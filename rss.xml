<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>affectalways</title>
        <link>https://affectalways.github.io/</link>
        <description>affectalways.</description>
        <generator>Hugo 0.72.0 https://gohugo.io/</generator>
        
            <language>en</language>
        
        
            <managingEditor>affectalways@gmail.com (affectalways)</managingEditor>
        
        
            <webMaster>affectalways@gmail.com (affectalways)</webMaster>
        
        
            <copyright>@2020 affectalways</copyright>
        
        <lastBuildDate>Thu, 02 Jul 2020 23:19:01 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://affectalways.github.io/rss.xml" />
        
        
            <item>
                <title>25 K 个一组翻转链表</title>
                <link>https://affectalways.github.io/posts/leetcode/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例：

给你这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5

当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5

当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;迭代&#34;&gt;迭代&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def reverseKGroup(self, head, k):
        cur = head
        if cur is None or cur.next is None:
            return cur

        tmp = list()
        while cur:
            tmp.append(cur)
            cur = cur.next

        pre = ListNode(None)
        cur = pre
        length = len(tmp)
        final_node = None
        if length % k &amp;lt; k and length % k != 0:
            final_node = tmp[-(length % k)]
        for node_index in range(k - 1, length, k):
            for key in range(k):
                cur.next = tmp[node_index - key]
                cur = cur.next
        cur.next = final_node
        return pre.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>33 搜索旋转排序数组</title>
                <link>https://affectalways.github.io/posts/leetcode/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解题思路&#34;&gt;解题思路：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;题目要求 O(logN)O(logN) 的时间复杂度，基本可以断定本题是需要使用二分查找，怎么分是关键。
由于题目说数字了无重复，举个例子：
1 2 3 4 5 6 7 可以大致分为两类，
第一类 2 3 4 5 6 7 1 这种，也就是 nums[start] &amp;lt;= nums[mid]。此例子中就是 2 &amp;lt;= 5。
这种情况下，前半部分有序。因此如果 nums[start] &amp;lt;=target&amp;lt;nums[mid]，则在前半部分找，否则去后半部分找。
第二类 6 7 1 2 3 4 5 这种，也就是 nums[start] &amp;gt; nums[mid]。此例子中就是 6 &amp;gt; 2。
这种情况下，后半部分有序。因此如果 nums[mid] &amp;lt;target&amp;lt;=nums[end]，则在后半部分找，否则去前半部分找。

此题有个存在重复数字的变形题，可参考 此题解 。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;代码&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def search(self, nums, target: int) -&amp;gt; int:
        if not nums:
            return -1
        if len(nums) == 1:
            if target in nums:
                return 0
            else:
                return -1
        length = len(nums)
        start = 0
        end = length - 1

        while start &amp;lt;= end:
            mid = start + (end - start) // 2
            if nums[mid] == target:
                return mid

            if nums[start] &amp;lt;= nums[mid]:
            #     前半部分有序
                if target &amp;gt;= nums[start] and target &amp;lt; nums[mid]:
                    end = mid - 1
                else:
                    start = mid + 1
            else:
                if target &amp;lt;= nums[end] and target &amp;gt; nums[mid]:
                    start = mid + 1
                else:
                    end = mid - 1
        return -1
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>39 组合综合</title>
                <link>https://affectalways.github.io/posts/leetcode/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个&lt;strong&gt;无重复元素&lt;/strong&gt;的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;
&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;所有数字（包括 target）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;回溯法&#34;&gt;回溯法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def combinationSum(self, candidates, target: int):
        if not candidates:
            return []
        result = []

        def isvalid(path, value, target):
            total = sum(path) + value
            if total &amp;gt; target:
                return False
            return True

        def backtrack(path, candidates):
            if sum(path) == target:
                path = sorted(path)
                if path not in result:
                    result.append(path)
                return None

            for value in candidates:
                if not isvalid(path, value, target):
                    continue
                path.append(value)

                backtrack(path, candidates)

                path.pop()

        backtrack([], candidates)
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>40 组合总和 II</title>
                <link>https://affectalways.github.io/posts/leetcode/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个数组** candidates **和一个目标数** target **，找出** candidates **中所有可以使数字和为** target **的组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;candidates&lt;/strong&gt; 中的每个数字在每个组合中&lt;strong&gt;只能使用一次&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;所有数字（包括目标数）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;回溯法&#34;&gt;回溯法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def combinationSum2(self, candidates, target: int):
        if not candidates:
            return []

        def isvalid(path, value):
            if (sum(path) + value) &amp;gt; target:
                return False
            return True

        def backtrack(path, rest):
            if sum(path) == target:
                path = sorted(path)
                if path not in result:
                    result.append(path)
                return
            for index, value in enumerate(rest):
                if not isvalid(path, value):
                    continue
                path.append(value)
                backtrack(path, rest[index + 1:])
                path.pop()

        result = []
        backtrack([], candidates)
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>22 括号生成</title>
                <link>https://affectalways.github.io/posts/leetcode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
例如，给出 n = 3，生成结果为：
[
  &amp;quot;((()))&amp;quot;,
  &amp;quot;(()())&amp;quot;,
  &amp;quot;(())()&amp;quot;,
  &amp;quot;()(())&amp;quot;,
  &amp;quot;()()()&amp;quot;
]
## 回溯算法

from collections import Counter


class Solution:
    def generateParenthesis(self, n: int):
        self.n = n
        # 结果
        result = []
        # 每次运行的
        track = []
        tmp = []

        def backtrack(path, options):
            if len(path) == n * 2:
                tmp.append(path)
                result.append(&#39;&#39;.join(path))
                return

            for i in range(len(options)):
                if not self.isvalid(path, options[i]):
                    continue
                path.append(options[i])

                backtrack(path, options)

                path.pop()

        backtrack(track, [&#39;(&#39;, &#39;)&#39;])
        return result

    def isvalid(self, path, next):
        if len(path) == 0 and next == &#39;)&#39;:
            return False

        count_dict = Counter(path)
        left_value = count_dict[&#39;(&#39;]
        right_value = count_dict[&#39;)&#39;]
        if next == &#39;)&#39; and right_value + 1 &amp;gt; left_value:
            return False

        for key, value in count_dict.items():
            if key == next and value == self.n:
                return False

        return True


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.generateParenthesis(3)
    print(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>23 合并K个排序链表</title>
                <link>https://affectalways.github.io/posts/leetcode/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;暴力解法&#34;&gt;暴力解法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;遍历所有链表，将所有节点的值放到一个数组中。
将这个数组排序，然后遍历所有元素得到正确顺序的值。
用遍历得到的值，创建一个新的有序链表。
# -*- coding: utf-8 -*-
# @Time     : 2020/3/29 1:14
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 23.py
# @Software : PyCharm 


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        # head = ListNode(-1)
        result = []
        for cur in lists:
            while cur:
                result.append(cur.val)
                cur = cur.next
        head = ListNode(-1)
        cur = head
        result.sort()
        for i in result:
            cur.next = ListNode(i)
            cur = cur.next

        return head.next


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head_1 = ListNode(1)
    node_2 = ListNode(4)
    node_4 = ListNode(5)
    head_1.next = node_2
    node_2.next = node_4

    head_2 = ListNode(1)
    node_3 = ListNode(3)
    node_4_copy = ListNode(4)
    head_2.next = node_3
    node_3.next = node_4_copy

    head_3 = ListNode(2)
    node_6 = ListNode(6)
    head_3.next = node_6

    tmp = [head_1, head_2, head_3]
    result = solution.mergeKLists(tmp)
    while result:
        print(result.val)
        result = result.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>24 两两交换链表中的节点</title>
                <link>https://affectalways.github.io/posts/leetcode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例&#34;&gt;示例:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
# -*- coding: utf-8 -*-
# @Time     : 2020/3/29 14:34
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 24.py
# @Software : PyCharm 

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def swapPairs(self, head):
        cur = head
        if cur is None or cur.next is None:
            return cur

        tmp = list()
        while cur:
            tmp.append(cur)
            cur = cur.next

        pre = ListNode(None)
        cur = pre
        length = len(tmp)
        final_node = None
        if length % 2 == 1:
            final_node = tmp[-1]
        for node_index in range(1, length, 2):
            cur.next = tmp[node_index]
            cur = cur.next
            cur.next = tmp[node_index - 1]
            cur = cur.next
        cur.next = final_node
        return pre.next


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head_1 = ListNode(1)
    node_2 = ListNode(2)
    node_3 = ListNode(3)
    node_4 = ListNode(4)
    head_1.next = node_2
    node_2.next = node_3
    node_3.next = node_4
    result = solution.swapPairs(head_1)

    while result:
        print(result.val)
        result = result.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>41 缺失的第一个正数</title>
                <link>https://affectalways.github.io/posts/leetcode/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [1,2,0]
输出: 3
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [3,4,-1,1]
输出: 2
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [7,8,9,11,12]
输出: 1
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>48 旋转图像</title>
                <link>https://affectalways.github.io/posts/leetcode/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;
&lt;p&gt;你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>54 螺旋矩阵</title>
                <link>https://affectalways.github.io/posts/leetcode/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;解决方案&#34;&gt;解决方案&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小

首先设定上下左右边界
其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界
判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案
若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理
不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案
class Solution:
    def spiralOrder(self, matrix):
        if not matrix:
            return matrix
        result = []
        # 高
        row_length = len(matrix)
        # 几列
        col_length = len(matrix[0])

        # 上边界
        up = 0
        # 下边界
        down = row_length
        #         左边界
        left = 0
        #         右边界
        right = col_length

        # 上下游标
        row_cur = 0
        # 左右游标
        col_cur = 0

        while True:
            # print(&amp;quot;left = {}, right = {}, up = {}, down = {}&amp;quot;.format(left, right, up, down))
            for col_cur in range(left, right):
                # print(&amp;quot;1 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新上边界
            up += 1
            if up &amp;gt;= down:
                break

            for row_cur in range(up, down):
                # print(&amp;quot;2 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新右边界
            right -= 1
            if right &amp;lt;= left:
                break

            for col_cur in range(right - 1, left - 1, -1):
                # print(&amp;quot;3 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新下边界
            down -= 1
            if down &amp;lt;= up:
                break

            for row_cur in range(down - 1, up - 1, -1):
                # print(&amp;quot;4 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新左边界
            left += 1
            if left &amp;gt;= right:
                break


        return result

if __name__ == &#39;__main__&#39;:
    solution = Solution()
    matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    matrix = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    matrix = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    result = solution.spiralOrder(matrix)
    print(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Werkzeug 源码解析(1)</title>
                <link>https://affectalways.github.io/posts/werkzeug/werkzeug_sc_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/werkzeug/werkzeug_sc_1/</guid>
                <pubDate>Tue, 23 Jun 2020 23:08:16 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;werkzeug是什么&#34;&gt;Werkzeug是什么？&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Werkzeug&lt;/code&gt;是一个基于&lt;a href=&#34;https://affectalways.github.io/posts/wsgi/wsgi_kl_1/&#34;&gt;WSGI&lt;/a&gt;的Web应用框架（说框架可能不合理，&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/&#34;&gt;官方文档&lt;/a&gt;给出的是&lt;code&gt;应用程序库&lt;/code&gt;）。想要了解更多请看&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;为什么要了解werkzeug&#34;&gt;为什么要了解Werkzeug？&lt;/h1&gt;
&lt;p&gt;因为目前所用的web框架为Flask，而Flask是以Werkzeug为基础的，所以绕不开Werkzeug了。&lt;/p&gt;
&lt;h1 id=&#34;基础知识&#34;&gt;基础知识&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://affectalways.github.io/posts/wsgi/wsgi_kl_1/&#34;&gt;WSGI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;生成器&lt;/li&gt;
&lt;li&gt;非常简单的网络知识&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Werkzeug 源码解析(2)</title>
                <link>https://affectalways.github.io/posts/werkzeug/werkzeug_sc_2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/werkzeug/werkzeug_sc_2/</guid>
                <pubDate>Tue, 23 Jun 2020 23:08:16 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;从哪开始呢&#34;&gt;从哪开始呢？&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;熟悉目录层级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参照&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/&#34;&gt;Werkzeug&lt;/a&gt;官方文档给出的&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/tutorial/#introducing-shortly&#34;&gt;示例&lt;/a&gt;，重点关注&lt;code&gt;Request&lt;/code&gt;,&lt;code&gt;Response&lt;/code&gt;,&lt;code&gt;run_simple&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;werkzeug.wrappers&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;
   
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;application&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;!&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;World&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mimetype&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;text/plain&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
   
   
&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; 省略超多内容
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shortly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Redis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_host&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_port&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dispatch_request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello World!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;wsgi_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dispatch_request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__call__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
   
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;create_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis_host&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis_port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with_static&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shortly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;
        &lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_host&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;n&#34;&gt;redis_host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_port&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;n&#34;&gt;redis_port&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with_static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi_app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SharedDataMiddleware&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;s1&#34;&gt;&amp;#39;/static&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dirname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;vm&#34;&gt;__file__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;static&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;
   
   
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;werkzeug.serving&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;run_simple&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;run_simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;use_debugger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;use_reloader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;requestresponserun_simple最不重要的&#34;&gt;Request、Response、run_simple（最不重要的）&lt;/h1&gt;
&lt;p&gt;之后的文章就重点关注以上三个，而且肯定会延伸到Werkzeug的其他地方（源码），不必担心，肯定会有所涉猎。&lt;/p&gt;
&lt;p&gt;讲真，感觉run_simple可以不重点关注，希望不要打脸&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Werkzeug 源码解析(3)</title>
                <link>https://affectalways.github.io/posts/werkzeug/werkzeug_sc_3/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/werkzeug/werkzeug_sc_3/</guid>
                <pubDate>Tue, 23 Jun 2020 23:08:16 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;werkzeug-request-源码解析&#34;&gt;Werkzeug Request 源码解析&lt;/h1&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from werkzeug.wrappers import Request, Response

def application(environ, start_response):
    request = Request(environ)
    text = &#39;Hello %s!&#39; % request.args.get(&#39;name&#39;, &#39;World&#39;)
    response = Response(text, mimetype=&#39;text/plain&#39;)
    return response(environ, start_response)

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意，之后&lt;code&gt;Request&lt;/code&gt;和&lt;code&gt;Response&lt;/code&gt;的相关源码都会围绕&lt;code&gt;Werkzeug&lt;/code&gt;给出的以上代码讲解。&lt;/p&gt;
&lt;h1 id=&#34;request-类&#34;&gt;Request 类&lt;/h1&gt;
&lt;h3 id=&#34;文件定位&#34;&gt;文件定位&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;src/werkzeug/wrappers/request.py&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;根据&lt;code&gt;Request&lt;/code&gt;类的名称其实就可以知道，&lt;code&gt;Request&lt;/code&gt;类是处理请求的，实际上，通过阅读相关代码，&lt;code&gt;Request&lt;/code&gt;类的作用确实如此&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BaseRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;AcceptMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ETagRequestMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;UserAgentMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;AuthorizationMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;CORSRequestMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;CommonRequestDescriptorsMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Full featured request object implementing the following mixins:
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`AcceptMixin` for accept header parsing
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`ETagRequestMixin` for etag and cache control handling
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`UserAgentMixin` for user agent introspection
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`AuthorizationMixin` for http auth handling
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`~werkzeug.wrappers.cors.CORSRequestMixin` for Cross
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;        Origin Resource Sharing headers
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`CommonRequestDescriptorsMixin` for common headers
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;​	根据注释可知，除了&lt;code&gt;BaseRequest&lt;/code&gt;类之外，其他的&lt;code&gt;Mixin&lt;/code&gt;类都是作为添加&lt;code&gt;高级方法&lt;/code&gt;的类。而且&lt;code&gt;Request&lt;/code&gt;类也没有&lt;code&gt;初始化&lt;/code&gt;方法，所以可以将注意力从&lt;code&gt;Request&lt;/code&gt;转移到&lt;code&gt;BaseRequest&lt;/code&gt;类上面。&lt;/p&gt;
&lt;h1 id=&#34;baserequest-类&#34;&gt;BaseRequest 类&lt;/h1&gt;
&lt;p&gt;截取以上代码示例的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request = Request(environ)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用父类&lt;code&gt;BaseRequest&lt;/code&gt;的&lt;code&gt;__init__&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;populate_request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;populate_request&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;werkzeug.request&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;
        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>02 两数相加</title>
                <link>https://affectalways.github.io/posts/leetcode/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &amp;quot;&amp;quot;&amp;quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &amp;quot;&amp;quot;&amp;quot;
        list_1 = &amp;quot;&amp;quot;
        list_2 = &amp;quot;&amp;quot;
        if not l1 and not l2:
            return 0

        while l1:
            list_1 += str(l1.val)
            l1 = l1.next
        num_1 = int(list_1[::-1]) if list_1 else 0
        while l2:
            list_2 += str(l2.val)
            l2 = l2.next
        num_2 = int(list_2[::-1]) if list_2 else 0
        sum = list(str(num_1 + num_2)[::-1])
        head = ListNode(sum[0])
        cur = head
        for i in range(1, len(sum)):
            cur.next = ListNode(sum[i])
            cur = cur.next
        return head
            
        
    
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>03 无重复字符的最长子串</title>
                <link>https://affectalways.github.io/posts/leetcode/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h5 id=&#34;给定一个字符串请你找出其中不含有重复字符的-最长子串-的长度&#34;&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/h5&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;abcabcbb&amp;quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解决方法可以进行改进&#34;&gt;解决方法（可以进行改进）&lt;/h4&gt;
&lt;h4 id=&#34;采用-滑动窗口-算法详见html&#34;&gt;采用 滑动窗口 算法，详见html&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def lengthOfLongestSubstring(self, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if not s:
            return 0
        uq = set(s)
        uq_length = len(uq)
        windows = s[0]
        left = 0
        right = 1
        max_len = 1
        for i in range(1, len(s)):
            flag_index = windows.find(s[i])
            if flag_index == -1:
                windows += s[i]
                right += 1
            else:
                left = flag_index + 1
                right += 1
                windows = windows[left:] + s[i]
            if max_len &amp;lt; len(windows):
                max_len = len(windows)
        return max_len
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>04 寻找两个有序数组的中位数</title>
                <link>https://affectalways.github.io/posts/leetcode/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        &amp;quot;&amp;quot;&amp;quot;
        nums1.extend(nums2)
        nums1.sort()
        length = len(nums1)
        if length % 2 == 1:
            return float(nums1[length // 2])
        else:
            return float(((nums1[length // 2] + nums1[length // 2 - 1])) / 2)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>05 马拉车算法</title>
                <link>https://affectalways.github.io/posts/leetcode/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liuwei0604/article/details/50414542&#34;&gt;https://blog.csdn.net/liuwei0604/article/details/50414542&lt;/a&gt; 马拉车算法可以在线性时间复杂度内求出一个字符串的最长回文字串。其核心思想跟 KMP 相似，即反复利用已掌握的情况。&lt;/p&gt;
&lt;h3 id=&#34;1整体思路&#34;&gt;1.整体思路&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;这个算法的主要思路是维护一个跟原串 str 一样长的数组 lens。lens[i] 表示以 str[i] 为中点的回串其中一边的长度。这里有的人把中点算进去，有的人记录两边的长度，其实都一样，我这里是只记录一边的长度，不包括中点。比如 &amp;quot;CDCDE&amp;quot;
str:  [C, D, C, D, E]
lens: [0, 1, 1, 0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么 lens 里最大的自然就对应最长回串的中点了。所以这个算法的核心就是如何快速计算 lens。&lt;/p&gt;
&lt;h3 id=&#34;2预处理&#34;&gt;2.预处理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;回文有奇偶长度两种情况，通过补充间隔符可以将这两种情况化简为奇数长度。

比如 ABA 补充为 #A#B#A# 中点还是 B，ABBA 补充为 #A#B#B#A# 中点为 #，最后可以去掉。

算法用 JavaScript 写，我将原串转为数组，间隔符就用 null。

最后在两侧补上哨兵点方便遍历中止。我用了 NaN。所以看起来是这样
var arr = [NaN, null]
for (let i = 0; i &amp;lt; str.length; i += 1) {
  arr.push(str[i])
  arr.push(null)
}
arr.push(NaN)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3详解&#34;&gt;3.详解&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。

首先我们解决下奇数和偶数的问题，在每个字符间插入 &amp;quot;#&amp;quot;，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 &amp;quot;^&amp;quot; 和 &amp;quot;$&amp;quot;，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。
马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。

首先我们解决下奇数和偶数的问题，在每个字符间插入 &amp;quot;#&amp;quot;，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 &amp;quot;^&amp;quot; 和 &amp;quot;$&amp;quot;，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/ad2b5e0da4a3a35b60f60c9a5a2be07a8074f9be0fe1597351eeff7dc460789a-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 &amp;quot;#&amp;quot; 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 &amp;quot;#c#b#c#b#c#&amp;quot;。而去掉 # 恢复到原来的字符串，变成 &amp;quot;cbcbc&amp;quot;，它的长度刚好也就是 5。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/ae2c30d48d35faa7f3d0d8bc4fe18d0691f3d13dcfc5846ddce1bf7a002681f5-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4求原字符串下标&#34;&gt;4.求原字符串下标&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。

例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;5求每个-p--i-&#34;&gt;5.求每个 P [ i ]&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;接下来是算法的关键了，它充分利用了回文串的对称性。

我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。

让我们考虑求 P [ i ] 的时候，如下图。

用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/29eb66280ca149c3bf5d9906e066b4a2b39d1bf8f9dd0533ca00479aca6f4f39-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。

但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;1超出了r&#34;&gt;(1)超出了R&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/b0d52a5f30747e55ef09b3c7b7cfc23026e37040edc41f387263e8f8a0ba8f49-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2-p--i_mirror--遇到了原字符串的左边界&#34;&gt;(2) P [ i_mirror ] 遇到了原字符串的左边界&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 &amp;quot;#&amp;quot; == &amp;quot;#&amp;quot;，之后遇到了 &amp;quot;^&amp;quot; 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3i-等于了-r&#34;&gt;(3)i 等于了 R&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;6考虑-c-和-r-的更新&#34;&gt;6.考虑 C 和 R 的更新&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/5fbe52880634a9d5fa60ad5e126e8c5c38c5a6eadd0c901a3495dc1307d46d6b-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。
public String preProcess(String s) {
    int n = s.length();
    if (n == 0) {
        return &amp;quot;^$&amp;quot;;
    }
    String ret = &amp;quot;^&amp;quot;;
    for (int i = 0; i &amp;lt; n; i++)
        ret += &amp;quot;#&amp;quot; + s.charAt(i);
    ret += &amp;quot;#$&amp;quot;;
    return ret;
}

// 马拉车算法
public String longestPalindrome2(String s) {
    String T = preProcess(s);
    int n = T.length();
    int[] P = new int[n];
    int C = 0, R = 0;
    for (int i = 1; i &amp;lt; n - 1; i++) {
        int i_mirror = 2 * C - i;
        if (R &amp;gt; i) {
            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R
        } else {
            P[i] = 0;// 等于 R 的情况
        }

        // 碰到之前讲的三种情况时候，需要利用中心扩展法
        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {
            P[i]++;
        }

        // 判断是否需要更新 R
        if (i + P[i] &amp;gt; R) {
            C = i;
            R = i + P[i];
        }

    }

    // 找出 P 的最大值
    int maxLen = 0;
    int centerIndex = 0;
    for (int i = 1; i &amp;lt; n - 1; i++) {
        if (P[i] &amp;gt; maxLen) {
            maxLen = P[i];
            centerIndex = i;
        }
    }
    int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标
    return s.substring(start, start + maxLen);
}
class Solution:
    def longestPalindrome(self, s):
        format_s = self.pre_process(s)
        length = len(format_s)
        ps = [0] * length

        center = 0
        right = 0
        for current in range(1, length - 1):
            current_mirror = 2 * center - current
            if (current + ps[current_mirror]) &amp;lt; right and (current_mirror - 1) != 0:
                ps[current] = ps[current_mirror]
            elif (current + ps[current_mirror]) &amp;lt; right and (current_mirror - 1) == 0:
                i = 1
                while (current - i) &amp;gt;= 0 and (current + i) &amp;lt; length and format_s[current - i] == format_s[current + i]:
                    ps[current] += 1
                    i+=1
                if ps[current] &amp;lt; ps[current_mirror]:
                    ps[current] = ps[current_mirror]
            else:
                i = 1
                while (current - i) &amp;gt;= 0 and (current + i) &amp;lt; length and format_s[current - i] == format_s[
                    current + i]:
                    ps[current] += 1
                    i += 1

            if ps[current] + center &amp;gt; right:
                center = current
                right = ps[current] + center

        max_length = 0
        center_index = 0
        for i in range(1, length -1):
            if ps[i] &amp;gt; max_length:
                max_length = ps[i]
                center_index = i
        start = (center_index - max_length) // 2
        return s[start:start + max_length]

    def pre_process(self, s):
        result = &amp;quot;#&amp;quot;
        for i in range(len(s)):
            result += s[i]
            result += &#39;#&#39;
        return result


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.longestPalindrome(&amp;quot;ababcbab&amp;quot;)
    print(result)
时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O ( n )。

空间复杂度：O(n)。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;时间复杂度从三次方降到了一次，美妙！这里两次用到了动态规划去求解，初步认识了动态规划，就是将之前求的值保存起来，方便后边的计算，使得一些多余的计算消失了。并且在动态规划中，通过观察数组的利用情况，从而降低了空间复杂度。而 Manacher 算法对回文串对称性的充分利用，不得不让人叹服，自己加油啦

作者：windliang
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>06 Z 字形变换</title>
                <link>https://affectalways.github.io/posts/leetcode/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &amp;ldquo;LEETCODEISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L   C   I   R
E T O E S I I G
E   D   H   N
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;ldquo;LCIRETOESIIGEDHN&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string convert(string s, int numRows);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 3
输出: &amp;quot;LCIRETOESIIGEDHN&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 4
输出: &amp;quot;LDREOEIIECIHNTSG&amp;quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;h4 id=&#34;算法&#34;&gt;算法:&lt;/h4&gt;
&lt;p&gt;这个 Z 字型其实是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/810b316c74a8eb0d2c97cbfc1bcf7559811f73b1bbed92848ba1bb7b9f1691b1-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于前面的 3行的 示例1 , 它的字符数分布是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/01f701396440902b127931f5a1a8a9ecbf70a9dc43ba2b7752a8756b8393e521-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于前面的 4 行的 示例2 , 它的字符数分布是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/89ba53b0da11c91a66dbb05a75e4b9d83e853bbe3a82c7860cde1a6c1e0c9c8e-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么对于 n 行的字符数分布是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/d610b140dd0789204efe699672dc72a83e7b826da0165bbf083d24fc97ecdea7-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我们可以发现：&lt;/p&gt;
&lt;h4 id=&#34;1当前行-currow-为-0-或-n-1-时箭头发生反向转折&#34;&gt;1.当前行 curRow 为 0 或 n-1 时，箭头发生反向转折。&lt;/h4&gt;
&lt;p&gt;方法一： 从左到右按箭头方向迭代 s ，将每个字符添加到合适的行。之后从上到下遍历行即可。&lt;/p&gt;
&lt;p&gt;我们假定 n=numRows :&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def convert(self, s, numRows):
        length = len(s)
        row_num = numRows
        if length &amp;lt;= row_num or row_num == 1:
            return s
        result = [&#39;&#39;]*row_num
        turn = False
        current = 0
        for c in s:
            result[current] += c
            if current == 0 or current == (row_num - 1):
                turn = not turn
            current += 1 if turn else -1
        r = &#39;&#39;
        for s in result:
            r += s
        return r

if __name__ == &#39;__main__&#39;:
    solution = Solution()
    solution.convert(&#39;LEETCODEISHIRING&#39;, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为只需遍历一次，所以时间复杂度为 &lt;code&gt;O(len(s))&lt;/code&gt;‘O(len(s))‘&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>07 整数反转</title>
                <link>https://affectalways.github.io/posts/leetcode/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: -123
输出: -321
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
class Solution:
    def reverse(self, x):
        &amp;quot;&amp;quot;&amp;quot;
        :type x: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        flag = True
        if x &amp;lt; 0:
            flag = False

        tmp = str(x)[::-1] if flag else &#39;-&#39; + str(x)[1:][::-1]
        result = int(tmp)
        if result &amp;lt; -2 ** 31 or result &amp;gt; (2 ** 31 - 1):
            return 0
        else:
            return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>08 字符串转换整数</title>
                <link>https://affectalways.github.io/posts/leetcode/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;
&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。&lt;/p&gt;
&lt;p&gt;该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。&lt;/p&gt;
&lt;p&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。&lt;/p&gt;
&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;42&amp;quot;
输出: 42
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;   -42&amp;quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;4193 with words&amp;quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;words and 987&amp;quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-5&#34;&gt;示例 5:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;-91283472332&amp;quot;
输出: -2147483648
解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−2^31) 。
class Solution:
    def myAtoi(self, str):
        fixed = str.strip()
        if not fixed:
            return 0

        symbol = [&#39;+&#39;, &#39;-&#39;]
        result = &#39;&#39;
        for i in range(0, len(fixed)):
            if fixed[i] == &#39;+&#39; and i == 0:
                continue
            elif (fixed[i] == &#39;-&#39; and i == 0) or fixed[i].isdigit():
                result += fixed[i]
            else:
                break
        if not result or result == &#39;-&#39; or result == &#39;+&#39;:
            return 0
        int_max = 2 ** 31 - 1
        int_min = -2 ** 31
        if int(result) &amp;gt; int_max:
            return int_max
        elif int(result) &amp;lt; int_min:
            return int_min
        return int(result)


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.myAtoi(&amp;quot;  0000000000012345678&amp;quot;)
    print(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>09 回文数</title>
                <link>https://affectalways.github.io/posts/leetcode/09-%E5%9B%9E%E6%96%87%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/09-%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 121
输出: true
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
进阶:

你能不将整数转为字符串来解决这个问题吗？
class Solution:
    def isPalindrome(self, x):
        &amp;quot;&amp;quot;&amp;quot;
        :type x: int
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        if str(x) == str(x)[::-1]:
            return True
        else:
            return False
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>11 盛最多水的容器</title>
                <link>https://affectalways.github.io/posts/leetcode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg?ynotemdtimestamp=1593701291427&#34; alt=&#34;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;图中垂直线代表输入数组
[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [1,8,6,2,5,4,8,3,7]
输出: 49
class Solution:
    def maxArea(self, height):
        length = len(height)
        max = 0
        left_index = 0
        right_index = length - 1
        while left_index &amp;lt; right_index:
            area = min(height[left_index], height[right_index]) * (right_index - left_index)
            if max &amp;lt; area:
                max = area
            if height[left_index] &amp;lt; height[right_index]:
                while left_index &amp;lt; right_index:
                    if height[left_index] &amp;lt; height[left_index + 1]:
                        left_index = left_index + 1
                        break
                    else:
                        left_index = left_index + 1
            else:
                right_index = right_index - 1
                while right_index &amp;lt; left_index:
                    if height[right_index] &amp;lt; height[right_index - 1]:
                        right_index = right_index - 1
                        break
                    else:
                        right_index -= 1
        return max
&amp;quot;&amp;quot;&amp;quot;
时间复杂度为O(n)， 空间复杂度为O(1)
思路：left、right游标分别从列表左右两端向中间靠拢
1、计算以left、right为左右游标的容量（取游标指向的值中较小的作为容器高度）
2、比较left、right两个游标指向值的大小，较小的往下一个位置移动，
否则随便选择一个游标下移，在本程序中固定选择右边的游标下移
3、重复步骤1 的计算，直到程序结束
&amp;quot;&amp;quot;&amp;quot;
class Solution:
    def maxArea(self, height: list) -&amp;gt; int:
        max = 0
        left = 0
        right = len(height) - 1
        while left &amp;lt; right:
            l = left  #暂存左边游标的位置
            r = right  #暂存右边游标的位置
            if height[left] &amp;lt; height[right]:
                h = height[left]
                left += 1
            else:
                h = height[right]
                right -= 1
            tmp = h * (r - l)  #计算当前容器的容量
            max = tmp if tmp &amp;gt; max else max
        return max
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>12 整数转罗马数</title>
                <link>https://affectalways.github.io/posts/leetcode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 3
输出: &amp;quot;III&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 4
输出: &amp;quot;IV&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 9
输出: &amp;quot;IX&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 58
输出: &amp;quot;LVIII&amp;quot;
解释: L = 50, V = 5, III = 3.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-5&#34;&gt;示例 5：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 1994
输出: &amp;quot;MCMXCIV&amp;quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
class Solution:
    def intToRoman(self, num):
        # store = {&#39;I&#39;: 1, &amp;quot;V&amp;quot;: 5, &amp;quot;X&amp;quot;: 10, &amp;quot;L&amp;quot;: 50, &amp;quot;C&amp;quot;: 100, &amp;quot;D&amp;quot;: 500, &amp;quot;M&amp;quot;: 1000, &amp;quot;IV&amp;quot;: 4, &amp;quot;IX&amp;quot;: 9, &amp;quot;XL&amp;quot;: 40, &amp;quot;XC&amp;quot;: 90,
        #          &amp;quot;CD&amp;quot;: 400, &amp;quot;CM&amp;quot;: 900}
        store = {1: &amp;quot;I&amp;quot;, 5: &amp;quot;V&amp;quot;, 10: &amp;quot;X&amp;quot;, 50: &#39;L&#39;, 100: &#39;C&#39;, 500: &#39;D&#39;, 1000: &#39;M&#39;, 4: &#39;IV&#39;, 9: &#39;IX&#39;, 40: &#39;XL&#39;, 90: &#39;XC&#39;,
                 400: &#39;CD&#39;,
                 900: &#39;CM&#39;}
        # store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True))
        store_list = sorted(store.keys(), reverse=True)
        print(store_list)
        result = []
        index = 0
        while True:
            for i in range(index, len(store_list)):
                value = store_list[i]
                if value &amp;lt;= num:
                    index = i
                    tmp = store_list[index]
                    num = num - tmp
                    result.append(store[tmp])
                    break
            if num == 0:
                break
        return &#39;&#39;.join(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>13 罗马数转整数</title>
                <link>https://affectalways.github.io/posts/leetcode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;III&amp;quot;
输出: 3
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;IV&amp;quot;
输出: 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;IX&amp;quot;
输出: 9
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;LVIII&amp;quot;
输出: 58
解释: L = 50, V= 5, III = 3.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-5&#34;&gt;示例 5:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;MCMXCIV&amp;quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
# -*- coding: utf-8 -*-
# @Time     : 2018/12/2 16:48
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 13.py
# @Software : PyCharm 

class Solution(object):
    def romanToInt(self, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        # store = {1: &amp;quot;I&amp;quot;, 5: &amp;quot;V&amp;quot;, 10: &amp;quot;X&amp;quot;, 50: &#39;L&#39;, 100: &#39;C&#39;, 500: &#39;D&#39;, 1000: &#39;M&#39;, 4: &#39;IV&#39;, 9: &#39;IX&#39;, 40: &#39;XL&#39;, 90: &#39;XC&#39;,
        #          400: &#39;CD&#39;,
        #          900: &#39;CM&#39;}
        store = {&#39;I&#39;: 1, &amp;quot;V&amp;quot;: 5, &amp;quot;X&amp;quot;: 10, &amp;quot;L&amp;quot;: 50, &amp;quot;C&amp;quot;: 100, &amp;quot;D&amp;quot;: 500, &amp;quot;M&amp;quot;: 1000, &amp;quot;IV&amp;quot;: 4, &amp;quot;IX&amp;quot;: 9, &amp;quot;XL&amp;quot;: 40, &amp;quot;XC&amp;quot;: 90,
                 &amp;quot;CD&amp;quot;: 400, &amp;quot;CM&amp;quot;: 900}
        # store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True))
        result = []
        length = len(s)
        index = 0
        while index &amp;lt; length:
            if (index +1) &amp;lt; length and (s[index] + s[index + 1]) in store.keys():
                result.append(store[s[index] + s[index + 1]])
                index += 2
            else:
                result.append(store[s[index]])
                index += 1

        tmp = 0
        for i in result:
            tmp += i
        return tmp


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    # print(solution.romanToInt(&amp;quot;III&amp;quot;))
    print(solution.romanToInt(&amp;quot;IV&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>14 最长公共前缀</title>
                <link>https://affectalways.github.io/posts/leetcode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。&lt;/p&gt;
&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]
输出: &amp;quot;fl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]
输出: &amp;quot;&amp;quot;
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。
# -*- coding: utf-8 -*-
# @Time     : 2018/12/2 22:48
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 14.py
# @Software : PyCharm 

class Solution:
    def longestCommonPrefix(self, strs):
        &amp;quot;&amp;quot;&amp;quot;
        :type strs: List[str]
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        length = len(strs)
        if length == 0 or (length == 1 and strs[0] == &#39;&#39;):
            return &amp;quot;&amp;quot;
        result = []

        min_length = len(min(strs, key=len))

        index = 0
        while index &amp;lt; min_length:
            flag = True
            all = None
            for value in strs:
                if all is None:
                    all = value[index]
                    continue
                if all == value[index]:
                    continue
                else:
                    flag = False
                    break

            if not flag:
                break
            else:
                index += 1
                result.append(all)
        return &#39;&#39;.join(result)


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    # print(solution.longestCommonPrefix([&amp;quot;flower&amp;quot;, &amp;quot;flow&amp;quot;, &amp;quot;flight&amp;quot;]))
    print(solution.longestCommonPrefix([&amp;quot;&amp;quot;, &amp;quot;&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>17 电话号码的字母组合</title>
                <link>https://affectalways.github.io/posts/leetcode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例:&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;输入：&amp;quot;23&amp;quot;
输出：[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].
方法：回溯
回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。

给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。

如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。
如果还有数字需要被输入：
遍历下一个数字所对应的所有映射的字母。
将当前的字母添加到组合最后，也就是 combination = combination + letter 。
重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/38567dcbb6401d88946ca974aacffb5ab27cb1ad54056f02b59016c0cc68b40f-file_1562774451350?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;问题转化成了从根节点到空节点一共有多少条路径&#34;&gt;问题转化成了从根节点到空节点一共有多少条路径；&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def letterCombinations(self, digits: str):
        if len(digits) == 0:
            return []
        number_al_dict = {
            &#39;2&#39;: &#39;abc&#39;,
            &#39;3&#39;: &#39;def&#39;,
            &#39;4&#39;: &#39;ghi&#39;,
            &#39;5&#39;: &#39;jkl&#39;,
            &#39;6&#39;: &#39;mno&#39;,
            &#39;7&#39;: &#39;pqrs&#39;,
            &#39;8&#39;: &#39;tuv&#39;,
            &#39;9&#39;: &#39;wxyz&#39;
        }
        if len(digits) == 1:
            return [i for i in number_al_dict[digits[0]]]

        tmp = []
        output = []

        def backtrack(path, next_numbers):
            if len(next_numbers) == 0:
                tmp.append(path)
                output.append(&amp;quot;&amp;quot;.join(path))
                return

            for letter in number_al_dict[next_numbers[0]]:
                # if letter in path:
                #     continue
                path.append(letter)
                backtrack(path, next_numbers[1:])
                path.pop()

        backtrack([], digits)
        return output
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>18 四数之和</title>
                <link>https://affectalways.github.io/posts/leetcode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
### 注意：

答案中不可以包含重复的四元组。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;解法1回溯法&#34;&gt;解法1：回溯法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def fourSum(self, nums, target: int):
        if len(nums) &amp;lt; 4:
            return []

        output = []

        def backtrack(path, next):
            if len(path) == 4:
                output.append(sorted(path))
                return

            for index, element in enumerate(next):
                path.append(element)
                backtrack(path, next[index + 1:])
                path.pop()

        backtrack([], nums)

        result = []
        for element in output:
            if sum(element) == target and element not in result:
                result.append(element)

        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>21 合并两个有序列表</title>
                <link>https://affectalways.github.io/posts/leetcode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
方法 2：迭代
想法

我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。

算法

首先，我们设定一个哨兵节点 &amp;quot;prehead&amp;quot; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。

在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/f6a8a3f573188706887808ef769ce3dc496e1bc3ef9b737e24498bd740442bb4-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# @Time     : 2020/3/27 23:37
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 21_.py
# @Software : PyCharm 

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode):
        # head = ListNode(-1)
        head = ListNode(-1)
        cur = head

        while l1 and l2:
            if l1.val &amp;lt;= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next

        cur.next = l1 if l2 is None else l2
        return head.next


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head_1 = ListNode(1)
    node_2 = ListNode(2)
    node_4 = ListNode(4)
    head_1.next = node_2
    node_2.next = node_4

    head_2 = ListNode(1)
    node_3 = ListNode(3)
    node_4_copy = ListNode(4)
    head_2.next = node_3
    node_3.next = node_4_copy

    result = solution.mergeTwoLists(head_1, head_2)
    while result:
        print(result.val)
        result = result.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>31 下一个排列</title>
                <link>https://affectalways.github.io/posts/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。

以 1,2,3,4,5,6 为例，其排列依次为：
123456
123465
123546
...
654321
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;算法推导&#34;&gt;算法推导&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：

1.我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
2.我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
（1）在尽可能靠右的低位进行交换，需要从后向前查找
（2）将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
（3）将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
以上就是求“下一个排列”的分析过程。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;算法过程&#34;&gt;算法过程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;标准的“下一个排列”算法可以描述为：

1.从后向前查找第一个**==相邻升序==**的元素对 (i,j)，满足 A[i] &amp;lt; A[j]。此时 [j,end) 必然是降序
2.在 [j,end) 从后向前查找第一个满足 A[i] &amp;lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」
3.将 A[i] 与 A[k] 交换
4.可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序
5.如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;可视化&#34;&gt;可视化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;以求 12385764 的下一个排列为例：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/6e8c9822771be77c6f34cd3086153984eec386fb8376e09e36132ac36bb9cd6f-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先从后向前查找第一个相邻升序的元素对 (i,j)。这里 i=4，j=5，对应的值为 5，7：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/d7acefea4f7d4e2f19fb5eaa269c448a3098eee53656926a0ab592c564dde150-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;然后在 [j,end) 从后向前查找第一个大于 A[i] 的值 A[k]。这里 A[i] 是 5，故 A[k] 是 6：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/061cf291c237e6f5bcd0554192f894cd0c3e361b4564aa542aabe96e644afbf1-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将 A[i] 与 A[k] 交换。这里交换 5、6：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/eb1470fd9942da6d2ab4855d13dfadcb715b629b4ea9cba0edfe2d1298744186-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这时 [j,end) 必然是降序，逆置 [j,end)，使其升序。这里逆置 [7,5,4]：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/9d627a4ffda635bbf0c4fcdb7b1359c557db8e1c300ab54383a0bc89f6763c18-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;因此，12385764 的下一个排列就是 12386457。

最后再可视化地对比一下这两个相邻的排列（橙色是蓝色的下一个排列）：
class Solution:
    def nextPermutation(self, nums) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        length = len(nums)
        guard = -1
        guard_index = length + 1
        index = length - 1
        while (index - 1) &amp;gt;= 0:
            if nums[index - 1] &amp;lt; nums[index]:
                guard = nums[index - 1]
                guard_index = index - 1
                break
            index = index - 1

        # print(&amp;quot;guard_index = {}, guard = {}&amp;quot;.format(guard_index, guard))
        if guard_index == (length + 1):
            return nums.sort(reverse=False)

        cur_index = length - 1
        while cur_index &amp;gt; guard_index:
            if nums[cur_index] &amp;gt; guard:
                break
            cur_index -= 1

        if cur_index &amp;gt;= length:
            cur_index = index
        nums[cur_index], nums[guard_index] = nums[guard_index], nums[cur_index]

        for i in range(guard_index + 1, length - 1):
            for j in range(guard_index + 1, length - 1):
                if nums[j] &amp;gt; nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>55 跳跃游戏</title>
                <link>https://affectalways.github.io/posts/leetcode/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;解题思路&#34;&gt;解题思路：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。&lt;/li&gt;
&lt;li&gt;可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。&lt;/li&gt;
&lt;li&gt;如果可以一直跳到最后，就成功了。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def canJump(self, nums) -&amp;gt; bool:
        length = len(nums)
        k = 0
        for i in range(length):
            if i &amp;gt; k:
                return False
            k = max(k, k + nums[i])
        return True
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>单例模式</title>
                <link>https://affectalways.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
                <pubDate>Mon, 22 Jun 2020 22:28:03 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>01 两数之和相加</title>
                <link>https://affectalways.github.io/posts/leetcode/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/</guid>
                <pubDate>Mon, 22 Jun 2020 21:51:44 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解法一&#34;&gt;解法一&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def twoSum(self, nums, target):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        if not len(nums):
            return []
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i,j]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解法二&#34;&gt;解法二&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;利用Python创建字典（即hash），同时有效避免了key相同的情况
class Solution:
    def twoSum(self, nums, target):
        dic = {}
        for i in range(len(nums)):
            if str(target - nums[i]) in dic:
                return [dic[str(target - nums[i])], i]
            dic[str(nums[i])] = i


&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Gunicorn 源码解析(1)</title>
                <link>https://affectalways.github.io/posts/gunicorn/gunicorn_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/gunicorn/gunicorn_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:29:06 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/gunicorn/">gunicorn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/server/">server</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/gunicorn/">gunicorn</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Celery 源码解析（1）</title>
                <link>https://affectalways.github.io/posts/celery/celery_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/celery/celery_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/celery/">celery</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（1）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（2）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_2/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（3）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_3/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_3/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（4）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_4/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_4/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（5）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_5/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_5/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（6）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_6/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_6/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>requests 源码解析（1）</title>
                <link>https://affectalways.github.io/posts/requests/requests_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/requests/requests_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/requests/">requests</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/requests/">requests</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>WSGI 理解（1）</title>
                <link>https://affectalways.github.io/posts/wsgi/wsgi_kl_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/wsgi/wsgi_kl_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h2 id=&#34;wsgi-是个什么东西&#34;&gt;WSGI 是个什么东西？&lt;/h2&gt;
&lt;p&gt;实际的生产环境中，Python应用程序是放在服务器的http server（比如Apache、Nginx等）上的。现在的问题是http server（之后以服务器代称）怎么把接收到的请求传递给Python应用程序？这就是WSGI做的事情。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WSGI（Web Server Gateway Interface）&lt;/code&gt;即Web服务器网关接口，解耦了&lt;code&gt;服务器（Apache、Nginx等）&lt;/code&gt;和&lt;code&gt;Python应用程序&lt;/code&gt;，是Python开发者只需要关注Python应用程序的开发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Web Server：即HTTP Server，接收用户的请求并返回响应信息；分为以下两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器，如Apache、Nginx等&lt;/li&gt;
&lt;li&gt;Python应用程序，负责处理业务逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/wsgi/wsgi_1/wsgi_1_framework.png?raw=true&#34; alt=&#34;wsgi_framework.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/wsgi/wsgi_1/wsgi_1_wsgi.png?raw=true&#34; alt=&#34;wsgi.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-server-实现&#34;&gt;HTTP Server 实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;服务器&lt;/code&gt;每接收到一个请求就调用一次&lt;code&gt;Python Application&lt;/code&gt;。&lt;code&gt;服务器&lt;/code&gt;作用如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收HTTP请求&lt;/li&gt;
&lt;li&gt;提供&lt;code&gt;environ&lt;/code&gt;和回调函数&lt;code&gt;start_response&lt;/code&gt;，并传给&lt;code&gt;callable object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;callable object&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是&lt;a href=&#34;https://www.python.org/dev/peps/pep-3333/#the-application-framework-side&#34;&gt;PEP-3333&lt;/a&gt;提供的示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os, sys

enc, esc = sys.getfilesystemencoding(), &#39;surrogateescape&#39;

def unicode_to_wsgi(u):
    # Convert an environment variable to a WSGI &amp;quot;bytes-as-unicode&amp;quot; string
    return u.encode(enc, esc).decode(&#39;iso-8859-1&#39;)

def wsgi_to_bytes(s):
    return s.encode(&#39;iso-8859-1&#39;)


def run_with_cgi(application):
	&amp;quot;&amp;quot;&amp;quot;
		application: 是Python Application中的callable object
	&amp;quot;&amp;quot;&amp;quot;
    # 构造environ变量，dict类型，里面的内容是一次HTTP请求的环境变量
    environ = {k: unicode_to_wsgi(v) for k,v in os.environ.items()}
    environ[&#39;wsgi.input&#39;]        = sys.stdin.buffer
    environ[&#39;wsgi.errors&#39;]       = sys.stderr
    environ[&#39;wsgi.version&#39;]      = (1, 0)
    environ[&#39;wsgi.multithread&#39;]  = False
    environ[&#39;wsgi.multiprocess&#39;] = True
    environ[&#39;wsgi.run_once&#39;]     = True

    if environ.get(&#39;HTTPS&#39;, &#39;off&#39;) in (&#39;on&#39;, &#39;1&#39;):
        environ[&#39;wsgi.url_scheme&#39;] = &#39;https&#39;
    else:
        environ[&#39;wsgi.url_scheme&#39;] = &#39;http&#39;

    headers_set = []
    headers_sent = []

    # 把响应信息写到终端
    def write(data):
        out = sys.stdout.buffer

        if not headers_set:
             raise AssertionError(&amp;quot;write() before start_response()&amp;quot;)

        elif not headers_sent:
             # Before the first output, send the stored headers
             status, response_headers = headers_sent[:] = headers_set
             out.write(wsgi_to_bytes(&#39;Status: %s\r\n&#39; % status))
             for header in response_headers:
                 out.write(wsgi_to_bytes(&#39;%s: %s\r\n&#39; % header))
             out.write(wsgi_to_bytes(&#39;\r\n&#39;))

        out.write(data)
        out.flush()

    # 定义start_response回调函数
    def start_response(status, response_headers, exc_info=None):
        if exc_info:
            try:
                if headers_sent:
                    # Re-raise original exception if headers sent
                    raise exc_info[1].with_traceback(exc_info[2])
            finally:
                exc_info = None     # avoid dangling circular ref
        elif headers_set:
            raise AssertionError(&amp;quot;Headers already set!&amp;quot;)

        headers_set[:] = [status, response_headers]

        # Note: error checking on the headers should happen here,
        # *after* the headers are set.  That way, if an error
        # occurs, start_response can only be re-called with
        # exc_info set.

        return write

    result = application(environ, start_response)
    try:
        # 处理application返回的结果（可迭代）
        for data in result:
            if data:    # don&#39;t send headers until body appears
                write(data)
        if not headers_sent:
            write(&#39;&#39;)   # send headers now if body was empty
    finally:
        if hasattr(result, &#39;close&#39;):
            result.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;中间件middleware&#34;&gt;中间件Middleware&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Middlerware&lt;/code&gt;是位于&lt;code&gt;Http Server&lt;/code&gt;和&lt;code&gt;Python Application&lt;/code&gt;之间的功能组件。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;Http Server&lt;/code&gt;而言，&lt;code&gt;Middlerware&lt;/code&gt;就是应用程序；对于&lt;code&gt;Python Application&lt;/code&gt;而言，&lt;code&gt;Middlerware&lt;/code&gt;就是&lt;code&gt;Http Server&lt;/code&gt;。&lt;code&gt;Middleware&lt;/code&gt;对&lt;code&gt;Http Server&lt;/code&gt;和&lt;code&gt;Python Application&lt;/code&gt;是透明的，把从&lt;code&gt;Http Server&lt;/code&gt;接收到的请求进行处理并向后传递，一直传递给&lt;code&gt;Python Application&lt;/code&gt;，最后把&lt;code&gt;Python Application&lt;/code&gt;的处理结果返回给&lt;code&gt;Http Server&lt;/code&gt;。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/wsgi/wsgi_1/wsgiframeworkmiddleware.png?raw=true&#34; alt=&#34;wsgi_middlerware.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Middlerware&lt;/code&gt;组件可执行以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 url 把用户请求调度到不同的 Python Application 中。&lt;/li&gt;
&lt;li&gt;负载均衡，转发用户请求&lt;/li&gt;
&lt;li&gt;预处理 XSL 等相关数据&lt;/li&gt;
&lt;li&gt;限制请求速率，设置白名单&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：WSGI 的 middleware 体现了 unix 的哲学之一：do one thing and do it well。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本例实现了一个关于异常处理的 middleware（&lt;a href=&#34;https://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/&#34;&gt;摘自&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sys import exc_info
from traceback import format_tb

class ExceptionMiddleware(object):
    &amp;quot;&amp;quot;&amp;quot;The middleware we use.&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        &amp;quot;&amp;quot;&amp;quot;Call the application can catch exceptions.&amp;quot;&amp;quot;&amp;quot;
        appiter = None
        # just call the application and send the output back
        # unchanged but catch exceptions
        try:
            appiter = self.app(environ, start_response)
            for item in appiter:
                yield item
        # if an exception occours we get the exception information
        # and prepare a traceback we can render
        except:
            e_type, e_value, tb = exc_info()
            traceback = [&#39;Traceback (most recent call last):&#39;]
            traceback += format_tb(tb)
            traceback.append(&#39;%s: %s&#39; % (e_type.__name__, e_value))
            # we might have not a stated response by now. try
            # to start one with the status code 500 or ignore an
            # raised exception if the application already started one.
            try:
                start_response(&#39;500 INTERNAL SERVER ERROR&#39;, [
                               (&#39;Content-Type&#39;, &#39;text/plain&#39;)])
            except:
                pass
            yield &#39;\n&#39;.join(traceback)

        # wsgi applications might have a close function. If it exists
        # it *must* be called.
        if hasattr(appiter, &#39;close&#39;):
            appiter.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;python-application&#34;&gt;Python Application&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Python Application&lt;/code&gt;端必须定义一个 &lt;code&gt;callable object&lt;/code&gt;，&lt;code&gt;callable object&lt;/code&gt; 可以是以下三者之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function/method&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance with a __call__ method&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;callable object&lt;/code&gt;必须满足以下两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收两个参数：environ（字典，WSGI的环境信息）、start_response（响应请求的函数, 返回HTTP status、headers给server）&lt;/li&gt;
&lt;li&gt;返回一个可迭代的值（iterable）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;environ&lt;/code&gt;和&lt;code&gt;start_response&lt;/code&gt;由&lt;code&gt;http server&lt;/code&gt;提供并实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;environ&lt;/code&gt;变量是包含环境变量的字典&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Python Application&lt;/code&gt;内部在返回前调用&lt;code&gt;start_response&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_response&lt;/code&gt;也是一个callable，接收两个必要的参数，&lt;code&gt;status&lt;/code&gt;和&lt;code&gt;response_headers&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;callable-object代码实现&#34;&gt;callable object代码实现&lt;/h4&gt;
&lt;h5 id=&#34;1functionmethod&#34;&gt;1.function/method&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;def application(environ, start_response):
	# 调用服务器程序提供的 start_response，填入两个参数
	start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/json&#39;)])
	return []
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;2class&#34;&gt;2.class&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class ApplicationClass(object):
	def __init__(self, environ, start_response):
		self.environ = environ
		self.start_response = start_response
	
	def __iter__(self):
		self.start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/json&#39;)])
		yield &amp;quot;随便&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for result in ApplicationClass(environ, start_response):
    do_somthing(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h5 id=&#34;3instance-with-a-__call__-method&#34;&gt;3.instance with a &lt;strong&gt;call&lt;/strong&gt; method&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class ApplicationClass(object):
	def __init__(self):
		pass
		
	def __call__(self, environ, start_response):
		start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/json&#39;)])
		yield &amp;quot;anything&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = ApplicationClass()
for result in app(environ, start_response):
	do_something(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;参考链接&#34;&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-3333/#the-application-framework-side&#34;&gt;PEP-3333&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/&#34;&gt;巨佬&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/wsgi/">WSGI</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/wsgi/">wsgi</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo 添加评论功能</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_comment/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_comment/</guid>
                <pubDate>Wed, 17 Jun 2020 21:48:44 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;不能评论&#34;&gt;不能评论!&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; 是一个强大的静态网页生成器，使用 go 开发，速度贼快。不过 Hugo 还比较年轻，没有像 &lt;a href=&#34;https://theme-next.iissnan.com/&#34;&gt;NexT&lt;/a&gt; 那样功能强大，成熟稳定的主题。所以很多东西需要自己动手撸。&lt;/p&gt;
&lt;p&gt;比如评论系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;评论系统排名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;valine &amp;gt; gitalk &amp;gt; gitment &amp;gt; livere &amp;gt; 畅言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于valine&#34;&gt;关于Valine&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/valine.png?raw=true&#34; alt=&#34;valine.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;官方网址： &amp;laquo;&lt;a href=&#34;https://valine.js.org/%3E%3E&#34;&gt;https://valine.js.org/&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其特性不一一赘述，官方网址有介绍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;添加评论区&#34;&gt;添加评论区&lt;/h2&gt;
&lt;p&gt;目前博客使用的主题是meme&lt;/p&gt;
&lt;p&gt;不同的主题可能有所区别，但原理大都类似&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理？&lt;/h3&gt;
&lt;p&gt;Hugo 会将 &lt;strong&gt;Markdown 文档&lt;/strong&gt; 按照 &lt;strong&gt;主题 (包括 HTML 模板、CSS、JavaScript 等)&lt;/strong&gt; 编译成静态网页&lt;/p&gt;
&lt;p&gt;那么我们只需要将 &lt;code&gt;Valine&lt;/code&gt;作为一个 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 插入到 HTML 模板中，然后在 &lt;code&gt;config.toml&lt;/code&gt; 中添加相关配置，就可以添加&lt;code&gt;评论区&lt;/code&gt;了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;leancloud相关配置&#34;&gt;Leancloud相关配置&lt;/h2&gt;
&lt;p&gt;评论系统依赖于&lt;code&gt;leancloud&lt;/code&gt;，所以需要先在&lt;code&gt;leancloud&lt;/code&gt;中进行相关的准备工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leancloud.cn/dashboard/login.html#/signin&#34;&gt;登录&lt;/a&gt; 或 &lt;a href=&#34;https://leancloud.cn/dashboard/login.html#/signup&#34;&gt;注册&lt;/a&gt; LeanCloud&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录成功后，进入后台点击左上角的创建应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud.png?raw=true&#34; alt=&#34;leancloud.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建好应用，进入应用，左边栏找到 &lt;strong&gt;设置&lt;/strong&gt; ，然后点击 &lt;strong&gt;应用Key&lt;/strong&gt;，此时记录出现的 &lt;strong&gt;App ID&lt;/strong&gt; 和 &lt;strong&gt;App Key&lt;/strong&gt;，后面配置文件中会用到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud_key.png?raw=true&#34; alt=&#34;lc_key.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 &lt;code&gt;Class&lt;/code&gt;，左边栏找到并点击 &lt;strong&gt;存储&lt;/strong&gt;，点击 &lt;strong&gt;创建Class&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud_class.png?raw=true&#34; alt=&#34;lc_class.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建两个存储Class，分别命名为: &lt;code&gt;Counter&lt;/code&gt; 和 &lt;code&gt;Comment&lt;/code&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还需要为应用添加安全域名，左边栏点击 &lt;strong&gt;设置&lt;/strong&gt;，找到 &lt;strong&gt;安全中心&lt;/strong&gt;，点击后会看到 &lt;strong&gt;安全域名&lt;/strong&gt; 设置框，输入博客使用的域名，点击保存即可：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud_safe.png?raw=true&#34; alt=&#34;lc_safe.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;configtoml开启comment&#34;&gt;config.toml开启comment&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;enableComments = false&lt;/code&gt;设置为&lt;code&gt;enableComments = true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;enableValine = false&lt;/code&gt;设置为&lt;code&gt;enableValine = true&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;添加 &lt;strong&gt;Valine&lt;/strong&gt; 参数项：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;## Valine
    enableValine = true
    valineAppId = &amp;quot;************&amp;quot;
    valineAppKey = &amp;quot;*****************&amp;quot;
    valinePlaceholder = &amp;quot;Just go go&amp;quot;
    valinePath = &amp;quot;&amp;quot;
    valineAvatar = &amp;quot;mm&amp;quot;
    valineMeta = [&amp;quot;nick&amp;quot;, &amp;quot;mail&amp;quot;, &amp;quot;link&amp;quot;]
    valinePageSize = 10
    valineLang = &amp;quot;zh-cn&amp;quot;
    valineVisitor = false
    valineHighlight = true
    valineAvatarForce = false
    valineRecordIP = false
    valineServerURLs = &amp;quot;&amp;quot;
    valineEmojiCDN = &amp;quot;&amp;quot;
    valineEmojiMaps = {}
    valineEnableQQ = false
    valineRequiredFields = []
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面几项内容的含义，这里简单一说，具体还是要看 &lt;a href=&#34;https://valine.js.org/configuration.html&#34;&gt;Valine官网中配置相关的内容&lt;/a&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;这是用于主题中配置的，不是官方Valine的参数，&lt;strong&gt;true&lt;/strong&gt;时控制开启此评论系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;appId&lt;/td&gt;
&lt;td&gt;这是在 &lt;a href=&#34;https://leancloud.cn/&#34;&gt;leancloud&lt;/a&gt; 后台应用中获取的，也就是上面提到的 &lt;strong&gt;App ID&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;appKey&lt;/td&gt;
&lt;td&gt;这是在 &lt;a href=&#34;https://leancloud.cn/&#34;&gt;leancloud&lt;/a&gt; 后台应用中获取的，也就是上面提到的 &lt;strong&gt;App Key&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;notify&lt;/td&gt;
&lt;td&gt;用于控制是否开启邮件通知功能，具体参考&lt;a href=&#34;https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE&#34;&gt;邮件提醒配置&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;verify&lt;/td&gt;
&lt;td&gt;用于控制是否开启评论验证码功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;avatar&lt;/td&gt;
&lt;td&gt;用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：&lt;a href=&#34;https://valine.js.org/avatar.html&#34;&gt;头像配置&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;placehoder&lt;/td&gt;
&lt;td&gt;评论框的提示符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;visitor&lt;/td&gt;
&lt;td&gt;控制是否开启文章阅读数的统计功能i, 详情阅读&lt;a href=&#34;https://valine.js.org/visitor.html&#34;&gt;文章阅读数统计&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;修改主题文件&#34;&gt;修改主题文件&lt;/h3&gt;
&lt;p&gt;主要是修改主题中评论相关的布局文件 &lt;code&gt;themes\meme\layouts\partials\components\comments.html&lt;/code&gt;，按照 &lt;a href=&#34;https://valine.js.org/quickstart.html&#34;&gt;Valine快速开始&lt;/a&gt; 添加 &lt;strong&gt;Valine&lt;/strong&gt; 相关代码，找到以下位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ if .Site.Params.enableValine }}
{{- end }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加的 &lt;strong&gt;Valine&lt;/strong&gt; 评论的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ if .Site.Params.enableValine }}
            &amp;lt;div id=&amp;quot;vcomments&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;script src=&amp;quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
			  &amp;lt;script src=&#39;//unpkg.com/valine/dist/Valine.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
			  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
				new Valine({
					el: &#39;#vcomments&#39; ,
					appId: &#39;{{ .Site.Params.valineAppId }}&#39;,
					appKey: &#39;{{ .Site.Params.valineAppKey }}&#39;,
					notify: &#39;{{ .Site.Params.valineNotify }}&#39;, 
					verify: &#39;{{ .Site.Params.valineVerify }}&#39;, 
					avatar:&#39;{{ .Site.Params.valineAvatar }}&#39;, 
					placeholder: &#39;{{ .Site.Params.valinePlaceholder }}&#39;,
					visitor: &#39;{{ .Site.Params.valineVisitor }}&#39;
				});
			  &amp;lt;/script&amp;gt;
        {{ end }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到上述代码中引用了配置文件中的相关参数，这样以后修改配置就不用修改代码了，只需要改配置文件 &lt;code&gt;config.toml&lt;/code&gt;。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo 让 GitHub Pages被索引到</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_seo/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_seo/</guid>
                <pubDate>Wed, 17 Jun 2020 21:00:29 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h2 id=&#34;居然都找不到&#34;&gt;居然都找不到！&lt;/h2&gt;
&lt;p&gt;其实Blog我主要是用来做一些记录，突然看到有博客提到GitHub Pages屏蔽了百度的爬虫，所以百度是搜索不到GitHub Pages上的网页的。&lt;/p&gt;
&lt;p&gt;什么？所以百度搜索搜不到我的个人博客？不死心，尝试一下，找得到github、gist主页，但是就是找不到github.io后缀的网页。除了百度之外，我还尝试了Bing、Google，都没有。&lt;/p&gt;
&lt;h2 id=&#34;如何让搜索引擎索引到呢&#34;&gt;如何让搜索引擎索引到呢？&lt;/h2&gt;
&lt;p&gt;发现流行的搜索引擎居然都找不到博客，那就需要赶紧找解决方法。Google和Bing还不清楚是怎么回事，但网上流传的email回复内容都点明了Github Pages禁止了百度爬虫的爬去，似乎原因是百度爬虫爬得太过于频繁，会严重影响服务器性能。针对百度爬虫的问题，大家找了很多方法。自建服务器托管博客、将博客放在Gitlab上或者CDN方法都不在我的选择范围内，因为暂时我还没有购买服务器或者域名的打算，所以决定放弃百度……但不管怎么样Bing和Google还是要设置好的！&lt;/p&gt;
&lt;h3 id=&#34;google&#34;&gt;Google&lt;/h3&gt;
&lt;h4 id=&#34;添加资源&#34;&gt;添加资源&lt;/h4&gt;
&lt;p&gt;在google搜索页面输入“site:affectalways.github.io”就可以看到这个网页是否被google索引到，如果没被索引到，在搜索结果页面就会直接提示你使用&lt;a href=&#34;https://search.google.com/search-console?utm_source=about-page&amp;amp;resource_id=https://affectalways.github.io/&#34;&gt;Google Search Console&lt;/a&gt;。登录后，如果是首次使用在Search Console中以下界面中选择“网页”类型资源，并将博客完整url填入其中，我填入“https://affectalways.github.io”。注意http或者https，www等最好能完全正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_seo/hugo_seo_1.png?raw=true&#34; alt=&#34;hugo_seo_1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果已经添加过资源，则需要点击左上角的按钮，然后和上面一样地添加资源即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_seo/hugo_seo_2.png?raw=true&#34; alt=&#34;hugo_seo_2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;资源添加后，需要验证你对该网站有所有权。Google提供了几种方法，我选择了三种方式：&lt;/p&gt;
&lt;h5 id=&#34;html验证文件上传&#34;&gt;HTML验证文件上传&lt;/h5&gt;
&lt;p&gt;只需要根据要求，下载HTML验证文件，把文件放在站点根目录的static目录下（以本网站为例：affectalways/static）&lt;/p&gt;
&lt;h5 id=&#34;html标记&#34;&gt;HTML标记&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;中的&lt;code&gt;googleSiteVerification = &amp;quot;&amp;quot;&lt;/code&gt; 设置为 &lt;code&gt;googleSiteVerification = 不为空&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找到&lt;code&gt;themes/meme/layouts/partials/head.html&lt;/code&gt;中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{- with .Site.Params.googleSiteVerification }}

        &amp;lt;meta name=&amp;quot;google-site-verification&amp;quot; content=&amp;quot;&amp;quot; /&amp;gt;

{{- end }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把&lt;code&gt;content&lt;/code&gt;内容改为给定的内容，然后执行&lt;code&gt;hugo&lt;/code&gt;命令，就可以验证了&lt;/p&gt;
&lt;h5 id=&#34;google-analytics&#34;&gt;Google Analytics&lt;/h5&gt;
&lt;p&gt;先到&lt;a href=&#34;https://marketingplatform.google.com/about/analytics/&#34;&gt;Google Analytics&lt;/a&gt;创建一个账号，并登录。&lt;/p&gt;
&lt;p&gt;新建一个资源，填完后获得&lt;code&gt;tracking code&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;更新&lt;code&gt;config.toml&lt;/code&gt;文件，把&lt;code&gt;enableGoogleAnalytics&lt;/code&gt;设为&lt;code&gt;true&lt;/code&gt;，&lt;code&gt;trackingCodeType&lt;/code&gt;设为&lt;code&gt;gtag&lt;/code&gt;（两个选择gtag和analytics，因为affectalways.github.io使用的是&lt;code&gt;Google Analytics给定的gtag.js&lt;/code&gt;，所以设置为gtag），&lt;code&gt;trackingID&lt;/code&gt;设为获取到的&lt;code&gt;tracking code&lt;/code&gt;。然后执行&lt;code&gt;hugo&lt;/code&gt;命令，就可以验证了。&lt;/p&gt;
&lt;h4 id=&#34;站点地图&#34;&gt;站点地图&lt;/h4&gt;
&lt;p&gt;在左侧点击“站点地图”，并在右侧点添加/测试站点地图，并添加url，我的是&lt;code&gt;https://affectalways.github.io/sitemap.xml&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;bing&#34;&gt;Bing&lt;/h3&gt;
&lt;p&gt;相似地，在&lt;a href=&#34;https://www.bing.com/webmaster/home&#34;&gt;Bing网站管理&lt;/a&gt;登陆、添加网站url。&lt;/p&gt;
&lt;p&gt;然后在左侧点击“配置我的网站&amp;gt;Sitemaps”，并在右侧加上sitemap的url，点击提交。&lt;/p&gt;
&lt;h3 id=&#34;百度不死心的尝试&#34;&gt;百度不死心的尝试&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不死心的失败了&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo 添加tags等分类</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_tags/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_tags/</guid>
                <pubDate>Wed, 17 Jun 2020 20:19:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;
&lt;p&gt;Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在&lt;a href=&#34;https://gohugo.io/content-management/taxonomies/&#34;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;分类taxonomy有3个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Taxonomy 分类&lt;/strong&gt;: 可以用来对内容进行分类的类别&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Term 术语&lt;/strong&gt;: 分类的一个键&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value 值&lt;/strong&gt;: 分配给这个Term的具体内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如我需要增加3个分类，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag：文章标签&lt;/li&gt;
&lt;li&gt;topic：文章主题/文章系列&lt;/li&gt;
&lt;li&gt;category：文章分类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如hugo，Value是打上这个标签的对应网页。&lt;/p&gt;
&lt;h3 id=&#34;配置分类&#34;&gt;配置分类&lt;/h3&gt;
&lt;p&gt;需要在 &lt;code&gt;config.toml&lt;/code&gt; 中增加分类。还是这个例子，则需要增加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[taxonomies]
tag = &amp;quot;tags&amp;quot;
category = &amp;quot;categories&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title: &amp;quot;Hugo添加tags等分类&amp;quot;
date: 2020-06-17T20:19:37+08:00
tags: [&amp;quot;hugo&amp;quot;]
draft: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然实际上，Hugo默认会产生 &lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt; 的分类，如果只需要这两个，可以不用在 &lt;code&gt;config.toml&lt;/code&gt; 中声明就在post头部使用。&lt;/p&gt;
&lt;h3 id=&#34;分类集合查看&#34;&gt;分类集合查看&lt;/h3&gt;
&lt;p&gt;使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。&lt;/p&gt;
&lt;p&gt;还是以tag为例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com/tags/&lt;/code&gt; 会列出tags中的所有术语；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com/tags/docker&lt;/code&gt; 会列出tags标为docker的所有网页列表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;额外知识点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;keywordsdescription&#34;&gt;keywords、description&lt;/h3&gt;
&lt;p&gt;meta标签的一个很重要的功能就是设置关键字，来帮助你的主页被各大搜索引擎登录，提高网站的访问量。在这个功能中，最重要的就是对Keywords和description的设置。因为按照搜索引擎的工作原理,搜索引擎首先派出机器人自动检索页面中的keywords和decription，并将其加入到自己的数据库，然后再根据关键词的密度将网站排序。因此，我们必须设置好关键字，来提高页面的搜索点击率。使用如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keywords: 
- hugo
- blog
- 博客
- 建站
description: &amp;quot;Hugo 添加tags等分类&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;keywords需要进行配置：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;themes\meme\layouts\partials\header.html&lt;/code&gt;的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;header class=&amp;quot;header&amp;quot;{{ if and (eq .Site.Params.headerLayout &amp;quot;flex&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部添加&lt;/p&gt;
&lt;meta content=&#34;{{ delimit .Keywords &#34;, &#34; }}&#34; name=&#34;keywords&#34;&gt;
就可以了
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;description是hugo支持的，不需要配置&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo blog（2）</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_install_2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_install_2/</guid>
                <pubDate>Tue, 16 Jun 2020 23:30:53 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;正如上一篇说的，我选择了&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;作为静态网页生成器。为何要放弃Hexo，换成Hugo呢？&lt;/p&gt;
&lt;p&gt;主要是出于以下考虑：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。&lt;/p&gt;
&lt;p&gt;2.同样得益于go，Hugo的安装配置看上去也并不麻烦；Hugo可以很轻松的被编译成二进制文件安装、运行。不必像Hexo一样依赖Node.js，也不必安装一堆依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Hugo的安装配置看上去也并不麻烦，同样得益于go，&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;p&gt;直接在&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;这里&lt;/a&gt;选择合适的版本。&lt;/p&gt;
&lt;p&gt;下载好后解压，将解压出来的可执行文件 (格式为 .exe)，放到自己喜欢的目录下。直接可以使用，不需要安装。&lt;/p&gt;
&lt;p&gt;但要记住一定要将你选择的文件夹路径加入到环境变量 &lt;code&gt;PATH&lt;/code&gt; 中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：由于theme选择的是meme，需要下载extended版本的hugo；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;初始化&#34;&gt;初始化&lt;/h1&gt;
&lt;p&gt;下面，初始化博客路径。首先需要选择一个路径来存放我们的博客，在你选好的路径下执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new site myBlog
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条命令会创建一个名为&lt;strong&gt;myBlog&lt;/strong&gt;（可以使用任意名字）的文件夹来存放你的博客。执行 &lt;strong&gt;cd myBlog&lt;/strong&gt; 命令进入文件夹。&lt;/p&gt;
&lt;p&gt;此时目录结构应该是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
└── myBlog
    ├── config.toml / config.yaml / config.json
    ├── content
    │   └── ...
    ├── layouts
    │   └── ...
    ├── themes
    │   └── ...
    ├── static
    │   └── ...
    ├── archetypes
    │   └── ...
    ├── data
    │   └── ...
    └── ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;config.toml&lt;/code&gt; 是网站的配置文件，Hugo还可使用 &lt;code&gt;config.yaml&lt;/code&gt; 或者 &lt;code&gt;config.json&lt;/code&gt; 进行配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content&lt;/code&gt; 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layouts&lt;/code&gt; 文件夹存放 &lt;code&gt;.html&lt;/code&gt; 格式的模板。模板确定了静态网站渲染的样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;themes&lt;/code&gt; 文件夹存放网站使用的theme主题模板。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;archetypes&lt;/code&gt; 文件夹存放网站预设置的文件模板头部，当使用 &lt;code&gt;hugo new&lt;/code&gt; 时即可生成一个带有该头部的实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;配置theme&#34;&gt;配置theme&lt;/h1&gt;
&lt;p&gt;可以在&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;这里&lt;/a&gt;找自己喜欢的主题。我暂时选择有搜索功能的meme，将主题clone到&lt;code&gt;themes&lt;/code&gt;目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/忘了/meme.git themes/meme
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将&lt;code&gt;themes/meme/exampleSite/config.toml&lt;/code&gt;模板配置文件复制到根目录，然后根据此文件来配置你的设置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：一定要把config.yaml中的theme修改为你使用的主体名称。比如我用的主题是meme，config.yaml文件就设置theme=&amp;quot;meme&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;创建新页面&#34;&gt;创建新页面&lt;/h1&gt;
&lt;p&gt;创建一个新页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new about.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时 &lt;code&gt;content&lt;/code&gt; 文件夹下就多了一个 &lt;code&gt;about.md&lt;/code&gt; 文件，打开文件就可以看到时间、文件名等信息已经自动生成了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;about&amp;quot;
date: 2020-06-16T23:30:53+08:00
draft: true
---
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两条 &lt;code&gt;---&lt;/code&gt; 间的信息是文章的配置信息，有的信息是自动生成的 (如：&lt;code&gt;title&lt;/code&gt;、&lt;code&gt;date&lt;/code&gt; 等)，简单介绍以下各项配置&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以下项目是自动生成的:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title:&lt;/code&gt; # 文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date:&lt;/code&gt; # 写作时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;draft:&lt;/code&gt; # 是否为草稿，如果为 &lt;code&gt;true&lt;/code&gt; 需要在命令中加入 &lt;code&gt;--buildDrafts&lt;/code&gt; 参数才会生成这个文档&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以下项目需要自行添加:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description:&lt;/code&gt; # 描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags:&lt;/code&gt; # 标签，用于文章分类&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;自动生成&lt;/code&gt; 和 &lt;code&gt;执行添加&lt;/code&gt; 的内容并不是绝对的，你可以根据自己的喜好配置模板文件 &lt;code&gt;archetypes/default.md&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;生成网站&#34;&gt;生成网站&lt;/h1&gt;
&lt;p&gt;设置完&lt;code&gt;config.toml&lt;/code&gt; 后我们执行以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo server --buildDrafts -w
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时你就可以在 &lt;code&gt;http://localhost:1313&lt;/code&gt; 访问到你的博客了。&lt;/p&gt;
&lt;p&gt;此时你的博客目录下就会多出一个&lt;code&gt;public&lt;/code&gt;目录，这是Hugo生成的网站。&lt;/p&gt;
&lt;p&gt;简单介绍一下两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--buildDrafts&lt;/code&gt;: 生成被标记为 「草稿」 的文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;: 监控更改，如果发生更改直接显示到博客上&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：但此时只能在本地访问 (相当于预览博客，如果与期望值不符，可以随时更改)，如果想发布到 &lt;code&gt;Github Pages&lt;/code&gt; 上需要先将文章配置信息中的 &lt;code&gt;draft:&lt;/code&gt; 改为 &lt;code&gt;false&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;然后执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;h1 id=&#34;github-pages部署&#34;&gt;GitHub Pages部署&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&#34;https://help.github.com/articles/user-organization-and-project-pages/&#34;&gt;这里&lt;/a&gt;，在Github Pages有四种类型，而对于非组织型用户来说有两种，一种是用户的个人网站，网页域名为 &lt;code&gt;username.github.io&lt;/code&gt;，另一种为Project的主页，网页域名为 &lt;code&gt;username.github.io/projectname&lt;/code&gt;。Github Pages对于Project主页的源码要求有了修改，现在也可以放置在master上，之前版本中必须放在&lt;code&gt;gh-pages&lt;/code&gt; 分支上，不过这里暂且不提，主要还是关心用户个人主页。&lt;/p&gt;
&lt;p&gt;这就需要你在Github上建立一个以 &lt;code&gt;username.github.io&lt;/code&gt; 为名称的repository，对于我来说就是 &lt;code&gt;affectalways.github.io&lt;/code&gt;。此外，需要将Hugo生成的所有静态网页push到这个repository的master分支上。现在就可以用这个域名打开个人网站了。&lt;/p&gt;
&lt;p&gt;Hugo没有提供自动发布到GitHub Pages的功能。需要将&lt;code&gt;public&lt;/code&gt;中的内容手动上传到Github上。&lt;/p&gt;
&lt;p&gt;首先执行命令&lt;code&gt;cd public&lt;/code&gt;进入到&lt;code&gt;public&lt;/code&gt;目录，然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
git remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git
git add .
git commit -m &amp;quot;[介绍，随便写点什么，比如日期]&amp;quot;
git push （若是第一次发布，需要用到--set-upstream）
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo blog（1）</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_install_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_install_1/</guid>
                <pubDate>Tue, 16 Jun 2020 22:55:34 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;初始&#34;&gt;初始&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;养个blog的想法从很早就有了但是&#34;&gt;养个Blog的想法从很早就有了，但是…&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;从本科开始就一直想要一个自己的Blog，一直没有行动。本身我就没有记日志的习惯，也没有需求和冲动写下什么东西，虽然有时想记下学的内容，但有道云笔记就够了，也没什么写技术博客的想法。除了很久之前偶尔在CSDN写了几篇入门级文章，也就没有其他了。此外，虽说博客最重要的是内容，但没有一个好的生态环境和前端界面设计，至少对于我而言，没有任何兴趣花时间在上面，原谅我是外观主义者。对于界面设计，CSDN或者博客园实在不敢恭维，尤其是CSDN。自建网站之前也尝试过，恩，还要使用服务器，花钱。我得承认，当时作为本科生的我，太过局限于学校课堂，并未走出去看看，对于网络信息的运用和挖掘也更多停留在看看答案、找找软件、翻翻视频的基础使用上，最多也就是查看下算法之类的。&lt;/p&gt;
&lt;p&gt;最近，特别是正式工作快一年了，更多地接触了“网络世界”的信息和知识，拓宽了实页。随着自我学习机会和时间愈少，碎片化学习和感想也愈多，加上虽然网上知识丰富，但内容驳杂，过段时间想再查找却需要对这些信息重新筛选、略感费劲，再加上工作后个人体悟良多，于是又一次萌生个人博客的想法。&lt;/p&gt;
&lt;h1 id=&#34;难产&#34;&gt;难产&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;选择恐惧症控制狂的特质决定了我家blog的难产&#34;&gt;选择恐惧症+控制狂的特质决定了我家Blog的难产&amp;hellip;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管现在有许多像知乎专栏这样现代化的界面和良好的用户群的网站可以让人直接在上面写作，但我还是更倾向于GitHub Pages，与GitHub非常紧密的关系是该倾向性很重要的原因（这对码农而言，非常有诱惑力）。&lt;/p&gt;
&lt;p&gt;GitHub Pages搭建个人博客，使用的是轻量级的静态网页，网上已经有了很多教程和方案。几天前遇到了三种方案：Jekyll、Hexo、Hugo。Jekyll据说可定制化和功能很强大，但是ruby个人真的很不能接受。Hexo是国人教程最多的，国外口碑也非常好，看到外国的一句评论说，缺点就是大多数内容都是中文，英文教程少，哈哈。Hexo是基于Node.js，对于程序员相当友好。不过这次我决定选择另一个Framework，使用Hugo。Hugo是用现在大热的go语言写的，据说编译起来比Hexo还会快很多。而且我最近在学go&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;开始&#34;&gt;开始&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;开始吧&#34;&gt;开始吧&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;那就开始吧&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>使用Hugo &#43; GitHub Pages搭建个人博客</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_install/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_install/</guid>
                <pubDate>Tue, 16 Jun 2020 22:40:14 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_install/hugo.png?raw=true&#34; alt=&#34;hugo.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	Hugo：是一种通用的网站框架。严格来说，这类应用应该被称作静态网站生成器。这类应用将 Markdown 文件和主题一起编译成由 HTML、CSS、JavaScript 组成的静态网页。&lt;/p&gt;
&lt;p&gt;​	然后上传到 GitHub 上，通过 GitHub 提供的静态页面托管服务 (GitHub Pages) 进行访问。&lt;/p&gt;
&lt;p&gt;​	这里就写一篇文章来记录一下踩过的坑。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
