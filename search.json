[{"categories":["golang"],"content":"GoLand 2020版破解教程\n本教程适用于GoLand 2020 1.4版本，其他版本理论上是一致的。\nGoLand下载地址\n下载地址\n激活步骤\n  下载GoLand\n  下载破解补丁文件，jetbrains-agent-latest.zip破解补丁下载地址\n  安装GoLand，正常安装即可\n  进入激活界面，选择免费试用（Evaluate for free）\n  用GoLand随便打开一个已存在的项目（或者创建一个）\n  拖入zip文件\n  按箭头操作即可\n  查看是否激活成功\n点击Help --\u003e About\r","description":"","tags":["go"],"title":"Goland 2020版破解","uri":"/posts/golang/goland2020%E7%89%88%E7%A0%B4%E8%A7%A3/"},{"categories":["leetcode","数组"],"content":"1051. 高度检查器 ","description":"leetcode，1051 高度检查器","tags":["leetcode"],"title":"1051 高度检查器","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。\n示例：\n给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 k = 2.\r返回链表 4-\u003e5.\r解题思路\n1.快指针和慢指针相差k\r2.快指针到达链尾，慢指针所指方向就是倒数第k个链表\r代码\nclass Solution(object):\rdef getKthFromEnd(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: ListNode\r\"\"\"\rfast = head\rfor i in range(k):\rfast = fast.next\rcur = head\rwhile fast:\rcur = cur.next\rfast = fast.next\rreturn cur\r解题思路\n1.获取链表长度\r2.开始遍历（链表长度-k）次数\r代码\nclass Solution(object):\rdef getKthFromEnd(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: ListNode\r\"\"\"\rlength = 0\rcur = head\rwhile cur:\rlength += 1\rcur = cur.next\rcur = head\rindex = length - k\rfor i in range(index):\rcur = cur.next\rreturn cur\r","description":"leetcode，Offer22 链表中倒数第K个节点","tags":["leetcode"],"title":"Offer22 链表中倒数第K个节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"141. 环形链表 给定一个链表，判断链表中是否有环。\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\r输出：true\r解释：链表中有一个环，其尾部连接到第二个节点。\r示例 2：\n输入：head = [1,2], pos = 0\r输出：true\r解释：链表中有一个环，其尾部连接到第一个节点。\r示例 3：\n输入：head = [1], pos = -1\r输出：false\r解释：链表中没有环。\r进阶：\n你能用 O(1)（即，常量）内存解决此问题吗？\n 思路\n当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。\r根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。\r代码\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/22 22:19\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 141.py\r# @Software : PyCharm # -*- coding: utf-8 -*-\r# @Time : 2020/7/16 22:27\r# @Author : affectalways\r# @Site :\r# @Contact : affectalways@gmail.com\r# @File : 0201.py\r# @Software : PyCharm\r# Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef hasCycle(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: bool\r\"\"\"\rif not head:\rreturn False\rfast = head.next\rslow = head\rwhile fast != slow:\rif fast is None or fast.next is None:\rreturn False\rslow = slow.next\rfast = fast.next.next\rreturn True\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 3, 2, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.hasCycle(head)\rtraversal_link(result)\r","description":"leetcode，141 环形链表","tags":["leetcode"],"title":"141环形链表","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["python"],"content":"郑重声明：本篇文章非原创，摘自https://www.zlovezl.cn/articles/instagram-pycon-2017/\nPyCon 简介 PyCon 是全世界最大的以 Python 编程语言 为主题的技术大会。大会由 Python 社区组织，每年举办一次。在大会上，来自世界各地的 Python 用户与核心开发者齐聚一堂，共同分享 Python 世界的新鲜事、Python 语言的应用案例、使用技巧等等内容。\nInstagram 简介 Instagram 是一款移动端的照片与视频分享软件，由 Kevin Systrom 和 Mike Krieger 在 2010 年创办。Instagram 在发布后开始快速流行。于 2012 年被 Facebook 以 10 亿美元的价格收购。而当时 Instagram 的员工仅有区区 13 名。\n如今，Instagram 的总注册用户达到 30 亿，月活用户超过 7 亿 （作为对比，微信最新披露的月活跃用户为 9.38 亿）。而令人吃惊的是，这么高的访问量背后，竟完全是由以速度慢著称的 Python + Django 支撑。\n在 Python 2017 上，Instagram 的工程师们带来了一个有关 Python 在 Instagram 的主题演讲，同时还分享了 Instagram 如何将整个项目运行环境升级到 Python 3 的故事。\n本文为该次演讲的内容摘要。\nPython @Instagram 为什么选择 Python 和 Django Instagram 选择 Django 的原因很简单，Instagram 的两位创始人 (Kevin Systrom and Mike Krieger) 都是产品经理出身。在他们想要创造 Instagram 时，Django 是他们所知道的最稳定和成熟的技术之一。\n时至今日，即使已经拥有超过 30 亿的注册用户。Instagram 仍然是 Python 和 Django 的重度使用者。Instagram 的工程师 Hui Ding 说到： 『一直到用户 ID 已经超过了 32bit int 的限额（约为 20 亿），Django 本身仍然没有成为我们的瓶颈所在。』\n不过，除了使用 Django 的原生功能外，Instagram 还对 Django 做了很多定制化工作：\n  扩展 Django Models 使其支持 Sharding （一种数据库分片技术），Instagram Engneering 博客专门为这件事情写过一篇博客，可参阅：Sharding \u0026 IDs at Instagram\n  手动关闭 GC（垃圾回收）来提升 Python 内存管理效率，他们同样也写过一篇博客来说明这件事情：Dismissing Python Garbage Collection at Instagram\n  在位于不同地理位置的多个数据中心部署整套系统\n  Python 语言的优势所在 Instagram 的联合创始人 Mike Krieger 说过： 『我们的用户根本不关心 Instagram 使用了哪种关系数据库，他们当然也不关心 Instagram 是用什么编程语言开发的。』\n所以，Python 这种 简单 而且 实用至上 的编程语言最终赢得了 Instagram 的青睐。他们认为，使用 Python 这种简单的语言有助于塑造 Instagram 的工程师文化，那就是：\n 专注于定位问题、解决问题 - 而不是工具本身的各种花花绿绿的特性 使用那些经过市场验证过的成熟技术方案 - 而不用被工具本身的问题所烦扰 用户至上：专注于用户所能看到的新特性，为用户带去价值  但是，即使使用 Python 语言有这么多好处，它还是很慢，不是吗？\n不过，这对于 Instagram 不是问题，因为他们认为：『Instagram 的最大瓶颈在于开发效率，而不是代码的执行效率』\n At Instagram, our bottleneck is development velocity, not pure code execution.\n 所以，最终的结论是：你完全可以使用 Python 语言来实现一个超过几十亿用户使用的产品，而根本不用担心语言或框架本身的性能瓶颈。\n如何提升运行效率 但是，即使是选用了拥有诸多好处的 Python 和 Django。在 Instagram 的用户数迅速增长的过程中，性能问题还是出现了：服务器数量的增长率已经慢慢的超过了用户增长率。Instagram 是怎么应对这个问题的呢？\n他们使用了这些手段来缓解性能问题：\n 开发工具来帮助调优：Instagram 开发了很多涵盖各个层面的工具，来帮助他们进行性能调优以及找到性能瓶颈。 使用 C/C++ 来重写部分组件：把那些稳定而且对性能最敏感的组件，使用 C 或 C++ 来重写，比如访问 memcache 的 library。 使用 Cython：Cython 也是他们用来提升 Python 效率的法宝之一。  除了上面这些手段，他们还在探索异步 IO 以及新的 Python Runtime 所能带来的性能可能性。\n升级到 Python 3 在相当长的一段时间，Instagram 都跑在 Python 2.7 + Django 1.3 的组合之上。在这个已经落后社区很多年的环境上，他们的工程师们还打了非常非常多的小 patch。难道他们要被永远卡在这个版本上吗？\n所以，在经过一系列的讨论后，他们最终做出一个重大的决定：升级到 Python 3！！\n事实上，Instagram 目前已经完成了将运行环境迁移到 Python 3 的工作 - 他们的整套服务已经在 Python 3 上跑了好几个月了。那么他们是怎么做到的呢？接下来便是由 Instagram 工程师 Lisa guo 带来的 Instagram 如何迁移到 Python 3 的故事。\nInstagram 升级到 Python 3 的故事 为什么要升级到 Python 3 对于 Instagram 来说，下面这些因素是推动他们将运行环境迁移到 Python 3 的主要原因：\n1. 新特性：类型注解 Type Annotations 看看下面这段代码：\ndef compose_from_max_id(max_id):\r'''@param str max_id'''\r图中函数的 max_id 参数究竟是什么类型呢？int？tuple？或是 list? 等等，函数文档里面说它是 str 类型。\n但随着时间推移，万一这个参数的类型发生变化了呢？如果某位粗心的工程师修改代码的同时忘了更新文档，那就会给函数的使用者带来很大麻烦，最终还不如没有注释呢。\n2. 性能 Instagram 的整个 Django Stack 都跑在 uwsgi 之上，全部使用了同步的网络 IO。这意味着同一个 uwsgi 进程在同一时间只能接收并处理一个请求。这让如何调优每台机器上应该运行的 uwsgi 进程数成了一个麻烦事：\n为了更好利用 CPU，使用更多的进程数？但那样会消耗大量的内存。而过少的进程数量又会导致 CPU 不能被充分利用。\n为此，他们决定跳过 Python 2 中哪些蹩脚的异步 IO 实现 （可怜的 gevent、tornado、twisted 众），直接升级到 Python 3，去探索标准库中的 asyncio 模块所能带来的可能性。\n3. 社区 因为 Python 社区已经停止了对 Python 2 的支持。如果把整个运行环境升级到 Python 3，Instagram 的工程师们就能和 Python 社区走的更近，可以更好的把他们的工作回馈给社区。\n确定迁移方案 在 Instagram，进行 Python 3 的迁移需要必须满足两个前提条件：\n 不停机，不能有任何的服务因此不可用 不能影响产品新特性的开发  但是，在 Instagram 的开发环境中，要满足上面这两点来完成迁移到 Python 3.6 这种庞大的工程是非常困难的。\n基于主分支的开发流程 即便使用了以多分支功能著称的 git，Instagram 所有的开发工作都是主要在 master 分支上进行的，Instagram 所奉行的开发哲学是：『不管是多大的新特性或代码重构，都应该拆解成较小的 Commit 来进行。』\n那些被合并进 master 分支的代码，都将在一个小时内被发布到线上环境。**而这样的发布过程每天将会发生上百次。**在这么频繁的发布频率下，如何在满足之前的那两个前提下来完成迁移变得尤其困难。\n被弃用的迁移方案 创建一个新分支\n很多人在处理这类问题时，第一个蹦进脑子的想法就是： 『让我们创建一个分支，当我们开发完后，再把分支合并进来』\n但在 Instagram 这么高的迭代频率上，使用一个独立分支并不是好主意：\n Instagram 的 Codebase 每天都在频繁更新，在开发 Python 3 分支的过程中，让新分支与现有 master 分支保持同步开销极大，同时极易出错 最终将 Python 3 分支这个改动非常多的分支合并回 Master 拥有非常高的风险 只有少数几个工程师在 Python 3 分支上专职负责升级工作，其他想帮助迁移工作的工程师无法参与进来  挨个替换接口\n还有一个方案就是，挨个替换 Instagram 的 API 接口。但是 Instagram 的不同接口共享着很多通用模块。这个方案要实施起来也非常困难。\n微服务\n还有一个方案就是将 Instagram 改造成微服务架构。通过将那些通用模块重写成 Python 3 版本的微服务来一步步完成迁移工作。\n但是这个方案需要重新组织海量的代码。同时，当发生在进程内的函数调用变成 RPC 后 ，整个站点的延迟会变大。此外，更多的微服务也会引入更高的部署复杂度。\n所以，既然 Instagram 的开发哲学是：小步前进，快速迭代。他们最终决定的方案是：一步一步来，最终让 master 分支上的代码同时兼容 Python 2 和 Python 3 。\n开始迁移工作 既然要让整个 codebase 同时兼容 Python 2 和 Python 3，那么首先要符合这点的就是那些被大量使用的第三方 package。针对第三方 package，Instagram 做到了下面几点：\n 拒绝引入所有不兼容 Python 3 的新 package 去掉所有不再使用的 package 替换那些不兼容 Python 3 的 package  在代码的迁移过程中，他们使用了工具 modernize 来帮助他们。\n使用 modernize 时，有一个小技巧：每次修复多个文件的一个兼容问题，而不是一下修复一个文件中的多个兼容问题。 这样可以让 Code Review 过程简单很多，因为 Reviewer 每次只需要关注一个问题。\n使用单元测试来帮助迁移 对于 Python 这种灵活性极强的动态语言来说，除了真正去执行代码外，几乎没有其他比较好的检查代码错误的手段。\n前面提到，Instagram 所有被合并到 master 的代码提交会在一个小时内上线到线上环境，但这不是没有前提条件的。在上线前，所有的提交都需要通过成千上万个单元测试。\n于是，他们开始加入 Python 3 来执行所有的单元测试。一开始，只有极少数的单元测试能够在 Python 3 环境下通过，但随着 Instagram 的工程师们不断的修复那些失败的单元测试，最终所有的单元测试都可以在 Python 3 环境下成功执行。\n单元测试的局限性 但是，单元测试也是有局限性的：\n Instagram 的单元测试没有做到 100% 的代码覆盖率 很多第三方模块都使用了 mock 技术，而 mock 的行为与真实的线上服务可能会有所不同  所以，当所有的单元测试都被修复后，他们开始在线上正式使用 Python 3 来运行服务。\n这个过程并不是一蹴而就的。首先，所有的 Instagram 工程师开始访问到这些使用 Python 3 来执行的新服务，然后是 Facebook 的所有雇员，随后是 0.1%、20% 的用户，最终 Python 3 覆盖到了所有的 Instagram 用户。\n迁移过程的技术问题 Instagram 在迁移到 Python 3 时碰到很多问题，下面是最典型的几个：\nUnicode 相关的字符串问题 Python 3 相比 Python 2 最大的改动之一，就是在语言内部对 unicode 的处理。\n在 Python 2 中，文本类型 （也就是 unicode） 和二进制类型 （也就是 str） 的边界非常模糊。很多函数的参数既可以是文本，也可以是二进制。但是在 Python 3 中，文本类型和二进制类型的字符串被完全的区分开了。\n于是，下面这段在 Python 2 下可以正常运行的代码在 Python 3 下就会报错：\nmymac = hmac.new('abc')\rTypeError: key: expected bytes or bytearray, but got 'str'\r解决办法其实很简单，只要加上判断：如果 value 是文本类型，就将其转换为二进制。如下所示：\nvalue = 'abc'\rif isinstance(value, six.text_type):\rvalue = value.encode(encoding='utf-8')\rmymac = hmac.new(value)\r但是，在整个代码库中，像上面这样的情况非常多。作为开发人员，如果需要在调用每个函数时都要想想： 这里到底是应该编码成二进制，或者是解码成文本呢？ 将会是非常大的负担。\n于是 Instagram 封装了一些名为 ensure_str()、ensure_binary()、ensure_text() 的帮助函数，开发人员只需对那些不确定类型的字符串，使用这些帮助函数先做一次转换就好。\nmymac = hmac.new(ensure_binary('abc'))\r不同 Python 版本的 pickle 差异 Instagram 的代码中大量使用了 pickle。比如用它序列化某个对象，然后将其存储在 memcache 中。如下面的代码所示：\nmemcache_data = pickle.dumps(data, pickle.HIGHEST_PROTOCOL)\rdata = pickle.loads(memcache_data)\r问题在于，Python 2 与 Python 3 的 pickle 模块是有差别的。\n如果上文的第一行代码，刚好是由 Python 3 运行的服务进行序列化后存入 memcache。而反序列化的过程却是由 Python 2 进行，那代码运行时就会出现下面的错误：\nValueError: unsupported pickle protocol: 4\r这是由于在 Python 3 中，pickle.HIGHEST_PROTOCOL 的值为 4，而 Python 2 中的的 pickle 最高支持的版本号却是 2。那么如何解决这个问题呢？\nInstagram 最终选择让 Python 2 和 Python 3 使用完全不同的 namespace 来访问 memcache。通过将二者的数据读写完全隔开来解决这个问题。\n迭代器 在 Python 3 中，很多内置函数被修改成了只返成迭代器 Iterator：\nmap()\rfilter()\rdict.items()\r迭代器有诸多好处，最大的好处就是，使用迭代器不需要一次性分配大量内存，所以它的内存效率比较高。\n但是迭代器有一个天然的特点，当你对某个迭代器做了一次迭代，访问完它的内容后，就没法再次访问那些内容了。迭代器中的所有内容都只能被访问一次。\n在 Instagram 的 Python 3 迁移过程中，就因为迭代器的这个特性被坑了一次，看看下面这段代码：\nCYTHON_SOURCES = [a.pyx, b.pyx, c.pyx]\rbuilds = map(BuildProcess, CYTHON_SOURCES)\rwhile any(not build.done() for build in builds):\rpending = [build for build in builds if not build.started()]\r\u003cdo some work\u003e\r这段代码的用处是挨个编译 Cython 源文件。当他们把运行环境切换到 Python 3 后，一个奇怪的问题出现了：**CYTHON_SOURCES 中的第一个文件永远都被跳过了编译。**为什么呢？\n这都是迭代器的锅。在 Python 3 中，map() 函数不再返回整个 list，而是返回一个迭代器。\n于是，当第二行代码生成 builds 这个迭代器后，第三行代码的 while 循环迭代了 builds，刚好取出了第一个元素。于是之后的 pending 对象便里面永远少了那第一个元素。\n这个问题解决起来也挺简单的，你只要手动的吧 builds 转换成 list 就可以了：\nbuilds = list(map(BuildProcess, CYTHON_SOURCES))\r但是这类 bug 非常难定位到。如果用户的 feeds 里面永远少了那最新的第一条，用户很少会注意到。\n字典的顺序 看看下面这段代码：\n\u003e\u003e\u003e testdict = {'a': 1, 'b': 2, 'c': 3}\r\u003e\u003e\u003e json.dumps(testdict)\r它会输出什么结果呢？\n# Python2\r'{\"a\": 1, \"c\": 3, \"b\": 2}'\r# Python 3.5.1\r'{\"c\": 3, \"b\": 2, \"a\": 1}' # or\r'{\"c\": 3, \"a\": 1, \"b\": 2}'\r# Python 3.6\r'{\"a\": 1, \"b\": 2, \"c\": 3}'\r在不同的 Python 版本下，这个 json dumps 的结果是完全不一样的。甚至在 3.5.1 中，它会完全随机的返回两个不同的结果。Instagram 有一段判断配置文件是否发生变动的模块，就是因为这个原因出了问题。\n这个问题的解决办法是，在调用 json.dumps 传入 sort_keys=True 参数：\n\u003e\u003e\u003e json.dumps(testdict, sort_keys=True)\r'{\"a\": 1, \"b\": 2, \"c\": 3}'\r迁移到 Python 3.6 后的性能提升 当 Instagram 解决了这些奇奇怪怪的版本差异问题后，还有一个巨大的谜题困扰着他们：性能问题。\n在 Instagram，他们使用两个主要指标来衡量他们的服务性能：\n 每次请求产生的 CPU 指令数（越低越好） 每秒能够处理的请求数（越高越好）  所以，当所有的迁移工作完成后，他们非常惊喜的发现：第一个性能指标，每次请求产生的 CPU 指令数居然足足下降了 12% ！！！\n但是，按理说第二个指标 - 每秒请求数也应该获得接近 12% 的提升。不过最后的变化却是 0%。究竟是出了什么问题呢？\n他们最终定位到，是由于不同 Python 版本下的内存优化配置不同，导致 CPU 指令数下降带来的性能提升被抵消了。那为什么不同 Python 版本下的内存优化配置会不一样呢？\n这是他们用来检查 uwsgi 配置的代码：\nif uwsgi.opt.get('optimize_mem', None) == 'True':\roptimize_mem()\r注意到那段 ... ... == 'True' 了吗？在 Python 3 中，这个条件判断总是不会被满足。问题就在于 unicode。在将代码中的 'True' 换成 b'True'（也就是将文本类型换成二进制，这种判断在 Python 2 中完全不区分的）后，问题解决了。\n所以，最终因为加上了一个小小的字母 ‘b’，程序的整体性能提升了 12%。\n结论 在今年二月份，Instagram 的后端代码的运行环境完全切换到了 Python 3 下：\n当所有的代码都都迁移到 Python 3 运行环境后：\n 节约了 12% 的整体 CPU 使用率（Django/uwsgi） 节约了 30% 的内存使用（celery）  同时，在整个迁移期间，Instagram 的月活用户经历了从 4 亿到 6亿 的巨大增长。产品也发布了评论过滤、直播等非常多新功能。\n那么，那几个最开始驱动他们迁移到 Python 3 的目的呢？\n 类型注解：Instagram 的整个 codebase 里已经有 2% 的代码添加上了类型注解，同时他们还开发了一些工具来辅助开发者添加类型提示 asyncio：他们在单个接口中利用 asynio 平行的去做多件事情，最终降低了 20-30% 的请求延迟。 社区：他们与 Intel 的工程师联合，帮助他们更好的对 CPU 利用率进行调优。同时还开发了很多新的工具，帮助他们进行性能调优  Instagram 带给我们的启示 Instagram 的演讲视频时间不长，但是内容很丰富，在编写此文前，我完全没有想到最终的文章会这么长。\n那么，Instagram 的视频可以给我们哪些启示呢？\n Python + Django 的组合完全可以负载用户数以 10 亿记的服务，如果你正准备开始一个项目，放心使用 Python 吧！ 完善的单元测试对于复杂项目是非常有必要的。如果没有那『成千上万的单元测试』。很难想象 Instagram 的迁移项目可以成功进行下去。 开发者和同事也是你的产品用户，利用好他们。用他们为你的新特性发布前多一道测试。 完全基于主分支的开发流程，可以给你更快的迭代速度。前提是拥有完善的单元测试和持续部署流程。 Python 3 是大势所趋，如果你正准备开始一个新项目，无需迟疑，拥抱 Python 3 吧！  ","description":"python，Instagram在PyCon2017的演讲摘要","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/posts/python/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 18. 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n返回删除后的链表的头节点。\n**注意：**此题对比原题有改动\n示例 1:\n输入: head = [4,5,1,9], val = 5\r输出: [4,1,9]\r解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9.\r示例 2:\n输入: head = [4,5,1,9], val = 1\r输出: [4,5,9]\r解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9.\r说明：\n 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点  思路： 删除值为 val 的节点可分为两步：定位节点、修改引用。\n定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。 修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。\n算法流程：\n1.特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。\r2.初始化： pre = head , cur = head.next 。\r3.定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。\r4.保存当前节点索引，即 pre = cur 。\r5.遍历下一节点，即 cur = cur.next 。\r6.删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next 。（若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。\r7.返回值： 返回链表头部节点 head 即可。\r# -*- coding: utf-8 -*-\r# @Time : 2020/7/18 23:44\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : offer18.py\r# @Software : PyCharm class ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef deleteNode(self, head, val):\r\"\"\"\r:type head: ListNode\r:type val: int\r:rtype: ListNode\r\"\"\"\rif head.val == val:\rreturn head.next\rpre, cur = head, head.next\rwhile cur and cur.val != val:\rpre, cur = cur, cur.next\rif cur:\rpre.next = cur.next\rreturn head\rdef create_link(tmp):\rcur = head = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([4, 5, 1, 9])\rtraversal_link(head)\r","description":"leetcode，Offer18删除链表的节点","tags":["leetcode"],"title":"Offer18删除链表的节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1：\n输入：[1,2,3,4,5]\r输出：此列表中的结点 3 (序列化形式：[3,4,5])\r返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\r注意，我们返回了一个 ListNode 类型的对象 ans，这样：\rans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\r示例 2：\n输入：[1,2,3,4,5,6]\r输出：此列表中的结点 4 (序列化形式：[4,5,6])\r由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\r提示：\n 给定链表的结点数介于 1 和 100 之间。  思路\n方法一：数组\n链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。\r方法二：单指针法\n我们可以对方法一进行空间优化，省去数组 A。\r我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。\r方法三：快慢指针法\n\r我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。\r代码\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/16 23:03\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 876.py\r# @Software : PyCharm # Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef middleNode(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rslow = fast = head\rwhile fast and fast.next:\rslow = slow.next\rfast = fast.next.next\rreturn slow\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 4, 5])\rsolution = Solution()\rnode = solution.middleNode(head)\rprint(node.val)\r","description":"leetcode，876 链表的中间结点","tags":["leetcode"],"title":"876 链表的中间结点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.01. 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n示例1:\n 输入：[1, 2, 3, 3, 2, 1]\r输出：[1, 2, 3]\r示例2:\n 输入：[1, 1, 1, 1, 2]\r输出：[1, 2]\r提示：\n 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。  进阶：\n如果不得使用临时缓冲区，该怎么解决？\n思路\n哈希 O(n) 哈希表存储出现过的元素，如果当前节点出现过，就删掉\n我们从链表的头节点head 开始进行遍历，遍历的指针记为cur。由于头节点一定不会被删除，因此我们可以枚举待移除节点的前驱节点pre，减少编写代码的复杂度。\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/16 22:27\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 0201.py\r# @Software : PyCharm # Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef removeDuplicateNodes(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rif not head:\rreturn head\rtmp = {head.val}\rpre = head\rcur = pre.next\rwhile cur:\rif cur.val in tmp:\rpre.next = cur.next\rcur = cur.next\relse:\rtmp.add(cur.val)\rpre = pre.next\rcur = cur.next\rreturn head\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 3, 2, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.removeDuplicateNodes(head)\rtraversal_link(result)\r双指针 固定p指针，右侧q指针扫描，然后移动p，指针q再次扫描 时间复杂度 O(n^2)\n# Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef removeDuplicateNodes(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rp = head\rwhile p:\rq = p\rwhile q.next:\rif q.next.val == p.val:\rq.next = q.next.next\relse:\rq = q.next\rp = p.next\rreturn head\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 3, 2, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.removeDuplicateNodes(head)\rtraversal_link(result)\r","description":"leetcode，0201 移除重复节点","tags":["leetcode"],"title":"0201 移除重复节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 24. 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例:\n输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL\r输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL\r限制：\n0 \u003c= 节点个数 \u003c= 5000\r思路\n# Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef reverseList(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rcur = head\rpre = None\rwhile cur:\rafter = cur.next\rcur.next = pre\rpre = cur\rcur = after\rreturn pre\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 4, 5])\r# traversal_link(head)\rsolution = Solution()\rcur = solution.reverseList(head)\rtraversal_link(cur)\r","description":"leetcode，Offer24 反转链表","tags":["leetcode"],"title":"Offer24 反转链表","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"1290. 二进制链表转整数 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。\n请你返回该链表所表示数字的 十进制值 。\n示例 1：\n输入：head = [1,0,1]\r输出：5\r解释：二进制数 (101) 转化为十进制数 (5)\r示例 2：\n输入：head = [0]\r输出：0\r示例 3：\n输入：head = [1]\r输出：1\r示例 4：\n输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\r输出：18880\r示例 5：\n输入：head = [0,0]\r输出：0\r提示：\n链表不为空。\r链表的结点总数不超过 30。\r每个结点的值不是 0 就是 1。\r思路\n如果一个十进制的数字，999要和1拼接，需要999*10+1 = 999∗10+1=9991\r如果一个二进制的数字，110要和1拼接，需要110*2+1 = 110∗2+1=1101 （注意按照二进制的方法计算）\r代码\nclass Solution(object):\rdef getDecimalValue(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: int\r\"\"\"\rresult = 0\rwhile head:\rresult = head.val + (result \u003c\u003c 1)\rhead = head.next\rreturn result\r","description":"leetcode，1290 二进制链表转整数","tags":["leetcode"],"title":"1290 二进制链表转整数","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode","链表"],"content":"面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动\n示例：\n输入： 1-\u003e2-\u003e3-\u003e4-\u003e5 和 k = 2\r输出： 4\r说明：\r给定的 k 保证是有效的。\n思路\n经典的快慢指针问题\n\r反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。\r设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点\rclass Solution(object):\rdef kthToLast(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: int\r\"\"\"\rif head is None:\rreturn None\rleft = head\rright = head\rcount = 0\rwhile count \u003c k:\rright = right.next\rcount += 1\rwhile right:\rleft = left.next\rright = right.next\rreturn left.val\r","description":"leetcode，02.02. 返回倒数第 k 个节点","tags":["leetcode"],"title":"02.02. 返回倒数第 k 个节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。\n示例：\n输入：单向链表a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef中的节点c\r结果：不返回任何数据，但该链表变为a-\u003eb-\u003ed-\u003ee-\u003ef\r代码\nclass Solution(object):\rdef deleteNode(self, node):\r\"\"\"\r:type node: ListNode\r:rtype: void Do not return anything, modify node in-place instead.\r\"\"\"\rnode.val = node.next.val\rnode.next = node.next.next\r解题思路 删除当前节点 必须知道prev节点， 这里只能访问当前节点，就只能先将next节点的值赋值给当前结点, 再把next节点干掉\n","description":"leetcode，02.03. 删除中间节点","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/) 编写一个函数，检查输入的链表是否是回文的。\n示例 1：\n输入： 1-\u003e2\r输出： false 示例 2：\n输入： 1-\u003e2-\u003e2-\u003e1\r输出： true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n思路\n1. 快慢指针遍历到链表中间，快指针走两步、慢指针走一步，最后慢指针的位置就是链表中间（画个示例图就知道了，虽然我这看的是该题的评论，不太明白，然后画了个图就了解了）\r2. 从中间开始反转链表后半段\r3. 从原链表头和反转后的链表头开始比较 value\r代码\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/15 21:27\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 0206.py\r# @Software : PyCharm class ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef get_middle(self, head):\r\"\"\"用快慢指针获取中间节点\"\"\"\rleft = right = head\rwhile right and right.next:\rleft = left.next\rright = right.next.next\rreturn left\rdef reverse_link(self, head):\r\"\"\"反转链表\"\"\"\rcur = head\rpre = None\rwhile cur:\rafter = cur.next\rcur.next = pre\rpre = cur\rcur = after\rreturn pre\rdef isPalindrome(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: bool\r\"\"\"\rif head is None:\rreturn True\r# 获取中间节点\rmiddle_node = self.get_middle(head)\r# 反转链表\rfirst = head\rsecond = self.reverse_link(middle_node)\rwhile second:\rif first.val != second.val:\rreturn False\rfirst = first.next\rsecond = second.next\rreturn True\rdef create_link(tmp):\rhead = None\rcur = head\rfor val in tmp:\rnode = ListNode(val)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rwhile head:\rprint(head.val)\rhead = head.next\rif __name__ == '__main__':\rhead = create_link([1, 1, 1, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.isPalindrome(head)\rprint(result)\r","description":"leetcode，0206 回文链表","tags":["leetcode"],"title":"0206 回文链表","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。\n返回的长度需要从小到大排列。\n示例 输入：\rshorter = 1\rlonger = 2\rk = 3\r输出： {3,4,5,6}\r提示： \r0 \u003c shorter \u003c= longer\r0 \u003c= k \u003c= 100000\r代码 # -*- coding: utf-8 -*-\r# @Time : 2020/7/8 23:06\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 16.11跳水板.py\r# @Software : PyCharm class Solution:\rdef divingBoard(self, shorter: int, longer: int, k: int):\rif k == 0:\rreturn []\relif shorter == longer:\rreturn [k * longer]\rmin_length = shorter * k\rmax_length = longer * k\rdiff = longer - shorter\rresult = []\rfor i in range(min_length, max_length, diff):\rresult.append(i)\rresult.append(max_length)\rreturn result\rif __name__ == '__main__':\rsolution = Solution()\rresult = solution.divingBoard(1, 3, 3)\rprint(result)\r","description":"leetcode，跳水板","tags":["leetcode"],"title":"16.11 跳水板","uri":"/posts/leetcode/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"},{"categories":["leetcode"],"content":"给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。\n二叉搜索树保证具有唯一的值。\n示例 1：\n输入：root = [10,5,15,3,7,null,18], L = 7, R = 15\r输出：32\r示例 2：\n输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\r输出：23\r提示：\n树中的结点数量最多为 10000 个。\r最终的答案保证小于 2^31。\r","description":"938 二叉搜索树的范围和， leetcode","tags":["leetcode"],"title":"938 二叉搜索树的范围和","uri":"/posts/leetcode/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/"},{"categories":["leetcode"],"content":"给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\rk 是一个正整数，它的值小于或等于链表的长度。\r如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\r示例：\r给你这个链表：1-\u003e2-\u003e3-\u003e4-\u003e5\r当 k = 2 时，应当返回: 2-\u003e1-\u003e4-\u003e3-\u003e5\r当 k = 3 时，应当返回: 3-\u003e2-\u003e1-\u003e4-\u003e5\r说明：\r你的算法只能使用常数的额外空间。\r你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\r迭代 class Solution:\rdef reverseKGroup(self, head, k):\rcur = head\rif cur is None or cur.next is None:\rreturn cur\rtmp = list()\rwhile cur:\rtmp.append(cur)\rcur = cur.next\rpre = ListNode(None)\rcur = pre\rlength = len(tmp)\rfinal_node = None\rif length % k \u003c k and length % k != 0:\rfinal_node = tmp[-(length % k)]\rfor node_index in range(k - 1, length, k):\rfor key in range(k):\rcur.next = tmp[node_index - key]\rcur = cur.next\rcur.next = final_node\rreturn pre.next\r","description":"leetcode，25 K 个一组翻转链表","tags":["leetcode"],"title":"25 K 个一组翻转链表","uri":"/posts/leetcode/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。\r( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\r搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\r你可以假设数组中不存在重复的元素。\r你的算法时间复杂度必须是 O(log n) 级别。\r示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0\r输出: 4\r示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3\r输出: -1\r解题思路： 题目要求 O(logN)O(logN) 的时间复杂度，基本可以断定本题是需要使用二分查找，怎么分是关键。\r由于题目说数字了无重复，举个例子：\r1 2 3 4 5 6 7 可以大致分为两类，\r第一类 2 3 4 5 6 7 1 这种，也就是 nums[start] \u003c= nums[mid]。此例子中就是 2 \u003c= 5。\r这种情况下，前半部分有序。因此如果 nums[start] \u003c=target\u003cnums[mid]，则在前半部分找，否则去后半部分找。\r第二类 6 7 1 2 3 4 5 这种，也就是 nums[start] \u003e nums[mid]。此例子中就是 6 \u003e 2。\r这种情况下，后半部分有序。因此如果 nums[mid] \u003ctarget\u003c=nums[end]，则在后半部分找，否则去前半部分找。\r此题有个存在重复数字的变形题，可参考 此题解 。\r代码： class Solution:\rdef search(self, nums, target: int) -\u003e int:\rif not nums:\rreturn -1\rif len(nums) == 1:\rif target in nums:\rreturn 0\relse:\rreturn -1\rlength = len(nums)\rstart = 0\rend = length - 1\rwhile start \u003c= end:\rmid = start + (end - start) // 2\rif nums[mid] == target:\rreturn mid\rif nums[start] \u003c= nums[mid]:\r# 前半部分有序\rif target \u003e= nums[start] and target \u003c nums[mid]:\rend = mid - 1\relse:\rstart = mid + 1\relse:\rif target \u003c= nums[end] and target \u003e nums[mid]:\rstart = mid + 1\relse:\rend = mid - 1\rreturn -1\r","description":"leetcode，33 搜索旋转排序数组","tags":["leetcode"],"title":"33 搜索旋转排序数组","uri":"/posts/leetcode/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["leetcode"],"content":"给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的数字可以无限制重复被选取。\n说明：  所有数字（包括 target）都是正整数。 解集不能包含重复的组合。  示例 1: 输入: candidates = [2,3,6,7], target = 7,\r所求解集为:\r[\r[7],\r[2,2,3]\r]\r示例 2: 输入: candidates = [2,3,5], target = 8,\r所求解集为:\r[\r[2,2,2,2],\r[2,3,3],\r[3,5]\r]\r回溯法 class Solution:\rdef combinationSum(self, candidates, target: int):\rif not candidates:\rreturn []\rresult = []\rdef isvalid(path, value, target):\rtotal = sum(path) + value\rif total \u003e target:\rreturn False\rreturn True\rdef backtrack(path, candidates):\rif sum(path) == target:\rpath = sorted(path)\rif path not in result:\rresult.append(path)\rreturn None\rfor value in candidates:\rif not isvalid(path, value, target):\rcontinue\rpath.append(value)\rbacktrack(path, candidates)\rpath.pop()\rbacktrack([], candidates)\rreturn result\r","description":"leetcode，39 组合综合","tags":["leetcode"],"title":"39 组合综合","uri":"/posts/leetcode/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/"},{"categories":["leetcode"],"content":"给定一个数组** candidates **和一个目标数** target **，找出** candidates **中所有可以使数字和为** target **的组合。\ncandidates 中的每个数字在每个组合中只能使用一次。\n说明：  所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。  示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,\r所求解集为:\r[\r[1, 7],\r[1, 2, 5],\r[2, 6],\r[1, 1, 6]\r]\r示例 2: 输入: candidates = [2,5,2,1,2], target = 5,\r所求解集为:\r[\r[1,2,2],\r[5]\r]\r回溯法 class Solution:\rdef combinationSum2(self, candidates, target: int):\rif not candidates:\rreturn []\rdef isvalid(path, value):\rif (sum(path) + value) \u003e target:\rreturn False\rreturn True\rdef backtrack(path, rest):\rif sum(path) == target:\rpath = sorted(path)\rif path not in result:\rresult.append(path)\rreturn\rfor index, value in enumerate(rest):\rif not isvalid(path, value):\rcontinue\rpath.append(value)\rbacktrack(path, rest[index + 1:])\rpath.pop()\rresult = []\rbacktrack([], candidates)\rreturn result\r","description":"leetcode，40 组合总和 II","tags":["leetcode"],"title":"40 组合总和 II","uri":"/posts/leetcode/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/"},{"categories":["leetcode"],"content":"给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\r例如，给出 n = 3，生成结果为：\r[\r\"((()))\",\r\"(()())\",\r\"(())()\",\r\"()(())\",\r\"()()()\"\r]\r## 回溯算法\rfrom collections import Counter\rclass Solution:\rdef generateParenthesis(self, n: int):\rself.n = n\r# 结果\rresult = []\r# 每次运行的\rtrack = []\rtmp = []\rdef backtrack(path, options):\rif len(path) == n * 2:\rtmp.append(path)\rresult.append(''.join(path))\rreturn\rfor i in range(len(options)):\rif not self.isvalid(path, options[i]):\rcontinue\rpath.append(options[i])\rbacktrack(path, options)\rpath.pop()\rbacktrack(track, ['(', ')'])\rreturn result\rdef isvalid(self, path, next):\rif len(path) == 0 and next == ')':\rreturn False\rcount_dict = Counter(path)\rleft_value = count_dict['(']\rright_value = count_dict[')']\rif next == ')' and right_value + 1 \u003e left_value:\rreturn False\rfor key, value in count_dict.items():\rif key == next and value == self.n:\rreturn False\rreturn True\rif __name__ == '__main__':\rsolution = Solution()\rresult = solution.generateParenthesis(3)\rprint(result)\r","description":"leetcode，22 括号生成","tags":["leetcode"],"title":"22 括号生成","uri":"/posts/leetcode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["leetcode"],"content":"合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n示例: 输入:\r[\r1-\u003e4-\u003e5,\r1-\u003e3-\u003e4,\r2-\u003e6\r]\r输出: 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6\r暴力解法 遍历所有链表，将所有节点的值放到一个数组中。\r将这个数组排序，然后遍历所有元素得到正确顺序的值。\r用遍历得到的值，创建一个新的有序链表。\r# -*- coding: utf-8 -*-\r# @Time : 2020/3/29 1:14\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 23.py\r# @Software : PyCharm # Definition for singly-linked list.\rclass ListNode:\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution:\rdef mergeKLists(self, lists):\r# head = ListNode(-1)\rresult = []\rfor cur in lists:\rwhile cur:\rresult.append(cur.val)\rcur = cur.next\rhead = ListNode(-1)\rcur = head\rresult.sort()\rfor i in result:\rcur.next = ListNode(i)\rcur = cur.next\rreturn head.next\rif __name__ == '__main__':\rsolution = Solution()\rhead_1 = ListNode(1)\rnode_2 = ListNode(4)\rnode_4 = ListNode(5)\rhead_1.next = node_2\rnode_2.next = node_4\rhead_2 = ListNode(1)\rnode_3 = ListNode(3)\rnode_4_copy = ListNode(4)\rhead_2.next = node_3\rnode_3.next = node_4_copy\rhead_3 = ListNode(2)\rnode_6 = ListNode(6)\rhead_3.next = node_6\rtmp = [head_1, head_2, head_3]\rresult = solution.mergeKLists(tmp)\rwhile result:\rprint(result.val)\rresult = result.next\r","description":"leetcode，23 合并K个排序链表","tags":["leetcode"],"title":"23 合并K个排序链表","uri":"/posts/leetcode/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r示例: 给定 1-\u003e2-\u003e3-\u003e4, 你应该返回 2-\u003e1-\u003e4-\u003e3.\r# -*- coding: utf-8 -*-\r# @Time : 2020/3/29 14:34\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 24.py\r# @Software : PyCharm class ListNode:\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution:\rdef swapPairs(self, head):\rcur = head\rif cur is None or cur.next is None:\rreturn cur\rtmp = list()\rwhile cur:\rtmp.append(cur)\rcur = cur.next\rpre = ListNode(None)\rcur = pre\rlength = len(tmp)\rfinal_node = None\rif length % 2 == 1:\rfinal_node = tmp[-1]\rfor node_index in range(1, length, 2):\rcur.next = tmp[node_index]\rcur = cur.next\rcur.next = tmp[node_index - 1]\rcur = cur.next\rcur.next = final_node\rreturn pre.next\rif __name__ == '__main__':\rsolution = Solution()\rhead_1 = ListNode(1)\rnode_2 = ListNode(2)\rnode_3 = ListNode(3)\rnode_4 = ListNode(4)\rhead_1.next = node_2\rnode_2.next = node_3\rnode_3.next = node_4\rresult = solution.swapPairs(head_1)\rwhile result:\rprint(result.val)\rresult = result.next\r","description":"leetcode，24 两两交换链表中的节点","tags":["leetcode"],"title":"24 两两交换链表中的节点","uri":"/posts/leetcode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode"],"content":"给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。\n示例 1: 输入: [1,2,0]\r输出: 3\r示例 2: 输入: [3,4,-1,1]\r输出: 2\r示例 3: 输入: [7,8,9,11,12]\r输出: 1\r提示： 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。\r","description":"leetcode，41 缺失的第一个正数","tags":["leetcode"],"title":"41 缺失的第一个正数","uri":"/posts/leetcode/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"},{"categories":["leetcode"],"content":"给定一个 n × n 的二维矩阵表示一个图像。\n将图像顺时针旋转 90 度。\n说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n示例 1: 给定 matrix = [\r[1,2,3],\r[4,5,6],\r[7,8,9]\r],\r原地旋转输入矩阵，使其变为:\r[\r[7,4,1],\r[8,5,2],\r[9,6,3]\r]\r示例 2: 给定 matrix =\r[\r[ 5, 1, 9,11],\r[ 2, 4, 8,10],\r[13, 3, 6, 7],\r[15,14,12,16]\r], 原地旋转输入矩阵，使其变为:\r[\r[15,13, 2, 5],\r[14, 3, 4, 1],\r[12, 6, 8, 9],\r[16, 7,10,11]\r]\r","description":"leetcode，48 旋转图像","tags":["leetcode"],"title":"48 旋转图像","uri":"/posts/leetcode/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"},{"categories":["leetcode"],"content":"给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n示例 1: 输入:\r[\r[ 1, 2, 3 ],\r[ 4, 5, 6 ],\r[ 7, 8, 9 ]\r]\r输出: [1,2,3,6,9,8,7,4,5]\r示例 2: 输入:\r[\r[1, 2, 3, 4],\r[5, 6, 7, 8],\r[9,10,11,12]\r]\r输出: [1,2,3,4,8,12,11,10,9,5,6,7]\r解决方案 这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小\r首先设定上下左右边界\r其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界\r判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案\r若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理\r不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案\rclass Solution:\rdef spiralOrder(self, matrix):\rif not matrix:\rreturn matrix\rresult = []\r# 高\rrow_length = len(matrix)\r# 几列\rcol_length = len(matrix[0])\r# 上边界\rup = 0\r# 下边界\rdown = row_length\r# 左边界\rleft = 0\r# 右边界\rright = col_length\r# 上下游标\rrow_cur = 0\r# 左右游标\rcol_cur = 0\rwhile True:\r# print(\"left = {}, right = {}, up = {}, down = {}\".format(left, right, up, down))\rfor col_cur in range(left, right):\r# print(\"1 {}\".format(matrix[row_cur][col_cur]))\rresult.append(matrix[row_cur][col_cur])\r# 更新上边界\rup += 1\rif up \u003e= down:\rbreak\rfor row_cur in range(up, down):\r# print(\"2 {}\".format(matrix[row_cur][col_cur]))\rresult.append(matrix[row_cur][col_cur])\r# 更新右边界\rright -= 1\rif right \u003c= left:\rbreak\rfor col_cur in range(right - 1, left - 1, -1):\r# print(\"3 {}\".format(matrix[row_cur][col_cur]))\rresult.append(matrix[row_cur][col_cur])\r# 更新下边界\rdown -= 1\rif down \u003c= up:\rbreak\rfor row_cur in range(down - 1, up - 1, -1):\r# print(\"4 {}\".format(matrix[row_cur][col_cur]))\rresult.append(matrix[row_cur][col_cur])\r# 更新左边界\rleft += 1\rif left \u003e= right:\rbreak\rreturn result\rif __name__ == '__main__':\rsolution = Solution()\rmatrix = [\r[1, 2, 3],\r[4, 5, 6],\r[7, 8, 9]\r]\rmatrix = [\r[1, 2, 3, 4],\r[5, 6, 7, 8],\r[9, 10, 11, 12]\r]\rmatrix = [\r[1, 2, 3, 4],\r[5, 6, 7, 8],\r[9, 10, 11, 12]\r]\rresult = solution.spiralOrder(matrix)\rprint(result)\r","description":"leetcode，54 螺旋矩阵","tags":["leetcode"],"title":"54 螺旋矩阵","uri":"/posts/leetcode/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"categories":["python","werkzeug"],"content":"Werkzeug是什么？ Werkzeug是一个基于WSGI的Web应用框架（说框架可能不合理，官方文档给出的是应用程序库）。想要了解更多请看官方文档\n为什么要了解Werkzeug？ 因为目前所用的web框架为Flask，而Flask是以Werkzeug为基础的，所以绕不开Werkzeug了。\n基础知识  WSGI Python 生成器 非常简单的网络知识  ","description":"","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(1)","uri":"/posts/werkzeug/werkzeug_sc_1/"},{"categories":["python","werkzeug"],"content":"从哪开始呢？   熟悉目录层级\n  参照Werkzeug官方文档给出的示例，重点关注Request,Response,run_simple\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  from werkzeug.wrappers import Request, Response def application(environ, start_response): request = Request(environ) text = 'Hello %s!' % request.args.get('name', 'World') response = Response(text, mimetype='text/plain') return response(environ, start_response) \"\"\" 省略超多内容 \"\"\" class Shortly(object): def __init__(self, config): self.redis = redis.Redis(config['redis_host'], config['redis_port']) def dispatch_request(self, request): return Response('Hello World!') def wsgi_app(self, environ, start_response): request = Request(environ) response = self.dispatch_request(request) return response(environ, start_response) def __call__(self, environ, start_response): return self.wsgi_app(environ, start_response) def create_app(redis_host='localhost', redis_port=6379, with_static=True): app = Shortly({ 'redis_host': redis_host, 'redis_port': redis_port }) if with_static: app.wsgi_app = SharedDataMiddleware(app.wsgi_app, { '/static': os.path.join(os.path.dirname(__file__), 'static') }) return app if __name__ == '__main__': from werkzeug.serving import run_simple app = create_app() run_simple('127.0.0.1', 5000, app, use_debugger=True, use_reloader)     Request、Response、run_simple（最不重要的） 之后的文章就重点关注以上三个，而且肯定会延伸到Werkzeug的其他地方（源码），不必担心，肯定会有所涉猎。\n讲真，感觉run_simple可以不重点关注，希望不要打脸\n","description":"","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(2)","uri":"/posts/werkzeug/werkzeug_sc_2/"},{"categories":["python","werkzeug"],"content":"Werkzeug Request 源码解析 代码示例：\nfrom werkzeug.wrappers import Request, Response\rdef application(environ, start_response):\rrequest = Request(environ)\rtext = 'Hello %s!' % request.args.get('name', 'World')\rresponse = Response(text, mimetype='text/plain')\rreturn response(environ, start_response)\r请注意，之后Request和Response的相关源码都会围绕Werkzeug给出的以上代码讲解。\nRequest 类 文件定位 src/werkzeug/wrappers/request.py\n作用 根据Request类的名称其实就可以知道，Request类是处理请求的，实际上，通过阅读相关代码，Request类的作用确实如此\n分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Request( BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin, CORSRequestMixin, CommonRequestDescriptorsMixin, ): \"\"\"Full featured request object implementing the following mixins: - :class:`AcceptMixin` for accept header parsing - :class:`ETagRequestMixin` for etag and cache control handling - :class:`UserAgentMixin` for user agent introspection - :class:`AuthorizationMixin` for http auth handling - :class:`~werkzeug.wrappers.cors.CORSRequestMixin` for Cross Origin Resource Sharing headers - :class:`CommonRequestDescriptorsMixin` for common headers \"\"\"   ​\t根据注释可知，除了BaseRequest类之外，其他的Mixin类都是作为添加高级方法的类。而且Request类也没有初始化方法，所以可以将注意力从Request转移到BaseRequest类上面。\nBaseRequest 类 截取以上代码示例的代码\nrequest = Request(environ)\r调用父类BaseRequest的__init__方法\n1 2 3 4 5  def __init__(self, environ, populate_request=True, shallow=False): self.environ = environ if populate_request and not shallow: self.environ[\"werkzeug.request\"] = self self.shallow = shallow   ","description":"","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(3)","uri":"/posts/werkzeug/werkzeug_sc_3/"},{"categories":["leetcode"],"content":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4)\r输出：7 -\u003e 0 -\u003e 8\r原因：342 + 465 = 807\r代码\n# Definition for singly-linked list.\r# class ListNode(object):\r# def __init__(self, x):\r# self.val = x\r# self.next = None\rclass Solution(object):\rdef addTwoNumbers(self, l1, l2):\r\"\"\"\r:type l1: ListNode\r:type l2: ListNode\r:rtype: ListNode\r\"\"\"\rlist_1 = \"\"\rlist_2 = \"\"\rif not l1 and not l2:\rreturn 0\rwhile l1:\rlist_1 += str(l1.val)\rl1 = l1.next\rnum_1 = int(list_1[::-1]) if list_1 else 0\rwhile l2:\rlist_2 += str(l2.val)\rl2 = l2.next\rnum_2 = int(list_2[::-1]) if list_2 else 0\rsum = list(str(num_1 + num_2)[::-1])\rhead = ListNode(sum[0])\rcur = head\rfor i in range(1, len(sum)):\rcur.next = ListNode(sum[i])\rcur = cur.next\rreturn head\r","description":"leetcode，两数相加","tags":["leetcode"],"title":"02 两数相加","uri":"/posts/leetcode/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\"\r输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\r示例 2: 输入: \"bbbbb\"\r输出: 1\r解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\r示例 3: 输入: \"pwwkew\"\r输出: 3\r解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\r解决方法（可以进行改进） 采用 滑动窗口 算法，详见html class Solution(object):\rdef lengthOfLongestSubstring(self, s):\r\"\"\"\r:type s: str\r:rtype: int\r\"\"\"\rif not s:\rreturn 0\ruq = set(s)\ruq_length = len(uq)\rwindows = s[0]\rleft = 0\rright = 1\rmax_len = 1\rfor i in range(1, len(s)):\rflag_index = windows.find(s[i])\rif flag_index == -1:\rwindows += s[i]\rright += 1\relse:\rleft = flag_index + 1\rright += 1\rwindows = windows[left:] + s[i]\rif max_len \u003c len(windows):\rmax_len = len(windows)\rreturn max_len\r","description":"leetcode，无重复字符的最长子串","tags":["leetcode"],"title":"03 无重复字符的最长子串","uri":"/posts/leetcode/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["leetcode"],"content":"\r给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\r请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\r你可以假设 nums1 和 nums2 不会同时为空。\r示例 1: nums1 = [1, 3]\rnums2 = [2]\r则中位数是 2.0\r示例 2: nums1 = [1, 2]\rnums2 = [3, 4]\r则中位数是 (2 + 3)/2 = 2.5\rclass Solution(object):\rdef findMedianSortedArrays(self, nums1, nums2):\r\"\"\"\r:type nums1: List[int]\r:type nums2: List[int]\r:rtype: float\r\"\"\"\rnums1.extend(nums2)\rnums1.sort()\rlength = len(nums1)\rif length % 2 == 1:\rreturn float(nums1[length // 2])\relse:\rreturn float(((nums1[length // 2] + nums1[length // 2 - 1])) / 2)\r","description":"leetcode，04 寻找两个有序数组的中位数","tags":["leetcode"],"title":"04 寻找两个有序数组的中位数","uri":"/posts/leetcode/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["leetcode"],"content":"https://blog.csdn.net/liuwei0604/article/details/50414542 马拉车算法可以在线性时间复杂度内求出一个字符串的最长回文字串。其核心思想跟 KMP 相似，即反复利用已掌握的情况。\n1.整体思路 这个算法的主要思路是维护一个跟原串 str 一样长的数组 lens。lens[i] 表示以 str[i] 为中点的回串其中一边的长度。这里有的人把中点算进去，有的人记录两边的长度，其实都一样，我这里是只记录一边的长度，不包括中点。比如 \"CDCDE\"\rstr: [C, D, C, D, E]\rlens: [0, 1, 1, 0, 0]\r那么 lens 里最大的自然就对应最长回串的中点了。所以这个算法的核心就是如何快速计算 lens。\n2.预处理 回文有奇偶长度两种情况，通过补充间隔符可以将这两种情况化简为奇数长度。\r比如 ABA 补充为 #A#B#A# 中点还是 B，ABBA 补充为 #A#B#B#A# 中点为 #，最后可以去掉。\r算法用 JavaScript 写，我将原串转为数组，间隔符就用 null。\r最后在两侧补上哨兵点方便遍历中止。我用了 NaN。所以看起来是这样\rvar arr = [NaN, null]\rfor (let i = 0; i \u003c str.length; i += 1) {\rarr.push(str[i])\rarr.push(null)\r}\rarr.push(NaN)\r3.详解 马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。\r首先我们解决下奇数和偶数的问题，在每个字符间插入 \"#\"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 \"^\" 和 \"$\"，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。\r马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。\r首先我们解决下奇数和偶数的问题，在每个字符间插入 \"#\"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 \"^\" 和 \"$\"，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。\r首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 \"#\" 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 \"#c#b#c#b#c#\"。而去掉 # 恢复到原来的字符串，变成 \"cbcbc\"，它的长度刚好也就是 5。\r4.求原字符串下标 用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。\r例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。\r5.求每个 P [ i ] 接下来是算法的关键了，它充分利用了回文串的对称性。\r我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。\r让我们考虑求 P [ i ] 的时候，如下图。\r用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。\r我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。\r但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。\r(1)超出了R 当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。\r(2) P [ i_mirror ] 遇到了原字符串的左边界 此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 \"#\" == \"#\"，之后遇到了 \"^\" 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。\r(3)i 等于了 R 此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。\r6.考虑 C 和 R 的更新 就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。\r此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。\rpublic String preProcess(String s) {\rint n = s.length();\rif (n == 0) {\rreturn \"^$\";\r}\rString ret = \"^\";\rfor (int i = 0; i \u003c n; i++)\rret += \"#\" + s.charAt(i);\rret += \"#$\";\rreturn ret;\r}\r// 马拉车算法\rpublic String longestPalindrome2(String s) {\rString T = preProcess(s);\rint n = T.length();\rint[] P = new int[n];\rint C = 0, R = 0;\rfor (int i = 1; i \u003c n - 1; i++) {\rint i_mirror = 2 * C - i;\rif (R \u003e i) {\rP[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\r} else {\rP[i] = 0;// 等于 R 的情况\r}\r// 碰到之前讲的三种情况时候，需要利用中心扩展法\rwhile (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\rP[i]++;\r}\r// 判断是否需要更新 R\rif (i + P[i] \u003e R) {\rC = i;\rR = i + P[i];\r}\r}\r// 找出 P 的最大值\rint maxLen = 0;\rint centerIndex = 0;\rfor (int i = 1; i \u003c n - 1; i++) {\rif (P[i] \u003e maxLen) {\rmaxLen = P[i];\rcenterIndex = i;\r}\r}\rint start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标\rreturn s.substring(start, start + maxLen);\r}\rclass Solution:\rdef longestPalindrome(self, s):\rformat_s = self.pre_process(s)\rlength = len(format_s)\rps = [0] * length\rcenter = 0\rright = 0\rfor current in range(1, length - 1):\rcurrent_mirror = 2 * center - current\rif (current + ps[current_mirror]) \u003c right and (current_mirror - 1) != 0:\rps[current] = ps[current_mirror]\relif (current + ps[current_mirror]) \u003c right and (current_mirror - 1) == 0:\ri = 1\rwhile (current - i) \u003e= 0 and (current + i) \u003c length and format_s[current - i] == format_s[current + i]:\rps[current] += 1\ri+=1\rif ps[current] \u003c ps[current_mirror]:\rps[current] = ps[current_mirror]\relse:\ri = 1\rwhile (current - i) \u003e= 0 and (current + i) \u003c length and format_s[current - i] == format_s[\rcurrent + i]:\rps[current] += 1\ri += 1\rif ps[current] + center \u003e right:\rcenter = current\rright = ps[current] + center\rmax_length = 0\rcenter_index = 0\rfor i in range(1, length -1):\rif ps[i] \u003e max_length:\rmax_length = ps[i]\rcenter_index = i\rstart = (center_index - max_length) // 2\rreturn s[start:start + max_length]\rdef pre_process(self, s):\rresult = \"#\"\rfor i in range(len(s)):\rresult += s[i]\rresult += '#'\rreturn result\rif __name__ == '__main__':\rsolution = Solution()\rresult = solution.longestPalindrome(\"ababcbab\")\rprint(result)\r时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O ( n )。\r空间复杂度：O(n)。\r总结 时间复杂度从三次方降到了一次，美妙！这里两次用到了动态规划去求解，初步认识了动态规划，就是将之前求的值保存起来，方便后边的计算，使得一些多余的计算消失了。并且在动态规划中，通过观察数组的利用情况，从而降低了空间复杂度。而 Manacher 算法对回文串对称性的充分利用，不得不让人叹服，自己加油啦\r作者：windliang\r链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/\r来源：力扣（LeetCode）\r著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r","description":"leetcode，05 马拉车算法","tags":["leetcode"],"title":"05 马拉车算法","uri":"/posts/leetcode/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"},{"categories":["leetcode"],"content":"将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：\nL C I R\rE T O E S I I G\rE D H N\r之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\r示例 1:\n输入: s = \"LEETCODEISHIRING\", numRows = 3\r输出: \"LCIRETOESIIGEDHN\"\r示例 2:\n输入: s = \"LEETCODEISHIRING\", numRows = 4\r输出: \"LDREOEIIECIHNTSG\"\r解释:\rL D R\rE O E I I\rE C I H N\rT S G\r题解 算法: 这个 Z 字型其实是这样的：\n对于前面的 3行的 示例1 , 它的字符数分布是这样的：\n对于前面的 4 行的 示例2 , 它的字符数分布是这样的：\n那么对于 n 行的字符数分布是这样的：\n如上图所示，我们可以发现：\n1.当前行 curRow 为 0 或 n-1 时，箭头发生反向转折。 方法一： 从左到右按箭头方向迭代 s ，将每个字符添加到合适的行。之后从上到下遍历行即可。\n我们假定 n=numRows :\n代码如下\nclass Solution:\rdef convert(self, s, numRows):\rlength = len(s)\rrow_num = numRows\rif length \u003c= row_num or row_num == 1:\rreturn s\rresult = ['']*row_num\rturn = False\rcurrent = 0\rfor c in s:\rresult[current] += c\rif current == 0 or current == (row_num - 1):\rturn = not turn\rcurrent += 1 if turn else -1\rr = ''\rfor s in result:\rr += s\rreturn r\rif __name__ == '__main__':\rsolution = Solution()\rsolution.convert('LEETCODEISHIRING', 3)\r因为只需遍历一次，所以时间复杂度为 O(len(s))‘O(len(s))‘\n","description":"leetcode，06 Z 字形变换","tags":["leetcode"],"title":"06 Z 字形变换","uri":"/posts/leetcode/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"categories":["leetcode"],"content":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\r示例 1: 输入: 123\r输出: 321\r示例 2: 输入: -123\r输出: -321\r示例 3: 输入: 120\r输出: 21\r注意:\r假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\rclass Solution:\rdef reverse(self, x):\r\"\"\"\r:type x: int\r:rtype: int\r\"\"\"\rflag = True\rif x \u003c 0:\rflag = False\rtmp = str(x)[::-1] if flag else '-' + str(x)[1:][::-1]\rresult = int(tmp)\rif result \u003c -2 ** 31 or result \u003e (2 ** 31 - 1):\rreturn 0\relse:\rreturn result\r","description":"leetcode，07 整数反转","tags":["leetcode"],"title":"07 整数反转","uri":"/posts/leetcode/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"categories":["leetcode"],"content":"请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明：\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。\n示例 1: 输入: \"42\"\r输出: 42\r示例 2: 输入: \" -42\"\r输出: -42\r解释: 第一个非空白字符为 '-', 它是一个负号。\r我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\r示例 3: 输入: \"4193 with words\"\r输出: 4193\r解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\r示例 4: 输入: \"words and 987\"\r输出: 0\r解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\r因此无法执行有效的转换。\r示例 5: 输入: \"-91283472332\"\r输出: -2147483648\r解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−2^31) 。\rclass Solution:\rdef myAtoi(self, str):\rfixed = str.strip()\rif not fixed:\rreturn 0\rsymbol = ['+', '-']\rresult = ''\rfor i in range(0, len(fixed)):\rif fixed[i] == '+' and i == 0:\rcontinue\relif (fixed[i] == '-' and i == 0) or fixed[i].isdigit():\rresult += fixed[i]\relse:\rbreak\rif not result or result == '-' or result == '+':\rreturn 0\rint_max = 2 ** 31 - 1\rint_min = -2 ** 31\rif int(result) \u003e int_max:\rreturn int_max\relif int(result) \u003c int_min:\rreturn int_min\rreturn int(result)\rif __name__ == '__main__':\rsolution = Solution()\rresult = solution.myAtoi(\" 0000000000012345678\")\rprint(result)\r","description":"leetcode，08 字符串转换整数","tags":["leetcode"],"title":"08 字符串转换整数","uri":"/posts/leetcode/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"},{"categories":["leetcode"],"content":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\r示例 1: 输入: 121\r输出: true\r示例 2: 输入: -121\r输出: false\r解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\r示例 3: 输入: 10\r输出: false\r解释: 从右向左读, 为 01 。因此它不是一个回文数。\r进阶:\r你能不将整数转为字符串来解决这个问题吗？\rclass Solution:\rdef isPalindrome(self, x):\r\"\"\"\r:type x: int\r:rtype: bool\r\"\"\"\rif str(x) == str(x)[::-1]:\rreturn True\relse:\rreturn False\r","description":"leetcode，09 回文数","tags":["leetcode"],"title":"09 回文数","uri":"/posts/leetcode/09-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["leetcode"],"content":"给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\r说明：你不能倾斜容器，且 n 的值至少为 2。\r图中垂直线代表输入数组\r[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\r示例: 输入: [1,8,6,2,5,4,8,3,7]\r输出: 49\rclass Solution:\rdef maxArea(self, height):\rlength = len(height)\rmax = 0\rleft_index = 0\rright_index = length - 1\rwhile left_index \u003c right_index:\rarea = min(height[left_index], height[right_index]) * (right_index - left_index)\rif max \u003c area:\rmax = area\rif height[left_index] \u003c height[right_index]:\rwhile left_index \u003c right_index:\rif height[left_index] \u003c height[left_index + 1]:\rleft_index = left_index + 1\rbreak\relse:\rleft_index = left_index + 1\relse:\rright_index = right_index - 1\rwhile right_index \u003c left_index:\rif height[right_index] \u003c height[right_index - 1]:\rright_index = right_index - 1\rbreak\relse:\rright_index -= 1\rreturn max\r\"\"\"\r时间复杂度为O(n)， 空间复杂度为O(1)\r思路：left、right游标分别从列表左右两端向中间靠拢\r1、计算以left、right为左右游标的容量（取游标指向的值中较小的作为容器高度）\r2、比较left、right两个游标指向值的大小，较小的往下一个位置移动，\r否则随便选择一个游标下移，在本程序中固定选择右边的游标下移\r3、重复步骤1 的计算，直到程序结束\r\"\"\"\rclass Solution:\rdef maxArea(self, height: list) -\u003e int:\rmax = 0\rleft = 0\rright = len(height) - 1\rwhile left \u003c right:\rl = left #暂存左边游标的位置\rr = right #暂存右边游标的位置\rif height[left] \u003c height[right]:\rh = height[left]\rleft += 1\relse:\rh = height[right]\rright -= 1\rtmp = h * (r - l) #计算当前容器的容量\rmax = tmp if tmp \u003e max else max\rreturn max\r","description":"leetcode，11 盛最多水的容器","tags":["leetcode"],"title":"11 盛最多水的容器","uri":"/posts/leetcode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["leetcode"],"content":"罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n字符 数值\rI 1\rV 5\rX 10\rL 50\rC 100\rD 500\rM 1000\r例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n示例 1: 输入: 3\r输出: \"III\"\r示例 2: 输入: 4\r输出: \"IV\"\r示例 3: 输入: 9\r输出: \"IX\"\r示例 4: 输入: 58\r输出: \"LVIII\"\r解释: L = 50, V = 5, III = 3.\r示例 5： 输入: 1994\r输出: \"MCMXCIV\"\r解释: M = 1000, CM = 900, XC = 90, IV = 4.\rclass Solution:\rdef intToRoman(self, num):\r# store = {'I': 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IV\": 4, \"IX\": 9, \"XL\": 40, \"XC\": 90,\r# \"CD\": 400, \"CM\": 900}\rstore = {1: \"I\", 5: \"V\", 10: \"X\", 50: 'L', 100: 'C', 500: 'D', 1000: 'M', 4: 'IV', 9: 'IX', 40: 'XL', 90: 'XC',\r400: 'CD',\r900: 'CM'}\r# store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True))\rstore_list = sorted(store.keys(), reverse=True)\rprint(store_list)\rresult = []\rindex = 0\rwhile True:\rfor i in range(index, len(store_list)):\rvalue = store_list[i]\rif value \u003c= num:\rindex = i\rtmp = store_list[index]\rnum = num - tmp\rresult.append(store[tmp])\rbreak\rif num == 0:\rbreak\rreturn ''.join(result)\r","description":"leetcode，12 整数转罗马数","tags":["leetcode"],"title":"12 整数转罗马数","uri":"/posts/leetcode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/"},{"categories":["leetcode"],"content":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n字符 数值\rI 1\rV 5\rX 10\rL 50\rC 100\rD 500\rM 1000\r例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\r通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\rX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\r给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\r示例 1: 输入: \"III\"\r输出: 3\r示例 2: 输入: \"IV\"\r输出: 4\r示例 3: 输入: \"IX\"\r输出: 9\r示例 4: 输入: \"LVIII\"\r输出: 58\r解释: L = 50, V= 5, III = 3.\r示例 5: 输入: \"MCMXCIV\"\r输出: 1994\r解释: M = 1000, CM = 900, XC = 90, IV = 4.\r# -*- coding: utf-8 -*-\r# @Time : 2018/12/2 16:48\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 13.py\r# @Software : PyCharm class Solution(object):\rdef romanToInt(self, s):\r\"\"\"\r:type s: str\r:rtype: int\r\"\"\"\r# store = {1: \"I\", 5: \"V\", 10: \"X\", 50: 'L', 100: 'C', 500: 'D', 1000: 'M', 4: 'IV', 9: 'IX', 40: 'XL', 90: 'XC',\r# 400: 'CD',\r# 900: 'CM'}\rstore = {'I': 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IV\": 4, \"IX\": 9, \"XL\": 40, \"XC\": 90,\r\"CD\": 400, \"CM\": 900}\r# store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True))\rresult = []\rlength = len(s)\rindex = 0\rwhile index \u003c length:\rif (index +1) \u003c length and (s[index] + s[index + 1]) in store.keys():\rresult.append(store[s[index] + s[index + 1]])\rindex += 2\relse:\rresult.append(store[s[index]])\rindex += 1\rtmp = 0\rfor i in result:\rtmp += i\rreturn tmp\rif __name__ == '__main__':\rsolution = Solution()\r# print(solution.romanToInt(\"III\"))\rprint(solution.romanToInt(\"IV\"))\r","description":"leetcode，13 罗马数转整数","tags":["leetcode"],"title":"13 罗马数转整数","uri":"/posts/leetcode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode"],"content":"编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 “\"。\n示例 1: 输入: [\"flower\",\"flow\",\"flight\"]\r输出: \"fl\"\r示例 2: 输入: [\"dog\",\"racecar\",\"car\"]\r输出: \"\"\r解释: 输入不存在公共前缀。\r说明:\r所有输入只包含小写字母 a-z 。\r# -*- coding: utf-8 -*-\r# @Time : 2018/12/2 22:48\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 14.py\r# @Software : PyCharm class Solution:\rdef longestCommonPrefix(self, strs):\r\"\"\"\r:type strs: List[str]\r:rtype: str\r\"\"\"\rlength = len(strs)\rif length == 0 or (length == 1 and strs[0] == ''):\rreturn \"\"\rresult = []\rmin_length = len(min(strs, key=len))\rindex = 0\rwhile index \u003c min_length:\rflag = True\rall = None\rfor value in strs:\rif all is None:\rall = value[index]\rcontinue\rif all == value[index]:\rcontinue\relse:\rflag = False\rbreak\rif not flag:\rbreak\relse:\rindex += 1\rresult.append(all)\rreturn ''.join(result)\rif __name__ == '__main__':\rsolution = Solution()\r# print(solution.longestCommonPrefix([\"flower\", \"flow\", \"flight\"]))\rprint(solution.longestCommonPrefix([\"\", \"\"]))\r","description":"leetcode，14 最长公共前缀","tags":["leetcode"],"title":"14 最长公共前缀","uri":"/posts/leetcode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["leetcode"],"content":"给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\r给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\r示例: 输入：\"23\"\r输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\r方法：回溯\r回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。\r给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。\r如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。\r如果还有数字需要被输入：\r遍历下一个数字所对应的所有映射的字母。\r将当前的字母添加到组合最后，也就是 combination = combination + letter 。\r重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。\r问题转化成了从根节点到空节点一共有多少条路径； class Solution:\rdef letterCombinations(self, digits: str):\rif len(digits) == 0:\rreturn []\rnumber_al_dict = {\r'2': 'abc',\r'3': 'def',\r'4': 'ghi',\r'5': 'jkl',\r'6': 'mno',\r'7': 'pqrs',\r'8': 'tuv',\r'9': 'wxyz'\r}\rif len(digits) == 1:\rreturn [i for i in number_al_dict[digits[0]]]\rtmp = []\routput = []\rdef backtrack(path, next_numbers):\rif len(next_numbers) == 0:\rtmp.append(path)\routput.append(\"\".join(path))\rreturn\rfor letter in number_al_dict[next_numbers[0]]:\r# if letter in path:\r# continue\rpath.append(letter)\rbacktrack(path, next_numbers[1:])\rpath.pop()\rbacktrack([], digits)\rreturn output\r","description":"leetcode，17 电话号码的字母组合","tags":["leetcode"],"title":"17 电话号码的字母组合","uri":"/posts/leetcode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["leetcode"],"content":"给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\r### 注意：\r答案中不可以包含重复的四元组。\r示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\r满足要求的四元组集合为：\r[\r[-1, 0, 0, 1],\r[-2, -1, 1, 2],\r[-2, 0, 0, 2]\r]\r解法1：回溯法 class Solution:\rdef fourSum(self, nums, target: int):\rif len(nums) \u003c 4:\rreturn []\routput = []\rdef backtrack(path, next):\rif len(path) == 4:\routput.append(sorted(path))\rreturn\rfor index, element in enumerate(next):\rpath.append(element)\rbacktrack(path, next[index + 1:])\rpath.pop()\rbacktrack([], nums)\rresult = []\rfor element in output:\rif sum(element) == target and element not in result:\rresult.append(element)\rreturn result\r","description":"leetcode，18 四数之和","tags":["leetcode"],"title":"18 四数之和","uri":"/posts/leetcode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["leetcode"],"content":"将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例： 输入：1-\u003e2-\u003e4, 1-\u003e3-\u003e4\r输出：1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4\r方法 2：迭代\r想法\r我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\r算法\r首先，我们设定一个哨兵节点 \"prehead\" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\r在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\r# -*- coding: utf-8 -*-\r# @Time : 2020/3/27 23:37\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 21_.py\r# @Software : PyCharm # Definition for singly-linked list.\rclass ListNode:\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution:\rdef mergeTwoLists(self, l1: ListNode, l2: ListNode):\r# head = ListNode(-1)\rhead = ListNode(-1)\rcur = head\rwhile l1 and l2:\rif l1.val \u003c= l2.val:\rcur.next = l1\rl1 = l1.next\relse:\rcur.next = l2\rl2 = l2.next\rcur = cur.next\rcur.next = l1 if l2 is None else l2\rreturn head.next\rif __name__ == '__main__':\rsolution = Solution()\rhead_1 = ListNode(1)\rnode_2 = ListNode(2)\rnode_4 = ListNode(4)\rhead_1.next = node_2\rnode_2.next = node_4\rhead_2 = ListNode(1)\rnode_3 = ListNode(3)\rnode_4_copy = ListNode(4)\rhead_2.next = node_3\rnode_3.next = node_4_copy\rresult = solution.mergeTwoLists(head_1, head_2)\rwhile result:\rprint(result.val)\rresult = result.next\r","description":"leetcode，21 合并两个有序列表","tags":["leetcode"],"title":"21 合并两个有序列表","uri":"/posts/leetcode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"},{"categories":["leetcode"],"content":"实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\r如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\r必须原地修改，只允许使用额外常数空间。\r以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\r1,2,3 → 1,3,2\r3,2,1 → 1,2,3\r1,1,5 → 1,5,1\r“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\r我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。\r以 1,2,3,4,5,6 为例，其排列依次为：\r123456\r123465\r123546\r...\r654321\r算法推导 如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：\r1.我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。\r2.我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：\r（1）在尽可能靠右的低位进行交换，需要从后向前查找\r（2）将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换\r（3）将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列\r以上就是求“下一个排列”的分析过程。\r算法过程 标准的“下一个排列”算法可以描述为：\r1.从后向前查找第一个**==相邻升序==**的元素对 (i,j)，满足 A[i] \u003c A[j]。此时 [j,end) 必然是降序\r2.在 [j,end) 从后向前查找第一个满足 A[i] \u003c A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」\r3.将 A[i] 与 A[k] 交换\r4.可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序\r5.如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4\r可视化 以求 12385764 的下一个排列为例：\r首先从后向前查找第一个相邻升序的元素对 (i,j)。这里 i=4，j=5，对应的值为 5，7：\r然后在 [j,end) 从后向前查找第一个大于 A[i] 的值 A[k]。这里 A[i] 是 5，故 A[k] 是 6：\r将 A[i] 与 A[k] 交换。这里交换 5、6：\r这时 [j,end) 必然是降序，逆置 [j,end)，使其升序。这里逆置 [7,5,4]：\r因此，12385764 的下一个排列就是 12386457。\r最后再可视化地对比一下这两个相邻的排列（橙色是蓝色的下一个排列）：\rclass Solution:\rdef nextPermutation(self, nums) -\u003e None:\r\"\"\"\rDo not return anything, modify nums in-place instead.\r\"\"\"\rlength = len(nums)\rguard = -1\rguard_index = length + 1\rindex = length - 1\rwhile (index - 1) \u003e= 0:\rif nums[index - 1] \u003c nums[index]:\rguard = nums[index - 1]\rguard_index = index - 1\rbreak\rindex = index - 1\r# print(\"guard_index = {}, guard = {}\".format(guard_index, guard))\rif guard_index == (length + 1):\rreturn nums.sort(reverse=False)\rcur_index = length - 1\rwhile cur_index \u003e guard_index:\rif nums[cur_index] \u003e guard:\rbreak\rcur_index -= 1\rif cur_index \u003e= length:\rcur_index = index\rnums[cur_index], nums[guard_index] = nums[guard_index], nums[cur_index]\rfor i in range(guard_index + 1, length - 1):\rfor j in range(guard_index + 1, length - 1):\rif nums[j] \u003e nums[j + 1]:\rnums[j], nums[j + 1] = nums[j + 1], nums[j]\r","description":"leetcode，31 下一个排列","tags":["leetcode"],"title":"31 下一个排列","uri":"/posts/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["leetcode"],"content":"给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个位置。\n示例 1: 输入: [2,3,1,1,4]\r输出: true\r解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\r示例 2: 输入: [3,2,1,0,4]\r输出: false\r解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\r解题思路：  如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。 如果可以一直跳到最后，就成功了。  class Solution:\rdef canJump(self, nums) -\u003e bool:\rlength = len(nums)\rk = 0\rfor i in range(length):\rif i \u003e k:\rreturn False\rk = max(k, k + nums[i])\rreturn True\r","description":"leetcode，55 跳跃游戏","tags":["leetcode"],"title":"55 跳跃游戏","uri":"/posts/leetcode/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"categories":["leetcode"],"content":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4)\r输出：7 -\u003e 0 -\u003e 8\r原因：342 + 465 = 807\r代码\n# Definition for singly-linked list.\r# class ListNode(object):\r# def __init__(self, x):\r# self.val = x\r# self.next = None\rclass Solution(object):\rdef addTwoNumbers(self, l1, l2):\r\"\"\"\r:type l1: ListNode\r:type l2: ListNode\r:rtype: ListNode\r\"\"\"\rlist_1 = \"\"\rlist_2 = \"\"\rif not l1 and not l2:\rreturn 0\rwhile l1:\rlist_1 += str(l1.val)\rl1 = l1.next\rnum_1 = int(list_1[::-1]) if list_1 else 0\rwhile l2:\rlist_2 += str(l2.val)\rl2 = l2.next\rnum_2 = int(list_2[::-1]) if list_2 else 0\rsum = list(str(num_1 + num_2)[::-1])\rhead = ListNode(sum[0])\rcur = head\rfor i in range(1, len(sum)):\rcur.next = ListNode(sum[i])\rcur = cur.next\rreturn head\r","description":"leetcode，两数相加","tags":["leetcode"],"title":"（2）两数相加","uri":"/posts/leetcode/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\r给定 nums = [2, 7, 11, 15], target = 9\r因为 nums[0] + nums[1] = 2 + 7 = 9\r所以返回 [0, 1]\r解法一 class Solution(object):\rdef twoSum(self, nums, target):\r\"\"\"\r:type nums: List[int]\r:type target: int\r:rtype: List[int]\r\"\"\"\rif not len(nums):\rreturn []\rfor i in range(len(nums)):\rfor j in range(i+1, len(nums)):\rif nums[i] + nums[j] == target:\rreturn [i,j]\r解法二 利用Python创建字典（即hash），同时有效避免了key相同的情况\rclass Solution:\rdef twoSum(self, nums, target):\rdic = {}\rfor i in range(len(nums)):\rif str(target - nums[i]) in dic:\rreturn [dic[str(target - nums[i])], i]\rdic[str(nums[i])] = i\r","description":"leetcode，01 两数之和相加","tags":["leetcode"],"title":"01 两数之和相加","uri":"/posts/leetcode/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\r给定 nums = [2, 7, 11, 15], target = 9\r因为 nums[0] + nums[1] = 2 + 7 = 9\r所以返回 [0, 1]\r解法一 class Solution(object):\rdef twoSum(self, nums, target):\r\"\"\"\r:type nums: List[int]\r:type target: int\r:rtype: List[int]\r\"\"\"\rif not len(nums):\rreturn []\rfor i in range(len(nums)):\rfor j in range(i+1, len(nums)):\rif nums[i] + nums[j] == target:\rreturn [i,j]\r解法二 利用Python创建字典（即hash），同时有效避免了key相同的情况\rclass Solution:\rdef twoSum(self, nums, target):\rdic = {}\rfor i in range(len(nums)):\rif str(target - nums[i]) in dic:\rreturn [dic[str(target - nums[i])], i]\rdic[str(nums[i])] = i\r","description":"leetcode，两数之和相加","tags":["leetcode"],"title":"（1）两数之和相加","uri":"/posts/leetcode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["python","WSGI"],"content":"WSGI 是个什么东西？ 实际的生产环境中，Python应用程序是放在服务器的http server（比如Apache、Nginx等）上的。现在的问题是http server（之后以服务器代称）怎么把接收到的请求传递给Python应用程序？这就是WSGI做的事情。\nWSGI（Web Server Gateway Interface）即Web服务器网关接口，解耦了服务器（Apache、Nginx等）和Python应用程序，是Python开发者只需要关注Python应用程序的开发。\n Web Server：即HTTP Server，接收用户的请求并返回响应信息；分为以下两部分：\n 服务器，如Apache、Nginx等 Python应用程序，负责处理业务逻辑   HTTP Server 实现 服务器每接收到一个请求就调用一次Python Application。服务器作用如下\n 接收HTTP请求 提供environ和回调函数start_response，并传给callable object 调用callable object  以下是PEP-3333提供的示例\nimport os, sys\renc, esc = sys.getfilesystemencoding(), 'surrogateescape'\rdef unicode_to_wsgi(u):\r# Convert an environment variable to a WSGI \"bytes-as-unicode\" string\rreturn u.encode(enc, esc).decode('iso-8859-1')\rdef wsgi_to_bytes(s):\rreturn s.encode('iso-8859-1')\rdef run_with_cgi(application):\r\"\"\"\rapplication: 是Python Application中的callable object\r\"\"\"\r# 构造environ变量，dict类型，里面的内容是一次HTTP请求的环境变量\renviron = {k: unicode_to_wsgi(v) for k,v in os.environ.items()}\renviron['wsgi.input'] = sys.stdin.buffer\renviron['wsgi.errors'] = sys.stderr\renviron['wsgi.version'] = (1, 0)\renviron['wsgi.multithread'] = False\renviron['wsgi.multiprocess'] = True\renviron['wsgi.run_once'] = True\rif environ.get('HTTPS', 'off') in ('on', '1'):\renviron['wsgi.url_scheme'] = 'https'\relse:\renviron['wsgi.url_scheme'] = 'http'\rheaders_set = []\rheaders_sent = []\r# 把响应信息写到终端\rdef write(data):\rout = sys.stdout.buffer\rif not headers_set:\rraise AssertionError(\"write() before start_response()\")\relif not headers_sent:\r# Before the first output, send the stored headers\rstatus, response_headers = headers_sent[:] = headers_set\rout.write(wsgi_to_bytes('Status: %s\\r\\n' % status))\rfor header in response_headers:\rout.write(wsgi_to_bytes('%s: %s\\r\\n' % header))\rout.write(wsgi_to_bytes('\\r\\n'))\rout.write(data)\rout.flush()\r# 定义start_response回调函数\rdef start_response(status, response_headers, exc_info=None):\rif exc_info:\rtry:\rif headers_sent:\r# Re-raise original exception if headers sent\rraise exc_info[1].with_traceback(exc_info[2])\rfinally:\rexc_info = None # avoid dangling circular ref\relif headers_set:\rraise AssertionError(\"Headers already set!\")\rheaders_set[:] = [status, response_headers]\r# Note: error checking on the headers should happen here,\r# *after* the headers are set. That way, if an error\r# occurs, start_response can only be re-called with\r# exc_info set.\rreturn write\rresult = application(environ, start_response)\rtry:\r# 处理application返回的结果（可迭代）\rfor data in result:\rif data: # don't send headers until body appears\rwrite(data)\rif not headers_sent:\rwrite('') # send headers now if body was empty\rfinally:\rif hasattr(result, 'close'):\rresult.close()\r中间件Middleware Middlerware是位于Http Server和Python Application之间的功能组件。\n对于Http Server而言，Middlerware就是应用程序；对于Python Application而言，Middlerware就是Http Server。Middleware对Http Server和Python Application是透明的，把从Http Server接收到的请求进行处理并向后传递，一直传递给Python Application，最后把Python Application的处理结果返回给Http Server。如下图：\nMiddlerware组件可执行以下功能：\n 根据 url 把用户请求调度到不同的 Python Application 中。 负载均衡，转发用户请求 预处理 XSL 等相关数据 限制请求速率，设置白名单   PS：WSGI 的 middleware 体现了 unix 的哲学之一：do one thing and do it well。\n 本例实现了一个关于异常处理的 middleware（摘自）：\nfrom sys import exc_info\rfrom traceback import format_tb\rclass ExceptionMiddleware(object):\r\"\"\"The middleware we use.\"\"\"\rdef __init__(self, app):\rself.app = app\rdef __call__(self, environ, start_response):\r\"\"\"Call the application can catch exceptions.\"\"\"\rappiter = None\r# just call the application and send the output back\r# unchanged but catch exceptions\rtry:\rappiter = self.app(environ, start_response)\rfor item in appiter:\ryield item\r# if an exception occours we get the exception information\r# and prepare a traceback we can render\rexcept:\re_type, e_value, tb = exc_info()\rtraceback = ['Traceback (most recent call last):']\rtraceback += format_tb(tb)\rtraceback.append('%s: %s' % (e_type.__name__, e_value))\r# we might have not a stated response by now. try\r# to start one with the status code 500 or ignore an\r# raised exception if the application already started one.\rtry:\rstart_response('500 INTERNAL SERVER ERROR', [\r('Content-Type', 'text/plain')])\rexcept:\rpass\ryield '\\n'.join(traceback)\r# wsgi applications might have a close function. If it exists\r# it *must* be called.\rif hasattr(appiter, 'close'):\rappiter.close()\rPython Application Python Application端必须定义一个 callable object，callable object 可以是以下三者之一：\n function/method class instance with a __call__ method  callable object必须满足以下两个条件：\n 接收两个参数：environ（字典，WSGI的环境信息）、start_response（响应请求的函数, 返回HTTP status、headers给server） 返回一个可迭代的值（iterable）   重点内容：\n environ和start_response由http server提供并实现 environ变量是包含环境变量的字典 Python Application内部在返回前调用start_response start_response也是一个callable，接收两个必要的参数，status和response_headers   callable object代码实现 1.function/method def application(environ, start_response):\r# 调用服务器程序提供的 start_response，填入两个参数\rstart_response('200 OK', [('Content-Type', 'text/json')])\rreturn []\r2.class class ApplicationClass(object):\rdef __init__(self, environ, start_response):\rself.environ = environ\rself.start_response = start_response\rdef __iter__(self):\rself.start_response('200 OK', [('Content-Type', 'text/json')])\ryield \"随便\"\r 使用方式\nfor result in ApplicationClass(environ, start_response):\rdo_somthing(result)\r 3.instance with a call method class ApplicationClass(object):\rdef __init__(self):\rpass\rdef __call__(self, environ, start_response):\rstart_response('200 OK', [('Content-Type', 'text/json')])\ryield \"anything\"\r 使用方式\napp = ApplicationClass()\rfor result in app(environ, start_response):\rdo_something(result)\r 参考链接 PEP-3333\n巨佬\n","description":"","tags":["flask","python","wsgi"],"title":"WSGI 理解（1）","uri":"/posts/wsgi/wsgi_kl_1/"},{"categories":["blog","hugo"],"content":"不能评论! Hugo 是一个强大的静态网页生成器，使用 go 开发，速度贼快。不过 Hugo 还比较年轻，没有像 NexT 那样功能强大，成熟稳定的主题。所以很多东西需要自己动手撸。\n比如评论系统。\n 评论系统排名\n  valine \u003e gitalk \u003e gitment \u003e livere \u003e 畅言\n 关于Valine   官方网址： «https://valine.js.org/\u003e\u003e\n  其特性不一一赘述，官方网址有介绍\n  添加评论区 目前博客使用的主题是meme\n不同的主题可能有所区别，但原理大都类似\n 原理？ Hugo 会将 Markdown 文档 按照 主题 (包括 HTML 模板、CSS、JavaScript 等) 编译成静态网页\n那么我们只需要将 Valine作为一个 \u003cdiv\u003e 插入到 HTML 模板中，然后在 config.toml 中添加相关配置，就可以添加评论区了\n Leancloud相关配置 评论系统依赖于leancloud，所以需要先在leancloud中进行相关的准备工作。\n  登录 或 注册 LeanCloud\n  登录成功后，进入后台点击左上角的创建应用：\n  创建好应用，进入应用，左边栏找到 设置 ，然后点击 应用Key，此时记录出现的 App ID 和 App Key，后面配置文件中会用到：\n  因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 Class，左边栏找到并点击 存储，点击 创建Class:\n  创建两个存储Class，分别命名为: Counter 和 Comment;\n  还需要为应用添加安全域名，左边栏点击 设置，找到 安全中心，点击后会看到 安全域名 设置框，输入博客使用的域名，点击保存即可：\n  config.toml开启comment  将enableComments = false设置为enableComments = true 将enableValine = false设置为enableValine = true   添加 Valine 参数项：\n ## Valine\renableValine = true\rvalineAppId = \"************\"\rvalineAppKey = \"*****************\"\rvalinePlaceholder = \"Just go go\"\rvalinePath = \"\"\rvalineAvatar = \"mm\"\rvalineMeta = [\"nick\", \"mail\", \"link\"]\rvalinePageSize = 10\rvalineLang = \"zh-cn\"\rvalineVisitor = false\rvalineHighlight = true\rvalineAvatarForce = false\rvalineRecordIP = false\rvalineServerURLs = \"\"\rvalineEmojiCDN = \"\"\rvalineEmojiMaps = {}\rvalineEnableQQ = false\rvalineRequiredFields = []\r上面几项内容的含义，这里简单一说，具体还是要看 Valine官网中配置相关的内容：\n   参数 用途     enable 这是用于主题中配置的，不是官方Valine的参数，true时控制开启此评论系统   appId 这是在 leancloud 后台应用中获取的，也就是上面提到的 App ID   appKey 这是在 leancloud 后台应用中获取的，也就是上面提到的 App Key   notify 用于控制是否开启邮件通知功能，具体参考邮件提醒配置   verify 用于控制是否开启评论验证码功能   avatar 用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：头像配置   placehoder 评论框的提示符   visitor 控制是否开启文章阅读数的统计功能i, 详情阅读文章阅读数统计    修改主题文件 主要是修改主题中评论相关的布局文件 themes\\meme\\layouts\\partials\\components\\comments.html，按照 Valine快速开始 添加 Valine 相关代码，找到以下位置\n{{ if .Site.Params.enableValine }}\r{{- end }}\r添加的 Valine 评论的代码如下：\n{{ if .Site.Params.enableValine }}\r\u003cdiv id=\"vcomments\"\u003e\u003c/div\u003e\r\u003cscript src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"\u003e\u003c/script\u003e\r\u003cscript src='//unpkg.com/valine/dist/Valine.min.js'\u003e\u003c/script\u003e\r\u003cscript type=\"text/javascript\"\u003e\rnew Valine({\rel: '#vcomments' ,\rappId: '{{ .Site.Params.valineAppId }}',\rappKey: '{{ .Site.Params.valineAppKey }}',\rnotify: '{{ .Site.Params.valineNotify }}', verify: '{{ .Site.Params.valineVerify }}', avatar:'{{ .Site.Params.valineAvatar }}', placeholder: '{{ .Site.Params.valinePlaceholder }}',\rvisitor: '{{ .Site.Params.valineVisitor }}'\r});\r\u003c/script\u003e\r{{ end }}\r可以看到上述代码中引用了配置文件中的相关参数，这样以后修改配置就不用修改代码了，只需要改配置文件 config.toml。\n","description":"Hugo 添加评论功能","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/posts/hugo/hugo_comment/"},{"categories":["blog","hugo"],"content":"居然都找不到！ 其实Blog我主要是用来做一些记录，突然看到有博客提到GitHub Pages屏蔽了百度的爬虫，所以百度是搜索不到GitHub Pages上的网页的。\n什么？所以百度搜索搜不到我的个人博客？不死心，尝试一下，找得到github、gist主页，但是就是找不到github.io后缀的网页。除了百度之外，我还尝试了Bing、Google，都没有。\n如何让搜索引擎索引到呢？ 发现流行的搜索引擎居然都找不到博客，那就需要赶紧找解决方法。Google和Bing还不清楚是怎么回事，但网上流传的email回复内容都点明了Github Pages禁止了百度爬虫的爬去，似乎原因是百度爬虫爬得太过于频繁，会严重影响服务器性能。针对百度爬虫的问题，大家找了很多方法。自建服务器托管博客、将博客放在Gitlab上或者CDN方法都不在我的选择范围内，因为暂时我还没有购买服务器或者域名的打算，所以决定放弃百度……但不管怎么样Bing和Google还是要设置好的！\nGoogle 添加资源 在google搜索页面输入“site:affectalways.github.io”就可以看到这个网页是否被google索引到，如果没被索引到，在搜索结果页面就会直接提示你使用Google Search Console。登录后，如果是首次使用在Search Console中以下界面中选择“网页”类型资源，并将博客完整url填入其中，我填入“https://affectalways.github.io”。注意http或者https，www等最好能完全正确。\n如果已经添加过资源，则需要点击左上角的按钮，然后和上面一样地添加资源即可。\n资源添加后，需要验证你对该网站有所有权。Google提供了几种方法，我选择了三种方式：\nHTML验证文件上传 只需要根据要求，下载HTML验证文件，把文件放在站点根目录的static目录下（以本网站为例：affectalways/static）\nHTML标记 config.toml中的googleSiteVerification = \"\" 设置为 googleSiteVerification = 不为空\n找到themes/meme/layouts/partials/head.html中的\n{{- with .Site.Params.googleSiteVerification }}\r\u003cmeta name=\"google-site-verification\" content=\"\" /\u003e\r{{- end }}\r把content内容改为给定的内容，然后执行hugo命令，就可以验证了\nGoogle Analytics 先到Google Analytics创建一个账号，并登录。\n新建一个资源，填完后获得tracking code。\n更新config.toml文件，把enableGoogleAnalytics设为true，trackingCodeType设为gtag（两个选择gtag和analytics，因为affectalways.github.io使用的是Google Analytics给定的gtag.js，所以设置为gtag），trackingID设为获取到的tracking code。然后执行hugo命令，就可以验证了。\n站点地图 在左侧点击“站点地图”，并在右侧点添加/测试站点地图，并添加url，我的是https://affectalways.github.io/sitemap.xml\nBing 相似地，在Bing网站管理登陆、添加网站url。\n然后在左侧点击“配置我的网站\u003eSitemaps”，并在右侧加上sitemap的url，点击提交。\n百度不死心的尝试  不死心的失败了\n ","description":"Hugo 让 GitHub Pages被索引到","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/posts/hugo/hugo_seo/"},{"categories":["blog","hugo"],"content":"Hugo Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在这里查看。\n分类taxonomy有3个概念：\n Taxonomy 分类: 可以用来对内容进行分类的类别 Term 术语: 分类的一个键 Value 值: 分配给这个Term的具体内容  例如我需要增加3个分类，分别是：\n tag：文章标签 topic：文章主题/文章系列 category：文章分类  以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如hugo，Value是打上这个标签的对应网页。\n配置分类 需要在 config.toml 中增加分类。还是这个例子，则需要增加如下内容：\n[taxonomies]\rtag = \"tags\"\rcategory = \"categories\"\r而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为：\ntitle: \"Hugo添加tags等分类\"\rdate: 2020-06-17T20:19:37+08:00\rtags: [\"hugo\"]\rdraft: true\r当然实际上，Hugo默认会产生 tags 和 categories 的分类，如果只需要这两个，可以不用在 config.toml 中声明就在post头部使用。\n分类集合查看 使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。\n还是以tag为例：\nexample.com/tags/ 会列出tags中的所有术语；\nexample.com/tags/docker 会列出tags标为docker的所有网页列表。\n 额外知识点：\n keywords、description meta标签的一个很重要的功能就是设置关键字，来帮助你的主页被各大搜索引擎登录，提高网站的访问量。在这个功能中，最重要的就是对Keywords和description的设置。因为按照搜索引擎的工作原理,搜索引擎首先派出机器人自动检索页面中的keywords和decription，并将其加入到自己的数据库，然后再根据关键词的密度将网站排序。因此，我们必须设置好关键字，来提高页面的搜索点击率。使用如下：\nkeywords: - hugo\r- blog\r- 博客\r- 建站\rdescription: \"Hugo 添加tags等分类\"\r keywords需要进行配置：\n在themes\\meme\\layouts\\partials\\header.html的\n\u003cheader class=\"header\"{{ if and (eq .Site.Params.headerLayout \"flex\") 内部添加\n就可以了\r  description是hugo支持的，不需要配置\n ","description":"Hugo 添加tags等分类","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/posts/hugo/hugo_tags/"},{"categories":["blog","hugo"],"content":"Introduction 正如上一篇说的，我选择了Hugo作为静态网页生成器。为何要放弃Hexo，换成Hugo呢？\n主要是出于以下考虑：\n 1.Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。\n2.同样得益于go，Hugo的安装配置看上去也并不麻烦；Hugo可以很轻松的被编译成二进制文件安装、运行。不必像Hexo一样依赖Node.js，也不必安装一堆依赖\n  Hugo的安装配置看上去也并不麻烦，同样得益于go，  安装 直接在这里选择合适的版本。\n下载好后解压，将解压出来的可执行文件 (格式为 .exe)，放到自己喜欢的目录下。直接可以使用，不需要安装。\n但要记住一定要将你选择的文件夹路径加入到环境变量 PATH 中。\n PS：由于theme选择的是meme，需要下载extended版本的hugo；\n 初始化 下面，初始化博客路径。首先需要选择一个路径来存放我们的博客，在你选好的路径下执行：\nhugo new site myBlog\r这条命令会创建一个名为myBlog（可以使用任意名字）的文件夹来存放你的博客。执行 cd myBlog 命令进入文件夹。\n此时目录结构应该是这样的\n.\r└── myBlog\r├── config.toml / config.yaml / config.json\r├── content\r│ └── ...\r├── layouts\r│ └── ...\r├── themes\r│ └── ...\r├── static\r│ └── ...\r├── archetypes\r│ └── ...\r├── data\r│ └── ...\r└── ...\r其中：\n config.toml 是网站的配置文件，Hugo还可使用 config.yaml 或者 config.json 进行配置。 content 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。 layouts 文件夹存放 .html 格式的模板。模板确定了静态网站渲染的样式。 themes 文件夹存放网站使用的theme主题模板。 static 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。 archetypes 文件夹存放网站预设置的文件模板头部，当使用 hugo new 时即可生成一个带有该头部的实例。 data 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。  配置theme 可以在这里找自己喜欢的主题。我暂时选择有搜索功能的meme，将主题clone到themes目录下：\ngit clone https://github.com/忘了/meme.git themes/meme\r然后将themes/meme/exampleSite/config.toml模板配置文件复制到根目录，然后根据此文件来配置你的设置。\n PS：一定要把config.yaml中的theme修改为你使用的主体名称。比如我用的主题是meme，config.yaml文件就设置theme=\"meme”\n 创建新页面 创建一个新页面\nhugo new about.md\r此时 content 文件夹下就多了一个 about.md 文件，打开文件就可以看到时间、文件名等信息已经自动生成了\n---\rtitle: \"about\"\rdate: 2020-06-16T23:30:53+08:00\rdraft: true\r---\r两条 --- 间的信息是文章的配置信息，有的信息是自动生成的 (如：title、date 等)，简单介绍以下各项配置\n  以下项目是自动生成的: title: # 文章标题 date: # 写作时间 draft: # 是否为草稿，如果为 true 需要在命令中加入 --buildDrafts 参数才会生成这个文档 以下项目需要自行添加: description: # 描述 tags: # 标签，用于文章分类 等等   自动生成 和 执行添加 的内容并不是绝对的，你可以根据自己的喜好配置模板文件 archetypes/default.md\n生成网站 设置完config.toml 后我们执行以下命令\nhugo server --buildDrafts -w\r此时你就可以在 http://localhost:1313 访问到你的博客了。\n此时你的博客目录下就会多出一个public目录，这是Hugo生成的网站。\n简单介绍一下两个参数：\n --buildDrafts: 生成被标记为 「草稿」 的文档 -w: 监控更改，如果发生更改直接显示到博客上   PS：但此时只能在本地访问 (相当于预览博客，如果与期望值不符，可以随时更改)，如果想发布到 Github Pages 上需要先将文章配置信息中的 draft: 改为 false ，\n然后执行命令\nhugo\r  GitHub Pages部署 参考这里，在Github Pages有四种类型，而对于非组织型用户来说有两种，一种是用户的个人网站，网页域名为 username.github.io，另一种为Project的主页，网页域名为 username.github.io/projectname。Github Pages对于Project主页的源码要求有了修改，现在也可以放置在master上，之前版本中必须放在gh-pages 分支上，不过这里暂且不提，主要还是关心用户个人主页。\n这就需要你在Github上建立一个以 username.github.io 为名称的repository，对于我来说就是 affectalways.github.io。此外，需要将Hugo生成的所有静态网页push到这个repository的master分支上。现在就可以用这个域名打开个人网站了。\nHugo没有提供自动发布到GitHub Pages的功能。需要将public中的内容手动上传到Github上。\n首先执行命令cd public进入到public目录，然后执行\ngit init\rgit remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git\rgit add .\rgit commit -m \"[介绍，随便写点什么，比如日期]\"\rgit push （若是第一次发布，需要用到--set-upstream）\r","description":"Hugo 建站（2）Blog","tags":["hugo"],"title":"Hugo blog（2）","uri":"/posts/hugo/hugo_install_2/"},{"categories":["blog","hugo"],"content":"初始  养个Blog的想法从很早就有了，但是…  从本科开始就一直想要一个自己的Blog，一直没有行动。本身我就没有记日志的习惯，也没有需求和冲动写下什么东西，虽然有时想记下学的内容，但有道云笔记就够了，也没什么写技术博客的想法。除了很久之前偶尔在CSDN写了几篇入门级文章，也就没有其他了。此外，虽说博客最重要的是内容，但没有一个好的生态环境和前端界面设计，至少对于我而言，没有任何兴趣花时间在上面，原谅我是外观主义者。对于界面设计，CSDN或者博客园实在不敢恭维，尤其是CSDN。自建网站之前也尝试过，恩，还要使用服务器，花钱。我得承认，当时作为本科生的我，太过局限于学校课堂，并未走出去看看，对于网络信息的运用和挖掘也更多停留在看看答案、找找软件、翻翻视频的基础使用上，最多也就是查看下算法之类的。\n最近，特别是正式工作快一年了，更多地接触了“网络世界”的信息和知识，拓宽了实页。随着自我学习机会和时间愈少，碎片化学习和感想也愈多，加上虽然网上知识丰富，但内容驳杂，过段时间想再查找却需要对这些信息重新筛选、略感费劲，再加上工作后个人体悟良多，于是又一次萌生个人博客的想法。\n难产  选择恐惧症+控制狂的特质决定了我家Blog的难产…  尽管现在有许多像知乎专栏这样现代化的界面和良好的用户群的网站可以让人直接在上面写作，但我还是更倾向于GitHub Pages，与GitHub非常紧密的关系是该倾向性很重要的原因（这对码农而言，非常有诱惑力）。\nGitHub Pages搭建个人博客，使用的是轻量级的静态网页，网上已经有了很多教程和方案。几天前遇到了三种方案：Jekyll、Hexo、Hugo。Jekyll据说可定制化和功能很强大，但是ruby个人真的很不能接受。Hexo是国人教程最多的，国外口碑也非常好，看到外国的一句评论说，缺点就是大多数内容都是中文，英文教程少，哈哈。Hexo是基于Node.js，对于程序员相当友好。不过这次我决定选择另一个Framework，使用Hugo。Hugo是用现在大热的go语言写的，据说编译起来比Hexo还会快很多。而且我最近在学go…\n开始  开始吧  那就开始吧\n","description":"Hugo 建站（1）Blog","tags":["hugo"],"title":"Hugo blog（1）","uri":"/posts/hugo/hugo_install_1/"},{"categories":["blog","hugo"],"content":"​\tHugo：是一种通用的网站框架。严格来说，这类应用应该被称作静态网站生成器。这类应用将 Markdown 文件和主题一起编译成由 HTML、CSS、JavaScript 组成的静态网页。\n​\t然后上传到 GitHub 上，通过 GitHub 提供的静态页面托管服务 (GitHub Pages) 进行访问。\n​\t这里就写一篇文章来记录一下踩过的坑。\n","description":"使用Hugo + GitHub Pages搭建个人博客","tags":["hugo"],"title":"使用Hugo + GitHub Pages搭建个人博客","uri":"/posts/hugo/hugo_install/"},{"categories":null,"content":"​\t理工男，非强迫症，不可一日无书\n","description":"","tags":null,"title":"关于我","uri":"/about/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"categories":null,"content":"面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动\n示例：\n输入： 1-\u003e2-\u003e3-\u003e4-\u003e5 和 k = 2\r输出： 4\r说明：\r给定的 k 保证是有效的。\n思路\n经典的快慢指针问题\n\r反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。\r设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点\rclass Solution(object):\rdef kthToLast(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: int\r\"\"\"\rif head is None:\rreturn None\rleft = head\rright = head\rcount = 0\rwhile count \u003c k:\rright = right.next\rcount += 1\rwhile right:\rleft = left.next\rright = right.next\rreturn left.val\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"1108. IP 地址无效化 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。\n所谓无效化 IP 地址，其实就是用 \"[.]\" 代替了每个 \".\"。\n示例 1：\n输入：address = \"1.1.1.1\"\r输出：\"1[.]1[.]1[.]1\"\r示例 2：\n输入：address = \"255.100.50.0\"\r输出：\"255[.]100[.]50[.]0\"\r提示：\n 给出的 address 是一个有效的 IPv4 地址  代码\nclass Solution(object):\rdef defangIPaddr(self, address):\r\"\"\"\r:type address: str\r:rtype: str\r\"\"\"\rreturn address.replace('.', '[.]')\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/1108-ip%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"},{"categories":null,"content":"1252. 奇数值单元格的数目 给你一个n行m列的矩阵，最开始的时候，每个单元格中的值都是 0。\n另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。\n你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。\n请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。\n示例 1：\n输入：n = 2, m = 3, indices = [[0,1],[1,1]]\r输出：6\r解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。\r第一次增量操作后得到 [[1,2,1],[0,1,0]]。\r最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\r示例 2：\n输入：n = 2, m = 2, indices = [[1,1],[0,0]]\r输出：0\r解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。\r提示：\r1 \u003c= n \u003c= 50\r1 \u003c= m \u003c= 50\r1 \u003c= indices.length \u003c= 100\r0 \u003c= indices[i][0] \u003c n\r0 \u003c= indices[i][1] \u003c m\r代码\nclass Solution(object):\rdef oddCells(self, n, m, indices):\r\"\"\"\r:type n: int\r:type m: int\r:type indices: List[List[int]]\r:rtype: int\r\"\"\"\rrecy = [[0 for i in range(m)] for j in range(n)]\rfor item in indices:\rfor x in range(n):\rrecy[x][item[1]] += 1\rfor y in range(m):\rrecy[item[0]][y] += 1\rcount = 0\rfor i in range(n):\rfor j in range(m):\rif recy[i][j] % 2 == 1:\rcount += 1\rreturn count\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/"},{"categories":null,"content":"1281. 整数的各位积和之差 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。\n示例 1：\n输入：n = 234\r输出：15 解释：\r各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15\r示例 2：\n输入：n = 4421\r输出：21\r解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21\r提示：\r1 \u003c= n \u003c= 10^5\r代码\nclass Solution(object):\rdef subtractProductAndSum(self, n):\r\"\"\"\r:type n: int\r:rtype: int\r\"\"\"\rmul = 1\rad = 0\rwhile n \u003e 0:\rtmp = n % 10\rmul *= tmp\rad += tmp\rn //= 10\rreturn mul - ad\r ","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/"},{"categories":null,"content":"1323. 6 和 9 组成的最大数字 给你一个仅由数字 6 和 9 组成的正整数 num。\n你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。\n请返回你可以得到的最大数字。\n示例 1：\n输入：num = 9669\r输出：9969\r解释：\r改变第一位数字可以得到 6669 。\r改变第二位数字可以得到 9969 。\r改变第三位数字可以得到 9699 。\r改变第四位数字可以得到 9666 。\r其中最大的数字是 9969 。\r示例 2：\n输入：num = 9996\r输出：9999\r解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。\r示例 3：\n输入：num = 9999\r输出：9999\r解释：无需改变就已经是最大的数字了。\r提示：\r1 \u003c= num \u003c= 10^4\rnum 每一位上的数字都是 6 或者 9 。\r代码\nclass Solution(object):\rdef maximum69Number(self, num):\r\"\"\"\r:type num: int\r:rtype: int\r\"\"\"\rreturn int(str(num).replace('6', '9', 1))\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/1323-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/"},{"categories":null,"content":"1431. 拥有最多糖果的孩子 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。\n对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。\n示例 1：\n输入：candies = [2,3,5,1,3], extraCandies = 3\r输出：[true,true,true,false,true] 解释：\r孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。\r孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\r孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。\r孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。\r孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\r示例 2：\n输入：candies = [4,2,1,1,2], extraCandies = 1\r输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。\r示例 3：\n输入：candies = [12,1,12], extraCandies = 10\r输出：[true,false,true]\r提示\n2 \u003c= candies.length \u003c= 100\r1 \u003c= candies[i] \u003c= 100\r1 \u003c= extraCandies \u003c= 50\r代码\nclass Solution(object):\rdef kidsWithCandies(self, candies, extraCandies):\r\"\"\"\r:type candies: List[int]\r:type extraCandies: int\r:rtype: List[bool]\r\"\"\"\rmax_val = max(candies)\rresult = [False] * len(candies)\rfor index, item in enumerate(candies):\rif (item + extraCandies) \u003e= max_val:\rresult[index] = True\rreturn result\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/"},{"categories":null,"content":"1480. 一维数组的动态和 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。\n请返回 nums 的动态和。\n示例 1：\n输入：nums = [1,2,3,4]\r输出：[1,3,6,10]\r解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。\r示例 2：\n输入：nums = [1,1,1,1,1]\r输出：[1,2,3,4,5]\r解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。\r示例 3：\n输入：nums = [3,1,2,10,1]\r输出：[3,4,6,16,17]\r提示：\r1 \u003c= nums.length \u003c= 1000\r-10^6 \u003c= nums[i] \u003c= 10^6\r代码\nclass Solution(object):\rdef runningSum(self, nums):\r\"\"\"\r:type nums: List[int]\r:rtype: List[int]\r\"\"\"\rif not nums:\rreturn []\rresult = list()\rresult.append(nums[0])\rfor ind in range(1, len(nums)):\rresult.append(result[ind - 1] + nums[ind])\rreturn result\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/1480-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/"},{"categories":null,"content":"剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab”。\n示例 1：\n输入: s = \"abcdefg\", k = 2\r输出: \"cdefgab\"\r示例 2：\n输入: s = \"lrloseumgh\", k = 6\r输出: \"umghlrlose\"\r限制：\r1 \u003c= k \u003c s.length \u003c= 10000\r代码\nclass Solution(object):\rdef reverseLeftWords(self, s, n):\r\"\"\"\r:type s: str\r:type n: int\r:rtype: str\r\"\"\"\rreturn s[n:] + s[:n]\rif __name__ == '__main__':\rsolution = Solution()\rresult = solution.reverseLeftWords(s=\"abcdefg\", n=2)\rprint(result)\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/58offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"LCP 01. 猜数字 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？\n输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。\n示例 1：\n输入：guess = [1,2,3], answer = [1,2,3]\r输出：3\r解释：小A 每次都猜对了。\r示例 2：\n输入：guess = [2,2,3], answer = [3,2,1]\r输出：1\r解释：小A 只猜对了第二次。\r限制：\nguess的长度 = 3\ranswer的长度 = 3\rguess的元素取值为 {1, 2, 3} 之一。\ranswer的元素取值为 {1, 2, 3} 之一。\r代码\nclass Solution(object):\rdef game(self, guess, answer):\r\"\"\"\r:type guess: List[int]\r:type answer: List[int]\r:rtype: int\r\"\"\"\rcount = 0\rfor index in range(len(guess)):\rif guess[index] == answer[index]:\rcount += 1\rreturn count\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/lcp-01-%E7%8C%9C%E6%95%B0%E5%AD%97/"},{"categories":null,"content":"title: \"0207 链表相交\"\rdate: 2020-07-15T21:20:33+08:00\rtags: [\"leetcode\"]\rkeywords: - leetcode\r- blog\r- 博客\r- 领扣\r- 0207 链表相交\r- 算法\r- 链表\rdescription: \"leetcode，0207 链表相交\"\rcategories: [\"leetcode\", \"链表\"]\rdraft: false\r面试题 02.07. 链表相交 我竟然没读懂题！！！！！！！！！！！\n给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。\n示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r输出：Reference of the node with value = 8\r输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r示例 2：\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r输出：Reference of the node with value = 2\r输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r示例 3：\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r输出：null\r输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r解释：这两个链表不相交，因此返回 null。\r注意：\n 1.如果两个链表没有交点，返回 null 。\r2.在返回结果后，两个链表仍须保持原有的结构。\r3.可假定整个链表结构中没有循环。\r4.程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\r思路\n双指针什么的，技巧性有点强。最朴素的做法是求长度\r1.第一次遍历两个链表，记录长度\r2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步\r3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址）\r代码\nclass ListNode:\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution:\rdef getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode:\rlen_a = 0\rlen_b = 0\rcur_a = headA\rcur_b = headB\r# 1.第一次遍历两个链表，记录长度\rwhile cur_a:\rlen_a += 1\rcur_a = cur_a.next\rwhile cur_b:\rlen_b += 1\rcur_b = cur_b.next\r# 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步\rcur_a = headA\rcur_b = headB\rwhile len_b \u003e len_a:\rcur_b = cur_b.next\rlen_b -= 1\rwhile len_a \u003e len_b:\rcur_a = cur_a.next\rlen_a -= 1\r# 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址）\rwhile cur_a:\rif cur_a == cur_b:\rreturn cur_a\rcur_a = cur_a.next\rcur_b = cur_b.next\rreturn None\rdef create_list(sequence):\rheadA = None\rcur = None\rfor i in sequence:\rnode = ListNode(i)\rif headA is None:\rheadA = cur = node\rcontinue\rcur.next = node\rcur = cur.next\rreturn headA\rif __name__ == '__main__':\rintersectVal = 8\rlistA = [4, 1, 8, 4, 5]\rheadA = create_list(listA)\rlistB = [5, 0, 1, 8, 4, 5]\rheadB = create_list(listB)\rskipA = 2\rskipB = 3\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"},{"categories":null,"content":"title: \"Offer 06. 从尾到头打印链表\"\rdate: 2020-07-15T21:20:33+08:00\rtags: [\"leetcode\"]\rkeywords: - leetcode\r- blog\r- 博客\r- 领扣\r- Offer 06. 从尾到头打印链表\r- 算法\r- 链表\rdescription: \"leetcode，Offer 06. 从尾到头打印链表\"\rcategories: [\"leetcode\", \"链表\"]\rdraft: false\r剑指 Offer 06. 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head = [1,3,2]\r输出：[2,3,1]\r限制：\n0 \u003c= 链表长度 \u003c= 10000\r思路\n## 方法一：栈\r栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。\r创建一个栈，用于存储链表的节点\r创建一个指针，初始时指向链表的头节点\r当指针指向的元素非空时，重复下列操作：\r将指针指向的节点压入栈内\r将指针移到当前节点的下一个节点\r获得栈的大小 size，创建一个数组 print，其大小为 size\r创建下标并初始化 index = 0\r重复 size 次下列操作：\r从栈内弹出一个节点，将该节点的值存到 print[index]\r将 index 的值加 1\r返回 print\r## 复杂性分析\r时间复杂度：O(n)O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。\r空间复杂度：O(n)O(n)。额外使用一个栈存储链表中的每个节点。\r代码\nclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef reversePrint(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: List[int]\r\"\"\"\rif head is None:\rreturn []\rstack = []\rwhile head:\rstack.append(head.val)\rhead = head.next\rstack.reverse()\rreturn stack\r# result = None\r# cur = None\r# for node in stack:\r# if result is None:\r# result = node\r# cur = result\r# continue\r# cur.next = node\r# cur = cur.next\r# return result\rdef create_list(sequence):\rheadA = None\rcur = None\rfor i in sequence:\rnode = ListNode(i)\rif headA is None:\rheadA = cur = node\rcontinue\rcur.next = node\rcur = cur.next\rreturn headA\rif __name__ == '__main__':\rsolution = Solution()\rhead = create_list([1, 3, 2])\rresult = solution.reversePrint(head)\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"}]
