[{"categories":null,"content":"Hello? ","date":"29290-1010-19","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["python","werkzeug"],"content":"wsgi.py开讲 wsgi.py封装了一系列方法，现在讲几个自认为是常用的方法。 get_current_url方法 （1）作用： 获取当前请求的URL （2）使用案例： \u003e\u003e\u003e from werkzeug.test import create_environ \u003e\u003e\u003e env = create_environ(\"/?param=foo\", \"http://localhost/script\") \u003e\u003e\u003e get_current_url(env) 'http://localhost/script/?param=foo' \u003e\u003e\u003e get_current_url(env, root_only=True) 'http://localhost/script/' \u003e\u003e\u003e get_current_url(env, host_only=True) 'http://localhost/' \u003e\u003e\u003e get_current_url(env, strip_querystring=True) 'http://localhost/script/' （3）代码（感觉没有什么内容可说） def get_current_url( environ, root_only=False, strip_querystring=False, host_only=False, trusted_hosts=None, ): tmp = [environ[\"wsgi.url_scheme\"], \"://\", get_host(environ, trusted_hosts)] # tmp.append， tmp是list类型，list.append方法，cat指向tmp.append cat = tmp.append if host_only: return uri_to_iri(f\"{''.join(tmp)}/\") cat(url_quote(environ.get(\"SCRIPT_NAME\", \"\").encode(\"latin1\")).rstrip(\"/\")) cat(\"/\") if not root_only: cat(url_quote(environ.get(\"PATH_INFO\", \"\").encode(\"latin1\").lstrip(b\"/\"))) if not strip_querystring: qs = get_query_string(environ) if qs: cat(f\"?{qs}\") # uri_to_iri是把URI地址转换成IRI格式（IRI包含Unicode字符，URI是ASCII字符编码） return uri_to_iri(\"\".join(tmp)) host_is_trusted方法 （1）作用 检查主机是否可行 （2）使用案例 wsgi.py get_host方法159行有用到 （3）代码 def host_is_trusted(hostname, trusted_list): if not hostname: return False # str -\u003e list if isinstance(trusted_list, str): trusted_list = [trusted_list] def _normalize(hostname): # 把port去除，只获取host if \":\" in hostname: hostname = hostname.rsplit(\":\", 1)[0] return _encode_idna(hostname) try: hostname = _normalize(hostname) except UnicodeError: return False for ref in trusted_list: if ref.startswith(\".\"): ref = ref[1:] suffix_match = True else: suffix_match = False try: ref = _normalize(ref) except UnicodeError: return False if ref == hostname: return True if suffix_match and hostname.endswith(b\".\" + ref): return True return False get_host方法 （1）作用 返回运行环境主机 （2）使用案例 pass （3）代码 def get_host(environ, trusted_hosts=None): if \"HTTP_HOST\" in environ: # HTTP_HOST 在environ rv = environ[\"HTTP_HOST\"] if environ[\"wsgi.url_scheme\"] == \"http\" and rv.endswith(\":80\"): # 获取除:80端口的主机号 rv = rv[:-3] elif environ[\"wsgi.url_scheme\"] == \"https\" and rv.endswith(\":443\"): # 获取除:443端口的主机号 rv = rv[:-4] else: rv = environ[\"SERVER_NAME\"] if (environ[\"wsgi.url_scheme\"], environ[\"SERVER_PORT\"]) not in ( (\"https\", \"443\"), (\"http\", \"80\"), ): # 获取主机+端口 rv += f\":{environ['SERVER_PORT']}\" # 判断是否可信 if trusted_hosts is not None: # 用到了host_is_trusted方法了 if not host_is_trusted(rv, trusted_hosts): from .exceptions import SecurityError raise SecurityError(f'Host \"{rv}\" is not trusted') return rv get_content_length方法 （1）作用 获取来自WSGI环境的内容长度 （2）使用案例 pass （3）代码，实在没什么好讲的 def get_content_length(environ): # 块读取，直接返回None if environ.get(\"HTTP_TRANSFER_ENCODING\", \"\") == \"chunked\": return None content_length = environ.get(\"CONTENT_LENGTH\") if content_length is not None: try: return max(0, int(content_length)) except (ValueError, TypeError): pass get_query_string方法 （1）作用 获取对应的URL字段 （2）使用案例 pass （3）代码 def get_query_string(environ): # 获取environ中的QUERY_STRING对应的值，并以latin1格式进行编码 qs = environ.get(\"QUERY_STRING\", \"\").encode(\"latin1\") # QUERY_STRING really should be ascii safe but some browsers # will send us some unicode stuff (I am looking at you IE). # In that case we want to urllib quote it badly. return url_quote(qs, safe=\":\u0026%=+$!*'(),\") ","date":"5050-88-55","objectID":"/werkzeug_sc_4/:0:1","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(4)","uri":"/werkzeug_sc_4/"},{"categories":["leetcode","数组"],"content":"leetcode，643子数组最大平均数","date":"5050-88-50","objectID":"/643%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/","tags":["leetcode"],"title":"643子数组最大平均数","uri":"/643%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/"},{"categories":["leetcode","数组"],"content":"643. 子数组最大平均数 I 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例 1: 输入: [1,12,-5,-6,50,3], k = 4 输出: 12.75 解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 注意: 1 \u003c= k \u003c= n \u003c= 30,000。 所给数据范围 [-10,000，10,000]。 思路 滑动窗口 1、维护一个长度为k的窗口，和窗口当前的和sum 2、遍历nums，每碰到一个新元素时，都要相应的从sum中减去退出窗口的值，加上新加入窗口的值 3、看看当然的sum是不是比以往的都大，是的话，记录到max里面去 4、最后返回max/k就好了 代码 package main import \"fmt\" func findMaxAverage(nums []int, k int) float64 { var sum, max int for i := 0; i \u003c k; i++ { sum += nums[i] } max = sum for i := k; i \u003c len(nums); i++ { sum += nums[i] - nums[i-k] if sum \u003e max { max = sum } } return float64(max) / float64(k) } func main() { nums := []int{1, 12, -5, -6, 50, 3} k := 4 result := findMaxAverage(nums, k) fmt.Print(result) } ","date":"5050-88-50","objectID":"/643%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/:0:0","tags":["leetcode"],"title":"643子数组最大平均数","uri":"/643%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/"},{"categories":["leetcode","数组"],"content":"1346. 检查整数及其两倍数是否存在 给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j 0 \u003c= i, j \u003c arr.length arr[i] == 2 * arr[j] 示例 1： 输入：arr = [10,2,5,3] 输出：true 解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。 示例 2： 输入：arr = [7,1,14,11] 输出：true 解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。 示例 3： 输入：arr = [3,1,7,11] 输出：false 解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。 提示： 2 \u003c= arr.length \u003c= 500 -10^3 \u003c= arr[i] \u003c= 10^3 ","date":"3030-88-47","objectID":"/1346%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/:0:0","tags":null,"title":"1346检查整数及其两倍数是否存在","uri":"/1346%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"},{"categories":["leetcode","数组"],"content":"605. 种花问题 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1 输出: True 示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2 输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 思路 遍历数组： （1）对第一个元素，本身是0右边是0即可种花 （2）对于中间元素，本身是0，左右两边都是0，可以种花 （3）对于最后一个元素，本身是0，左边是0，可以种花 代码 package main import \"fmt\" func canPlaceFlowers(flowerbed []int, n int) bool { length := len(flowerbed) var count int for i, value := range flowerbed { if value == 0 \u0026\u0026 (i == 0 || flowerbed[i-1] == 0) \u0026\u0026 (i == length-1 || flowerbed[i+1] == 0) { flowerbed[i] = 1 count += 1 } } return count \u003e= n } func main() { flowerbed := []int{1, 0, 0, 0, 1} n := 1 result := canPlaceFlowers(flowerbed, n) fmt.Print(result) } ","date":"3030-88-52","objectID":"/605%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"605种花问题","uri":"/605%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"},{"categories":["leetcode","数组"],"content":"167. 两数之和 II - 输入有序数组 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 思路 双指针 初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。 代码 package main import \"fmt\" func twoSum(numbers []int, target int) []int { length := len(numbers) var right int = length - 1 var left int = 0 for left \u003c right { sum := numbers[left] + numbers[right] if sum == target { break } else if sum \u003c target { left += 1 } else { right -= 1 } } return []int{left + 1, right + 1} } func main() { numbers := []int{2, 7, 11, 15} target := 9 result := twoSum(numbers, target) fmt.Print(result) } ","date":"3030-88-59","objectID":"/167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2/:0:0","tags":null,"title":"167两数之和2","uri":"/167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2/"},{"categories":["leetcode","数组"],"content":"118. 杨辉三角 给定一个非负整数 *numRows，*生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 思路 1.杨辉三角每层的i的值都是上层决定的m[i]+m[i+1]的和 2 第一个元素需要特殊处理一下，我们可以在每层头部增加一个数字是0的元素 ","date":"29290-77-20","objectID":"/118%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/:0:0","tags":null,"title":"118杨辉三角","uri":"/118%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"},{"categories":["leetcode","数组"],"content":"1160. 拼写单词 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。 注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。 返回词汇表 words 中你掌握的所有单词的 长度之和。 示例 1： 输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\" 输出：6 解释： 可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。 示例 2： 输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\" 输出：10 解释： 可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。 提示： 1 \u003c= words.length \u003c= 1000 1 \u003c= words[i].length, chars.length \u003c= 100 所有字符串中都仅包含小写英文字母 思路 对于一个单词 word，只要其中的每个字母的数量都不大于 chars 中对应的字母的数量，那么就可以用 chars 中的字母拼写出 word。 代码 func countCharacters(words []string, chars string) int { count := 0 for _, word := range words { flag := true for _, value := range word { if flag \u0026\u0026 strings.Count(word, string(value)) \u003e strings.Count(chars, string(value)) { flag = false } } if flag { count += len(word) } } return count } ","date":"28280-77-32","objectID":"/1160%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/:0:0","tags":null,"title":"1160拼写单词","uri":"/1160%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"},{"categories":["leetcode","数组"],"content":"674. 最长连续递增序列 给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。 示例 1: 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2: 输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 思路 滑动窗口... 代码 func findLengthOfLCIS(nums []int) int { length := len(nums) if length \u003c= 1 { return length } var count int = 1 var max_length int = 1 for index, value := range nums { if index == 0 { continue } if value \u003e nums[index-1] { count += 1 } else { index += 1 count = 1 } if max_length \u003c count { max_length = count } } return max_length } ","date":"28280-77-15","objectID":"/674%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/:0:0","tags":null,"title":"674最长连续递增序列","uri":"/674%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"},{"categories":["leetcode","数组"],"content":"剑指 Offer 53 - II. 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1: 输入: [0,1,3] 输出: 2 示例 2: 输入: [0,1,2,3,4,5,6,7,9] 输出: 8 限制： 1 \u003c= 数组长度 \u003c= 10000 解题思路 思路一：依次遍历 (1) 从头开始依次遍历数组每一位元素。 (2) 找到第一位值不等于索引的元素，则缺失值为当前索引。 代码 package main import \"fmt\" func missingNumber(nums []int) int { for index, value := range nums { if index == 0 { continue } if (value - nums[index-1]) \u003e 1 { return value - 1 } } return 0 } func main() { nums := []int{0, 1, 3} number := missingNumber(nums) fmt.Println(number) } 思路二：二分查找 (1) 根据二分查找找到第一个元素值不等于索引的索引就是缺失值。 (2) 元素值都和索引相等则缺失值等于数组长度。 class Solution { public int missingNumber(int[] nums) { // 定义左右指针分别指向数组元素值的边界。 int left = 0, right = nums.length; while (left \u003c right) { // 找到中间值。 int mid = left + (right - left) / 2; if (nums[mid] \u003e mid) { // 数组索引值与索引不对应，则缺失值在左侧。 right = mid; } else { // 数组索引值等于索引，则缺失值在右侧。 left = mid + 1; } } return right; } } ","date":"28280-77-06","objectID":"/offer530~n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":null,"title":"Offer53 0~n-1中缺失的数字","uri":"/offer530~n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["算法","桶排序"],"content":"介绍 ​ 桶排序（Bucket sort），是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 桶排序并不是比较排序，他不受到下限的影响。 步骤 桶排序以下列程序进行： 1.设置一个定量的数组当作空桶子。 2.寻访序列，并且把项目一个一个放到对应的桶子去。 3.对每个不是空的桶子进行排序。 4.从不是空的桶子里把项目再放回原来的序列中。 说明 假设有些整数，范围在1-100之间。现在有n=10的序列要进行排序 Original array +-------------------------------------------------+ | 6 | 28 | 96 | 14 | 74 | 37 | 9 | 71 | 91 | 36 | +-------------------------------------------------+ Create：创建一定数量的空桶，这里我们建立与原始数组长度相等的空桶（10个）。每个空桶对应区间为0~9、10~19、20~29、30~39、40~49、50~59、60~69、70~79、80~89、90-99的区间 Bucket array +-------------------------------------------------+ | | | | | | | | | | | +-------------------------------------------------+ ^ ^ | | | | | holds values in range 11 to 20 holds values in range 1 to 10 Scout：将原始序列中的元素，放入到对应的桶里 Bucket array 6,9 14 28 37,36 74,71 96,91 | | | | | | +-v----v----v----v-------------------v---------v--+ | | | | | | | | | | | +-------------------------------------------------+ Sort：排序所有非空桶中的元素，桶内排序可以采用任意排序算法 Bucket array sort sort sort sort sort sort --- -- -- ----- ----- ----- 6,9 14 28 36,37 71,74 91,96 | | | | | | +-v----v----v----v-------------------v---------v--+ | | | | | | | | | | | +-------------------------------------------------+ Gather：排序完成后，再把所有桶中元素依序放回原始序列 Original array +-------------------------------------------------+ | 6 | 9 | 14 | 28 | 36 | 37 | 71 | 74 | 91 | 96 | +-------------------------------------------------+ ","date":"26260-77-37","objectID":"/%E6%A1%B6%E6%8E%92%E5%BA%8F/:0:0","tags":["算法"],"title":"桶排序","uri":"/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["golang"],"content":"GoLand 2020版破解教程 本教程适用于GoLand 2020 1.4版本，其他版本理论上是一致的。 GoLand下载地址 下载地址 激活步骤 下载GoLand 下载破解补丁文件，jetbrains-agent-latest.zip破解补丁下载地址 安装GoLand，正常安装即可 进入激活界面，选择免费试用（Evaluate for free） 用GoLand随便打开一个已存在的项目（或者创建一个） 拖入zip文件 按箭头操作即可 查看是否激活成功 点击Help --\u003e About ","date":"25250-77-36","objectID":"/goland2020%E7%89%88%E7%A0%B4%E8%A7%A3/:0:0","tags":["go"],"title":"Goland 2020版破解","uri":"/goland2020%E7%89%88%E7%A0%B4%E8%A7%A3/"},{"categories":["leetcode","数组"],"content":"leetcode，1051 高度检查器","date":"24240-77-17","objectID":"/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/","tags":["leetcode"],"title":"1051 高度检查器","uri":"/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"},{"categories":["leetcode","数组"],"content":"1051. 高度检查器 ","date":"24240-77-17","objectID":"/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/:0:0","tags":["leetcode"],"title":"1051 高度检查器","uri":"/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"},{"categories":["leetcode","数组"],"content":"leetcode，1051 高度检查器","date":"24240-77-17","objectID":"/1051%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/","tags":["leetcode"],"title":"1051高度检查器","uri":"/1051%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"},{"categories":["leetcode","数组"],"content":"1051. 高度检查器 学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。 注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。 示例： 输入：heights = [1,1,4,2,1,3] 输出：3 解释： 当前数组：[1,1,4,2,1,3] 目标数组：[1,1,1,2,3,4] 在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。 在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。 在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。 示例 2：** 输入：heights = [5,1,2,3,4] 输出：5 示例 3： 输入：heights = [1,2,3,4,5] 输出：0 提示： 1 \u003c= heights.length \u003c= 100 1 \u003c= heights[i] \u003c= 100 解题思路 首先我们其实并不关心排序后得到的结果，我们想知道的只是在该位置上，与最小的值是否一致 1.先排序 2.然后遍历，比较对应下标的元素是否相同，不同加1 代码 package main import ( \"fmt\" \"sort\" ) func heightChecker(heights []int) int { length := len(heights) // todo: 切片和数组的本质区别是什么 // todo: 有上述疑问，是因为 var copy_heights []int 会报错！！ var copy_heights = make([]int, length) copy(copy_heights, heights) sort.Ints(heights) var count int for index, value := range heights { if copy_heights[index] != value { count += 1 } } return count } func main() { var heights = []int{5, 1, 2, 3, 4} count := heightChecker(heights) fmt.Println(count) } ","date":"24240-77-17","objectID":"/1051%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/:0:0","tags":["leetcode"],"title":"1051高度检查器","uri":"/1051%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"},{"categories":["leetcode","链表"],"content":"leetcode，Offer22 链表中倒数第K个节点","date":"22220-77-30","objectID":"/offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"Offer22 链表中倒数第K个节点","uri":"/offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 k = 2. 返回链表 4-\u003e5. 解题思路 1.快指针和慢指针相差k 2.快指针到达链尾，慢指针所指方向就是倒数第k个链表 代码 class Solution(object): def getKthFromEnd(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" fast = head for i in range(k): fast = fast.next cur = head while fast: cur = cur.next fast = fast.next return cur 解题思路 1.获取链表长度 2.开始遍历（链表长度-k）次数 代码 class Solution(object): def getKthFromEnd(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" length = 0 cur = head while cur: length += 1 cur = cur.next cur = head index = length - k for i in range(index): cur = cur.next return cur ","date":"22220-77-30","objectID":"/offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"Offer22 链表中倒数第K个节点","uri":"/offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，Offer22 链表中倒数第K个节点","date":"22220-77-30","objectID":"/offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"Offer22 链表中倒数第K个节点","uri":"/offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 k = 2. 返回链表 4-\u003e5. 解题思路 1.快指针和慢指针相差k 2.快指针到达链尾，慢指针所指方向就是倒数第k个链表 代码 class Solution(object): def getKthFromEnd(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" fast = head for i in range(k): fast = fast.next cur = head while fast: cur = cur.next fast = fast.next return cur 解题思路 1.获取链表长度 2.开始遍历（链表长度-k）次数 代码 class Solution(object): def getKthFromEnd(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" length = 0 cur = head while cur: length += 1 cur = cur.next cur = head index = length - k for i in range(index): cur = cur.next return cur ","date":"22220-77-30","objectID":"/offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"Offer22 链表中倒数第K个节点","uri":"/offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，141 环形链表","date":"22220-77-40","objectID":"/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"141环形链表","uri":"/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"141. 环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 思路 当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。 根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/22 22:19 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 141.py # @Software : PyCharm # -*- coding: utf-8 -*- # @Time : 2020/7/16 22:27 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 0201.py # @Software : PyCharm # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return False fast = head.next slow = head while fast != slow: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 3, 2, 1]) # traversal_link(head) solution = Solution() result = solution.hasCycle(head) traversal_link(result) ","date":"22220-77-40","objectID":"/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"141环形链表","uri":"/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"leetcode，141 环形链表","date":"22220-77-40","objectID":"/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"141环形链表","uri":"/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"141. 环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 思路 当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。 根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/22 22:19 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 141.py # @Software : PyCharm # -*- coding: utf-8 -*- # @Time : 2020/7/16 22:27 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 0201.py # @Software : PyCharm # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return False fast = head.next slow = head while fast != slow: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 3, 2, 1]) # traversal_link(head) solution = Solution() result = solution.hasCycle(head) traversal_link(result) ","date":"22220-77-40","objectID":"/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"141环形链表","uri":"/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["python"],"content":"python，Instagram在PyCon2017的演讲摘要","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"郑重声明：本篇文章非原创，摘自https://www.zlovezl.cn/articles/instagram-pycon-2017/ ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:0:0","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"PyCon 简介 PyCon 是全世界最大的以 Python 编程语言 为主题的技术大会。大会由 Python 社区组织，每年举办一次。在大会上，来自世界各地的 Python 用户与核心开发者齐聚一堂，共同分享 Python 世界的新鲜事、Python 语言的应用案例、使用技巧等等内容。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:1:0","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"Instagram 简介 Instagram 是一款移动端的照片与视频分享软件，由 Kevin Systrom 和 Mike Krieger 在 2010 年创办。Instagram 在发布后开始快速流行。于 2012 年被 Facebook 以 10 亿美元的价格收购。而当时 Instagram 的员工仅有区区 13 名。 如今，Instagram 的总注册用户达到 30 亿，月活用户超过 7 亿 （作为对比，微信最新披露的月活跃用户为 9.38 亿）。而令人吃惊的是，这么高的访问量背后，竟完全是由以速度慢著称的 Python + Django 支撑。 在 Python 2017 上，Instagram 的工程师们带来了一个有关 Python 在 Instagram 的主题演讲，同时还分享了 Instagram 如何将整个项目运行环境升级到 Python 3 的故事。 本文为该次演讲的内容摘要。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:2:0","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"Python @Instagram ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:3:0","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"为什么选择 Python 和 Django Instagram 选择 Django 的原因很简单，Instagram 的两位创始人 (Kevin Systrom and Mike Krieger) 都是产品经理出身。在他们想要创造 Instagram 时，Django 是他们所知道的最稳定和成熟的技术之一。 时至今日，即使已经拥有超过 30 亿的注册用户。Instagram 仍然是 Python 和 Django 的重度使用者。Instagram 的工程师 Hui Ding 说到： 『一直到用户 ID 已经超过了 32bit int 的限额（约为 20 亿），Django 本身仍然没有成为我们的瓶颈所在。』 不过，除了使用 Django 的原生功能外，Instagram 还对 Django 做了很多定制化工作： 扩展 Django Models 使其支持 Sharding （一种数据库分片技术），Instagram Engneering 博客专门为这件事情写过一篇博客，可参阅：Sharding \u0026 IDs at Instagram 手动关闭 GC（垃圾回收）来提升 Python 内存管理效率，他们同样也写过一篇博客来说明这件事情：Dismissing Python Garbage Collection at Instagram 在位于不同地理位置的多个数据中心部署整套系统 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:3:1","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"Python 语言的优势所在 Instagram 的联合创始人 Mike Krieger 说过： 『我们的用户根本不关心 Instagram 使用了哪种关系数据库，他们当然也不关心 Instagram 是用什么编程语言开发的。』 所以，Python 这种 简单 而且 实用至上 的编程语言最终赢得了 Instagram 的青睐。他们认为，使用 Python 这种简单的语言有助于塑造 Instagram 的工程师文化，那就是： 专注于定位问题、解决问题 - 而不是工具本身的各种花花绿绿的特性 使用那些经过市场验证过的成熟技术方案 - 而不用被工具本身的问题所烦扰 用户至上：专注于用户所能看到的新特性，为用户带去价值 但是，即使使用 Python 语言有这么多好处，它还是很慢，不是吗？ 不过，这对于 Instagram 不是问题，因为他们认为：『Instagram 的最大瓶颈在于开发效率，而不是代码的执行效率』 At Instagram, our bottleneck is development velocity, not pure code execution. 所以，最终的结论是：你完全可以使用 Python 语言来实现一个超过几十亿用户使用的产品，而根本不用担心语言或框架本身的性能瓶颈。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:3:2","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"如何提升运行效率 但是，即使是选用了拥有诸多好处的 Python 和 Django。在 Instagram 的用户数迅速增长的过程中，性能问题还是出现了：服务器数量的增长率已经慢慢的超过了用户增长率。Instagram 是怎么应对这个问题的呢？ 他们使用了这些手段来缓解性能问题： 开发工具来帮助调优：Instagram 开发了很多涵盖各个层面的工具，来帮助他们进行性能调优以及找到性能瓶颈。 使用 C/C++ 来重写部分组件：把那些稳定而且对性能最敏感的组件，使用 C 或 C++ 来重写，比如访问 memcache 的 library。 使用 Cython：Cython 也是他们用来提升 Python 效率的法宝之一。 除了上面这些手段，他们还在探索异步 IO 以及新的 Python Runtime 所能带来的性能可能性。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:3:3","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"升级到 Python 3 在相当长的一段时间，Instagram 都跑在 Python 2.7 + Django 1.3 的组合之上。在这个已经落后社区很多年的环境上，他们的工程师们还打了非常非常多的小 patch。难道他们要被永远卡在这个版本上吗？ 所以，在经过一系列的讨论后，他们最终做出一个重大的决定：升级到 Python 3！！ 事实上，Instagram 目前已经完成了将运行环境迁移到 Python 3 的工作 - 他们的整套服务已经在 Python 3 上跑了好几个月了。那么他们是怎么做到的呢？接下来便是由 Instagram 工程师 Lisa guo 带来的 Instagram 如何迁移到 Python 3 的故事。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:3:4","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"Instagram 升级到 Python 3 的故事 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:0","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"为什么要升级到 Python 3 对于 Instagram 来说，下面这些因素是推动他们将运行环境迁移到 Python 3 的主要原因： 1. 新特性：类型注解 Type Annotations 看看下面这段代码： def compose_from_max_id(max_id): '''@param str max_id''' 图中函数的 max_id 参数究竟是什么类型呢？int？tuple？或是 list? 等等，函数文档里面说它是 str 类型。 但随着时间推移，万一这个参数的类型发生变化了呢？如果某位粗心的工程师修改代码的同时忘了更新文档，那就会给函数的使用者带来很大麻烦，最终还不如没有注释呢。 2. 性能 Instagram 的整个 Django Stack 都跑在 uwsgi 之上，全部使用了同步的网络 IO。这意味着同一个 uwsgi 进程在同一时间只能接收并处理一个请求。这让如何调优每台机器上应该运行的 uwsgi 进程数成了一个麻烦事： 为了更好利用 CPU，使用更多的进程数？但那样会消耗大量的内存。而过少的进程数量又会导致 CPU 不能被充分利用。 为此，他们决定跳过 Python 2 中哪些蹩脚的异步 IO 实现 （可怜的 gevent、tornado、twisted 众），直接升级到 Python 3，去探索标准库中的 asyncio 模块所能带来的可能性。 3. 社区 因为 Python 社区已经停止了对 Python 2 的支持。如果把整个运行环境升级到 Python 3，Instagram 的工程师们就能和 Python 社区走的更近，可以更好的把他们的工作回馈给社区。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:1","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"确定迁移方案 在 Instagram，进行 Python 3 的迁移需要必须满足两个前提条件： 不停机，不能有任何的服务因此不可用 不能影响产品新特性的开发 但是，在 Instagram 的开发环境中，要满足上面这两点来完成迁移到 Python 3.6 这种庞大的工程是非常困难的。 基于主分支的开发流程 即便使用了以多分支功能著称的 git，Instagram 所有的开发工作都是主要在 master 分支上进行的，Instagram 所奉行的开发哲学是：『不管是多大的新特性或代码重构，都应该拆解成较小的 Commit 来进行。』 那些被合并进 master 分支的代码，都将在一个小时内被发布到线上环境。**而这样的发布过程每天将会发生上百次。**在这么频繁的发布频率下，如何在满足之前的那两个前提下来完成迁移变得尤其困难。 被弃用的迁移方案 创建一个新分支 很多人在处理这类问题时，第一个蹦进脑子的想法就是： 『让我们创建一个分支，当我们开发完后，再把分支合并进来』 但在 Instagram 这么高的迭代频率上，使用一个独立分支并不是好主意： Instagram 的 Codebase 每天都在频繁更新，在开发 Python 3 分支的过程中，让新分支与现有 master 分支保持同步开销极大，同时极易出错 最终将 Python 3 分支这个改动非常多的分支合并回 Master 拥有非常高的风险 只有少数几个工程师在 Python 3 分支上专职负责升级工作，其他想帮助迁移工作的工程师无法参与进来 挨个替换接口 还有一个方案就是，挨个替换 Instagram 的 API 接口。但是 Instagram 的不同接口共享着很多通用模块。这个方案要实施起来也非常困难。 微服务 还有一个方案就是将 Instagram 改造成微服务架构。通过将那些通用模块重写成 Python 3 版本的微服务来一步步完成迁移工作。 但是这个方案需要重新组织海量的代码。同时，当发生在进程内的函数调用变成 RPC 后 ，整个站点的延迟会变大。此外，更多的微服务也会引入更高的部署复杂度。 所以，既然 Instagram 的开发哲学是：小步前进，快速迭代。他们最终决定的方案是：一步一步来，最终让 master 分支上的代码同时兼容 Python 2 和 Python 3 。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:2","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"开始迁移工作 既然要让整个 codebase 同时兼容 Python 2 和 Python 3，那么首先要符合这点的就是那些被大量使用的第三方 package。针对第三方 package，Instagram 做到了下面几点： 拒绝引入所有不兼容 Python 3 的新 package 去掉所有不再使用的 package 替换那些不兼容 Python 3 的 package 在代码的迁移过程中，他们使用了工具 modernize 来帮助他们。 使用 modernize 时，有一个小技巧：每次修复多个文件的一个兼容问题，而不是一下修复一个文件中的多个兼容问题。 这样可以让 Code Review 过程简单很多，因为 Reviewer 每次只需要关注一个问题。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:3","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"使用单元测试来帮助迁移 对于 Python 这种灵活性极强的动态语言来说，除了真正去执行代码外，几乎没有其他比较好的检查代码错误的手段。 前面提到，Instagram 所有被合并到 master 的代码提交会在一个小时内上线到线上环境，但这不是没有前提条件的。在上线前，所有的提交都需要通过成千上万个单元测试。 于是，他们开始加入 Python 3 来执行所有的单元测试。一开始，只有极少数的单元测试能够在 Python 3 环境下通过，但随着 Instagram 的工程师们不断的修复那些失败的单元测试，最终所有的单元测试都可以在 Python 3 环境下成功执行。 单元测试的局限性 但是，单元测试也是有局限性的： Instagram 的单元测试没有做到 100% 的代码覆盖率 很多第三方模块都使用了 mock 技术，而 mock 的行为与真实的线上服务可能会有所不同 所以，当所有的单元测试都被修复后，他们开始在线上正式使用 Python 3 来运行服务。 这个过程并不是一蹴而就的。首先，所有的 Instagram 工程师开始访问到这些使用 Python 3 来执行的新服务，然后是 Facebook 的所有雇员，随后是 0.1%、20% 的用户，最终 Python 3 覆盖到了所有的 Instagram 用户。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:4","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"迁移过程的技术问题 Instagram 在迁移到 Python 3 时碰到很多问题，下面是最典型的几个： Unicode 相关的字符串问题 Python 3 相比 Python 2 最大的改动之一，就是在语言内部对 unicode 的处理。 在 Python 2 中，文本类型 （也就是 unicode） 和二进制类型 （也就是 str） 的边界非常模糊。很多函数的参数既可以是文本，也可以是二进制。但是在 Python 3 中，文本类型和二进制类型的字符串被完全的区分开了。 于是，下面这段在 Python 2 下可以正常运行的代码在 Python 3 下就会报错： mymac = hmac.new('abc') TypeError: key: expected bytes or bytearray, but got 'str' 解决办法其实很简单，只要加上判断：如果 value 是文本类型，就将其转换为二进制。如下所示： value = 'abc' if isinstance(value, six.text_type): value = value.encode(encoding='utf-8') mymac = hmac.new(value) 但是，在整个代码库中，像上面这样的情况非常多。作为开发人员，如果需要在调用每个函数时都要想想： 这里到底是应该编码成二进制，或者是解码成文本呢？ 将会是非常大的负担。 于是 Instagram 封装了一些名为 ensure_str()、ensure_binary()、ensure_text() 的帮助函数，开发人员只需对那些不确定类型的字符串，使用这些帮助函数先做一次转换就好。 mymac = hmac.new(ensure_binary('abc')) 不同 Python 版本的 pickle 差异 Instagram 的代码中大量使用了 pickle。比如用它序列化某个对象，然后将其存储在 memcache 中。如下面的代码所示： memcache_data = pickle.dumps(data, pickle.HIGHEST_PROTOCOL) data = pickle.loads(memcache_data) 问题在于，Python 2 与 Python 3 的 pickle 模块是有差别的。 如果上文的第一行代码，刚好是由 Python 3 运行的服务进行序列化后存入 memcache。而反序列化的过程却是由 Python 2 进行，那代码运行时就会出现下面的错误： ValueError: unsupported pickle protocol: 4 这是由于在 Python 3 中，pickle.HIGHEST_PROTOCOL 的值为 4，而 Python 2 中的的 pickle 最高支持的版本号却是 2。那么如何解决这个问题呢？ Instagram 最终选择让 Python 2 和 Python 3 使用完全不同的 namespace 来访问 memcache。通过将二者的数据读写完全隔开来解决这个问题。 迭代器 在 Python 3 中，很多内置函数被修改成了只返成迭代器 Iterator： map() filter() dict.items() 迭代器有诸多好处，最大的好处就是，使用迭代器不需要一次性分配大量内存，所以它的内存效率比较高。 但是迭代器有一个天然的特点，当你对某个迭代器做了一次迭代，访问完它的内容后，就没法再次访问那些内容了。迭代器中的所有内容都只能被访问一次。 在 Instagram 的 Python 3 迁移过程中，就因为迭代器的这个特性被坑了一次，看看下面这段代码： CYTHON_SOURCES = [a.pyx, b.pyx, c.pyx] builds = map(BuildProcess, CYTHON_SOURCES) while any(not build.done() for build in builds): pending = [build for build in builds if not build.started()] \u003cdo some work\u003e 这段代码的用处是挨个编译 Cython 源文件。当他们把运行环境切换到 Python 3 后，一个奇怪的问题出现了：**CYTHON_SOURCES 中的第一个文件永远都被跳过了编译。**为什么呢？ 这都是迭代器的锅。在 Python 3 中，map() 函数不再返回整个 list，而是返回一个迭代器。 于是，当第二行代码生成 builds 这个迭代器后，第三行代码的 while 循环迭代了 builds，刚好取出了第一个元素。于是之后的 pending 对象便里面永远少了那第一个元素。 这个问题解决起来也挺简单的，你只要手动的吧 builds 转换成 list 就可以了： builds = list(map(BuildProcess, CYTHON_SOURCES)) 但是这类 bug 非常难定位到。如果用户的 feeds 里面永远少了那最新的第一条，用户很少会注意到。 字典的顺序 看看下面这段代码： \u003e\u003e\u003e testdict = {'a': 1, 'b': 2, 'c': 3} \u003e\u003e\u003e json.dumps(testdict) 它会输出什么结果呢？ # Python2 '{\"a\": 1, \"c\": 3, \"b\": 2}' # Python 3.5.1 '{\"c\": 3, \"b\": 2, \"a\": 1}' # or '{\"c\": 3, \"a\": 1, \"b\": 2}' # Python 3.6 '{\"a\": 1, \"b\": 2, \"c\": 3}' 在不同的 Python 版本下，这个 json dumps 的结果是完全不一样的。甚至在 3.5.1 中，它会完全随机的返回两个不同的结果。Instagram 有一段判断配置文件是否发生变动的模块，就是因为这个原因出了问题。 这个问题的解决办法是，在调用 json.dumps 传入 sort_keys=True 参数： \u003e\u003e\u003e json.dumps(testdict, sort_keys=True) '{\"a\": 1, \"b\": 2, \"c\": 3}' ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:5","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"迁移到 Python 3.6 后的性能提升 当 Instagram 解决了这些奇奇怪怪的版本差异问题后，还有一个巨大的谜题困扰着他们：性能问题。 在 Instagram，他们使用两个主要指标来衡量他们的服务性能： 每次请求产生的 CPU 指令数（越低越好） 每秒能够处理的请求数（越高越好） 所以，当所有的迁移工作完成后，他们非常惊喜的发现：第一个性能指标，每次请求产生的 CPU 指令数居然足足下降了 12% ！！！ 但是，按理说第二个指标 - 每秒请求数也应该获得接近 12% 的提升。不过最后的变化却是 0%。究竟是出了什么问题呢？ 他们最终定位到，是由于不同 Python 版本下的内存优化配置不同，导致 CPU 指令数下降带来的性能提升被抵消了。那为什么不同 Python 版本下的内存优化配置会不一样呢？ 这是他们用来检查 uwsgi 配置的代码： if uwsgi.opt.get('optimize_mem', None) == 'True': optimize_mem() 注意到那段 ... ... == 'True' 了吗？在 Python 3 中，这个条件判断总是不会被满足。问题就在于 unicode。在将代码中的 'True' 换成 b'True'（也就是将文本类型换成二进制，这种判断在 Python 2 中完全不区分的）后，问题解决了。 所以，最终因为加上了一个小小的字母 ‘b’，程序的整体性能提升了 12%。 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:6","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"结论 在今年二月份，Instagram 的后端代码的运行环境完全切换到了 Python 3 下： 当所有的代码都都迁移到 Python 3 运行环境后： 节约了 12% 的整体 CPU 使用率（Django/uwsgi） 节约了 30% 的内存使用（celery） 同时，在整个迁移期间，Instagram 的月活用户经历了从 4 亿到 6亿 的巨大增长。产品也发布了评论过滤、直播等非常多新功能。 那么，那几个最开始驱动他们迁移到 Python 3 的目的呢？ 类型注解：Instagram 的整个 codebase 里已经有 2% 的代码添加上了类型注解，同时他们还开发了一些工具来辅助开发者添加类型提示 asyncio：他们在单个接口中利用 asynio 平行的去做多件事情，最终降低了 20-30% 的请求延迟。 社区：他们与 Intel 的工程师联合，帮助他们更好的对 CPU 利用率进行调优。同时还开发了很多新的工具，帮助他们进行性能调优 ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:4:7","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["python"],"content":"Instagram 带给我们的启示 Instagram 的演讲视频时间不长，但是内容很丰富，在编写此文前，我完全没有想到最终的文章会这么长。 那么，Instagram 的视频可以给我们哪些启示呢？ Python + Django 的组合完全可以负载用户数以 10 亿记的服务，如果你正准备开始一个项目，放心使用 Python 吧！ 完善的单元测试对于复杂项目是非常有必要的。如果没有那『成千上万的单元测试』。很难想象 Instagram 的迁移项目可以成功进行下去。 开发者和同事也是你的产品用户，利用好他们。用他们为你的新特性发布前多一道测试。 完全基于主分支的开发流程，可以给你更快的迭代速度。前提是拥有完善的单元测试和持续部署流程。 Python 3 是大势所趋，如果你正准备开始一个新项目，无需迟疑，拥抱 Python 3 吧！ ","date":"21210-77-37","objectID":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/:5:0","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["leetcode","链表"],"content":"leetcode，Offer18删除链表的节点","date":"20200-77-28","objectID":"/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"Offer18删除链表的节点","uri":"/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 18. 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 **注意：**此题对比原题有改动 示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 思路： 删除值为 val 的节点可分为两步：定位节点、修改引用。 定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。 修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。 算法流程： 1.特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。 2.初始化： pre = head , cur = head.next 。 3.定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。 4.保存当前节点索引，即 pre = cur 。 5.遍历下一节点，即 cur = cur.next 。 6.删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next 。（若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。 7.返回值： 返回链表头部节点 head 即可。 # -*- coding: utf-8 -*- # @Time : 2020/7/18 23:44 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : offer18.py # @Software : PyCharm class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def deleteNode(self, head, val): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" if head.val == val: return head.next pre, cur = head, head.next while cur and cur.val != val: pre, cur = cur, cur.next if cur: pre.next = cur.next return head def create_link(tmp): cur = head = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([4, 5, 1, 9]) traversal_link(head) ","date":"20200-77-28","objectID":"/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"Offer18删除链表的节点","uri":"/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，Offer18删除链表的节点","date":"20200-77-28","objectID":"/offer18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"Offer18删除链表的节点","uri":"/offer18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 18. 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 **注意：**此题对比原题有改动 示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 思路： 删除值为 val 的节点可分为两步：定位节点、修改引用。 定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。 修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。 算法流程： 1.特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。 2.初始化： pre = head , cur = head.next 。 3.定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。 4.保存当前节点索引，即 pre = cur 。 5.遍历下一节点，即 cur = cur.next 。 6.删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next 。（若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。 7.返回值： 返回链表头部节点 head 即可。 # -*- coding: utf-8 -*- # @Time : 2020/7/18 23:44 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : offer18.py # @Software : PyCharm class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def deleteNode(self, head, val): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" if head.val == val: return head.next pre, cur = head, head.next while cur and cur.val != val: pre, cur = cur, cur.next if cur: pre.next = cur.next return head def create_link(tmp): cur = head = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([4, 5, 1, 9]) traversal_link(head) ","date":"20200-77-28","objectID":"/offer18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"Offer18删除链表的节点","uri":"/offer18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，876 链表的中间结点","date":"16160-77-17","objectID":"/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/","tags":["leetcode"],"title":"876 链表的中间结点","uri":"/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 思路 方法一：数组 链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。 方法二：单指针法 我们可以对方法一进行空间优化，省去数组 A。 我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。 方法三：快慢指针法 我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/16 23:03 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 876.py # @Software : PyCharm # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def middleNode(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 4, 5]) solution = Solution() node = solution.middleNode(head) print(node.val) ","date":"16160-77-17","objectID":"/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/:0:0","tags":["leetcode"],"title":"876 链表的中间结点","uri":"/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，876 链表的中间结点","date":"16160-77-17","objectID":"/876%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/","tags":["leetcode"],"title":"876 链表的中间结点","uri":"/876%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 思路 方法一：数组 链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。 方法二：单指针法 我们可以对方法一进行空间优化，省去数组 A。 我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。 方法三：快慢指针法 我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/16 23:03 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 876.py # @Software : PyCharm # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def middleNode(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 4, 5]) solution = Solution() node = solution.middleNode(head) print(node.val) ","date":"16160-77-17","objectID":"/876%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/:0:0","tags":["leetcode"],"title":"876 链表的中间结点","uri":"/876%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，0201 移除重复节点","date":"16160-77-51","objectID":"/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"0201 移除重复节点","uri":"/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.01. 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2: 输入：[1, 1, 1, 1, 2] 输出：[1, 2] 提示： 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 进阶： 如果不得使用临时缓冲区，该怎么解决？ 思路 哈希 O(n) 哈希表存储出现过的元素，如果当前节点出现过，就删掉 我们从链表的头节点head 开始进行遍历，遍历的指针记为cur。由于头节点一定不会被删除，因此我们可以枚举待移除节点的前驱节点pre，减少编写代码的复杂度。 # -*- coding: utf-8 -*- # @Time : 2020/7/16 22:27 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 0201.py # @Software : PyCharm # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def removeDuplicateNodes(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return head tmp = {head.val} pre = head cur = pre.next while cur: if cur.val in tmp: pre.next = cur.next cur = cur.next else: tmp.add(cur.val) pre = pre.next cur = cur.next return head def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 3, 2, 1]) # traversal_link(head) solution = Solution() result = solution.removeDuplicateNodes(head) traversal_link(result) 双指针 固定p指针，右侧q指针扫描，然后移动p，指针q再次扫描 时间复杂度 O(n^2) # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def removeDuplicateNodes(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" p = head while p: q = p while q.next: if q.next.val == p.val: q.next = q.next.next else: q = q.next p = p.next return head def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 3, 2, 1]) # traversal_link(head) solution = Solution() result = solution.removeDuplicateNodes(head) traversal_link(result) ","date":"16160-77-51","objectID":"/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"0201 移除重复节点","uri":"/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，0201 移除重复节点","date":"16160-77-51","objectID":"/0201%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"0201 移除重复节点","uri":"/0201%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.01. 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2: 输入：[1, 1, 1, 1, 2] 输出：[1, 2] 提示： 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 进阶： 如果不得使用临时缓冲区，该怎么解决？ 思路 哈希 O(n) 哈希表存储出现过的元素，如果当前节点出现过，就删掉 我们从链表的头节点head 开始进行遍历，遍历的指针记为cur。由于头节点一定不会被删除，因此我们可以枚举待移除节点的前驱节点pre，减少编写代码的复杂度。 # -*- coding: utf-8 -*- # @Time : 2020/7/16 22:27 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 0201.py # @Software : PyCharm # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def removeDuplicateNodes(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return head tmp = {head.val} pre = head cur = pre.next while cur: if cur.val in tmp: pre.next = cur.next cur = cur.next else: tmp.add(cur.val) pre = pre.next cur = cur.next return head def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 3, 2, 1]) # traversal_link(head) solution = Solution() result = solution.removeDuplicateNodes(head) traversal_link(result) 双指针 固定p指针，右侧q指针扫描，然后移动p，指针q再次扫描 时间复杂度 O(n^2) # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def removeDuplicateNodes(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" p = head while p: q = p while q.next: if q.next.val == p.val: q.next = q.next.next else: q = q.next p = p.next return head def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 3, 2, 1]) # traversal_link(head) solution = Solution() result = solution.removeDuplicateNodes(head) traversal_link(result) ","date":"16160-77-51","objectID":"/0201%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"0201 移除重复节点","uri":"/0201%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，Offer24 反转链表","date":"16160-77-25","objectID":"/offer24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"Offer24 反转链表","uri":"/offer24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 24. 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL 输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL 限制： 0 \u003c= 节点个数 \u003c= 5000 思路 # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" cur = head pre = None while cur: after = cur.next cur.next = pre pre = cur cur = after return pre def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 4, 5]) # traversal_link(head) solution = Solution() cur = solution.reverseList(head) traversal_link(cur) ","date":"16160-77-25","objectID":"/offer24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"Offer24 反转链表","uri":"/offer24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"leetcode，Offer24 反转链表","date":"16160-77-25","objectID":"/offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"Offer24 反转链表","uri":"/offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 24. 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL 输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL 限制： 0 \u003c= 节点个数 \u003c= 5000 思路 # Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" cur = head pre = None while cur: after = cur.next cur.next = pre pre = cur cur = after return pre def create_link(tmp): head = None cur = None for i in tmp: node = ListNode(i) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): cur = head while cur: print(cur.val) cur = cur.next if __name__ == '__main__': head = create_link([1, 2, 3, 4, 5]) # traversal_link(head) solution = Solution() cur = solution.reverseList(head) traversal_link(cur) ","date":"16160-77-25","objectID":"/offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"Offer24 反转链表","uri":"/offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"leetcode，1290 二进制链表转整数","date":"15150-77-39","objectID":"/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/","tags":["leetcode"],"title":"1290 二进制链表转整数","uri":"/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode","链表"],"content":"1290. 二进制链表转整数 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1： 输入：head = [1,0,1] 输出：5 解释：二进制数 (101) 转化为十进制数 (5) 示例 2： 输入：head = [0] 输出：0 示例 3： 输入：head = [1] 输出：1 示例 4： 输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0] 输出：18880 示例 5： 输入：head = [0,0] 输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 思路 如果一个十进制的数字，999要和1拼接，需要999*10+1 = 999∗10+1=9991 如果一个二进制的数字，110要和1拼接，需要110*2+1 = 110∗2+1=1101 （注意按照二进制的方法计算） 代码 class Solution(object): def getDecimalValue(self, head): \"\"\" :type head: ListNode :rtype: int \"\"\" result = 0 while head: result = head.val + (result \u003c\u003c 1) head = head.next return result ","date":"15150-77-39","objectID":"/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/:0:0","tags":["leetcode"],"title":"1290 二进制链表转整数","uri":"/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode","链表"],"content":"leetcode，1290 二进制链表转整数","date":"15150-77-39","objectID":"/1290%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/","tags":["leetcode"],"title":"1290 二进制链表转整数","uri":"/1290%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode","链表"],"content":"1290. 二进制链表转整数 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1： 输入：head = [1,0,1] 输出：5 解释：二进制数 (101) 转化为十进制数 (5) 示例 2： 输入：head = [0] 输出：0 示例 3： 输入：head = [1] 输出：1 示例 4： 输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0] 输出：18880 示例 5： 输入：head = [0,0] 输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 思路 如果一个十进制的数字，999要和1拼接，需要999*10+1 = 999∗10+1=9991 如果一个二进制的数字，110要和1拼接，需要110*2+1 = 110∗2+1=1101 （注意按照二进制的方法计算） 代码 class Solution(object): def getDecimalValue(self, head): \"\"\" :type head: ListNode :rtype: int \"\"\" result = 0 while head: result = head.val + (result \u003c\u003c 1) head = head.next return result ","date":"15150-77-39","objectID":"/1290%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/:0:0","tags":["leetcode"],"title":"1290 二进制链表转整数","uri":"/1290%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode","链表"],"content":"leetcode，02.02. 返回倒数第 k 个节点","date":"15150-77-33","objectID":"/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"02.02. 返回倒数第 k 个节点","uri":"/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1-\u003e2-\u003e3-\u003e4-\u003e5 和 k = 2 输出： 4 说明： 给定的 k 保证是有效的。 思路 经典的快慢指针问题 反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。 设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点 class Solution(object): def kthToLast(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: int \"\"\" if head is None: return None left = head right = head count = 0 while count \u003c k: right = right.next count += 1 while right: left = left.next right = right.next return left.val ","date":"15150-77-33","objectID":"/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"02.02. 返回倒数第 k 个节点","uri":"/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，02.02. 返回倒数第 k 个节点","date":"15150-77-33","objectID":"/0202%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"02.02. 返回倒数第 k 个节点","uri":"/0202%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1-\u003e2-\u003e3-\u003e4-\u003e5 和 k = 2 输出： 4 说明： 给定的 k 保证是有效的。 思路 经典的快慢指针问题 反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。 设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点 class Solution(object): def kthToLast(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: int \"\"\" if head is None: return None left = head right = head count = 0 while count \u003c k: right = right.next count += 1 while right: left = left.next right = right.next return left.val ","date":"15150-77-33","objectID":"/0202%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"02.02. 返回倒数第 k 个节点","uri":"/0202%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，02.03. 删除中间节点","date":"15150-77-33","objectID":"/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例： 输入：单向链表a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef中的节点c 结果：不返回任何数据，但该链表变为a-\u003eb-\u003ed-\u003ee-\u003ef 代码 class Solution(object): def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node.val = node.next.val node.next = node.next.next ","date":"15150-77-33","objectID":"/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"解题思路 删除当前节点 必须知道prev节点， 这里只能访问当前节点，就只能先将next节点的值赋值给当前结点, 再把next节点干掉 ","date":"15150-77-33","objectID":"/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/:0:1","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，02.03. 删除中间节点","date":"15150-77-33","objectID":"/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例： 输入：单向链表a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef中的节点c 结果：不返回任何数据，但该链表变为a-\u003eb-\u003ed-\u003ee-\u003ef 代码 class Solution(object): def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node.val = node.next.val node.next = node.next.next ","date":"15150-77-33","objectID":"/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"解题思路 删除当前节点 必须知道prev节点， 这里只能访问当前节点，就只能先将next节点的值赋值给当前结点, 再把next节点干掉 ","date":"15150-77-33","objectID":"/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/:0:1","tags":["leetcode"],"title":"02.03. 删除中间节点","uri":"/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"leetcode，0206 回文链表","date":"15150-77-33","objectID":"/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"0206 回文链表","uri":"/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"面试题 02.06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/) 编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-\u003e2 输出： false 示例 2： 输入： 1-\u003e2-\u003e2-\u003e1 输出： true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 思路 1. 快慢指针遍历到链表中间，快指针走两步、慢指针走一步，最后慢指针的位置就是链表中间（画个示例图就知道了，虽然我这看的是该题的评论，不太明白，然后画了个图就了解了） 2. 从中间开始反转链表后半段 3. 从原链表头和反转后的链表头开始比较 value 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/15 21:27 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 0206.py # @Software : PyCharm class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def get_middle(self, head): \"\"\"用快慢指针获取中间节点\"\"\" left = right = head while right and right.next: left = left.next right = right.next.next return left def reverse_link(self, head): \"\"\"反转链表\"\"\" cur = head pre = None while cur: after = cur.next cur.next = pre pre = cur cur = after return pre def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if head is None: return True # 获取中间节点 middle_node = self.get_middle(head) # 反转链表 first = head second = self.reverse_link(middle_node) while second: if first.val != second.val: return False first = first.next second = second.next return True def create_link(tmp): head = None cur = head for val in tmp: node = ListNode(val) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): while head: print(head.val) head = head.next if __name__ == '__main__': head = create_link([1, 1, 1, 1]) # traversal_link(head) solution = Solution() result = solution.isPalindrome(head) print(result) ","date":"15150-77-33","objectID":"/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"0206 回文链表","uri":"/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"leetcode，0206 回文链表","date":"15150-77-33","objectID":"/0206%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"0206 回文链表","uri":"/0206%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"面试题 02.06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/) 编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-\u003e2 输出： false 示例 2： 输入： 1-\u003e2-\u003e2-\u003e1 输出： true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 思路 1. 快慢指针遍历到链表中间，快指针走两步、慢指针走一步，最后慢指针的位置就是链表中间（画个示例图就知道了，虽然我这看的是该题的评论，不太明白，然后画了个图就了解了） 2. 从中间开始反转链表后半段 3. 从原链表头和反转后的链表头开始比较 value 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/15 21:27 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 0206.py # @Software : PyCharm class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def get_middle(self, head): \"\"\"用快慢指针获取中间节点\"\"\" left = right = head while right and right.next: left = left.next right = right.next.next return left def reverse_link(self, head): \"\"\"反转链表\"\"\" cur = head pre = None while cur: after = cur.next cur.next = pre pre = cur cur = after return pre def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if head is None: return True # 获取中间节点 middle_node = self.get_middle(head) # 反转链表 first = head second = self.reverse_link(middle_node) while second: if first.val != second.val: return False first = first.next second = second.next return True def create_link(tmp): head = None cur = head for val in tmp: node = ListNode(val) if head is None: head = node cur = head else: cur.next = node cur = cur.next return head def traversal_link(head): while head: print(head.val) head = head.next if __name__ == '__main__': head = create_link([1, 1, 1, 1]) # traversal_link(head) solution = Solution() result = solution.isPalindrome(head) print(result) ","date":"15150-77-33","objectID":"/0206%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"0206 回文链表","uri":"/0206%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"leetcode，跳水板","date":"8080-77-37","objectID":"/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/","tags":["leetcode"],"title":"16.11 跳水板","uri":"/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"},{"categories":["leetcode"],"content":"你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。 返回的长度需要从小到大排列。 示例 输入： shorter = 1 longer = 2 k = 3 输出： {3,4,5,6} 提示： 0 \u003c shorter \u003c= longer 0 \u003c= k \u003c= 100000 代码 # -*- coding: utf-8 -*- # @Time : 2020/7/8 23:06 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 16.11跳水板.py # @Software : PyCharm class Solution: def divingBoard(self, shorter: int, longer: int, k: int): if k == 0: return [] elif shorter == longer: return [k * longer] min_length = shorter * k max_length = longer * k diff = longer - shorter result = [] for i in range(min_length, max_length, diff): result.append(i) result.append(max_length) return result if __name__ == '__main__': solution = Solution() result = solution.divingBoard(1, 3, 3) print(result) ","date":"8080-77-37","objectID":"/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/:0:0","tags":["leetcode"],"title":"16.11 跳水板","uri":"/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"},{"categories":["leetcode"],"content":"938 二叉搜索树的范围和， leetcode","date":"8080-77-37","objectID":"/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/","tags":["leetcode"],"title":"938 二叉搜索树的范围和","uri":"/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/"},{"categories":["leetcode"],"content":"给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 示例 1： 输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32 示例 2： 输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23 提示： 树中的结点数量最多为 10000 个。 最终的答案保证小于 2^31。 ","date":"8080-77-37","objectID":"/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/:0:0","tags":["leetcode"],"title":"938 二叉搜索树的范围和","uri":"/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/"},{"categories":["leetcode"],"content":"leetcode，25 K 个一组翻转链表","date":"2020-77-37","objectID":"/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"25 K 个一组翻转链表","uri":"/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":" 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 给你这个链表：1-\u003e2-\u003e3-\u003e4-\u003e5 当 k = 2 时，应当返回: 2-\u003e1-\u003e4-\u003e3-\u003e5 当 k = 3 时，应当返回: 3-\u003e2-\u003e1-\u003e4-\u003e5 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 迭代 class Solution: def reverseKGroup(self, head, k): cur = head if cur is None or cur.next is None: return cur tmp = list() while cur: tmp.append(cur) cur = cur.next pre = ListNode(None) cur = pre length = len(tmp) final_node = None if length % k \u003c k and length % k != 0: final_node = tmp[-(length % k)] for node_index in range(k - 1, length, k): for key in range(k): cur.next = tmp[node_index - key] cur = cur.next cur.next = final_node return pre.next ","date":"2020-77-37","objectID":"/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"25 K 个一组翻转链表","uri":"/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"leetcode，33 搜索旋转排序数组","date":"2020-77-37","objectID":"/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","tags":["leetcode"],"title":"33 搜索旋转排序数组","uri":"/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["leetcode"],"content":" 搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 解题思路： 题目要求 O(logN)O(logN) 的时间复杂度，基本可以断定本题是需要使用二分查找，怎么分是关键。 由于题目说数字了无重复，举个例子： 1 2 3 4 5 6 7 可以大致分为两类， 第一类 2 3 4 5 6 7 1 这种，也就是 nums[start] \u003c= nums[mid]。此例子中就是 2 \u003c= 5。 这种情况下，前半部分有序。因此如果 nums[start] \u003c=target\u003cnums[mid]，则在前半部分找，否则去后半部分找。 第二类 6 7 1 2 3 4 5 这种，也就是 nums[start] \u003e nums[mid]。此例子中就是 6 \u003e 2。 这种情况下，后半部分有序。因此如果 nums[mid] \u003ctarget\u003c=nums[end]，则在后半部分找，否则去前半部分找。 此题有个存在重复数字的变形题，可参考 此题解 。 代码： class Solution: def search(self, nums, target: int) -\u003e int: if not nums: return -1 if len(nums) == 1: if target in nums: return 0 else: return -1 length = len(nums) start = 0 end = length - 1 while start \u003c= end: mid = start + (end - start) // 2 if nums[mid] == target: return mid if nums[start] \u003c= nums[mid]: # 前半部分有序 if target \u003e= nums[start] and target \u003c nums[mid]: end = mid - 1 else: start = mid + 1 else: if target \u003c= nums[end] and target \u003e nums[mid]: start = mid + 1 else: end = mid - 1 return -1 ","date":"2020-77-37","objectID":"/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/:0:0","tags":["leetcode"],"title":"33 搜索旋转排序数组","uri":"/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["leetcode"],"content":"leetcode，39 组合综合","date":"2020-77-37","objectID":"/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/","tags":["leetcode"],"title":"39 组合综合","uri":"/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/"},{"categories":["leetcode"],"content":"给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 回溯法 class Solution: def combinationSum(self, candidates, target: int): if not candidates: return [] result = [] def isvalid(path, value, target): total = sum(path) + value if total \u003e target: return False return True def backtrack(path, candidates): if sum(path) == target: path = sorted(path) if path not in result: result.append(path) return None for value in candidates: if not isvalid(path, value, target): continue path.append(value) backtrack(path, candidates) path.pop() backtrack([], candidates) return result ","date":"2020-77-37","objectID":"/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/:0:0","tags":["leetcode"],"title":"39 组合综合","uri":"/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/"},{"categories":["leetcode"],"content":"leetcode，40 组合总和 II","date":"2020-77-37","objectID":"/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/","tags":["leetcode"],"title":"40 组合总和 II","uri":"/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/"},{"categories":["leetcode"],"content":"给定一个数组** candidates **和一个目标数** target **，找出** candidates **中所有可以使数字和为** target **的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 回溯法 class Solution: def combinationSum2(self, candidates, target: int): if not candidates: return [] def isvalid(path, value): if (sum(path) + value) \u003e target: return False return True def backtrack(path, rest): if sum(path) == target: path = sorted(path) if path not in result: result.append(path) return for index, value in enumerate(rest): if not isvalid(path, value): continue path.append(value) backtrack(path, rest[index + 1:]) path.pop() result = [] backtrack([], candidates) return result ","date":"2020-77-37","objectID":"/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/:0:0","tags":["leetcode"],"title":"40 组合总和 II","uri":"/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/"},{"categories":["leetcode"],"content":"leetcode，22 括号生成","date":"1010-77-37","objectID":"/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","tags":["leetcode"],"title":"22 括号生成","uri":"/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["leetcode"],"content":" 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] ## 回溯算法 from collections import Counter class Solution: def generateParenthesis(self, n: int): self.n = n # 结果 result = [] # 每次运行的 track = [] tmp = [] def backtrack(path, options): if len(path) == n * 2: tmp.append(path) result.append(''.join(path)) return for i in range(len(options)): if not self.isvalid(path, options[i]): continue path.append(options[i]) backtrack(path, options) path.pop() backtrack(track, ['(', ')']) return result def isvalid(self, path, next): if len(path) == 0 and next == ')': return False count_dict = Counter(path) left_value = count_dict['('] right_value = count_dict[')'] if next == ')' and right_value + 1 \u003e left_value: return False for key, value in count_dict.items(): if key == next and value == self.n: return False return True if __name__ == '__main__': solution = Solution() result = solution.generateParenthesis(3) print(result) ","date":"1010-77-37","objectID":"/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:0:0","tags":["leetcode"],"title":"22 括号生成","uri":"/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["leetcode"],"content":"leetcode，23 合并K个排序链表","date":"1010-77-37","objectID":"/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["leetcode"],"title":"23 合并K个排序链表","uri":"/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] 输出: 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6 暴力解法 遍历所有链表，将所有节点的值放到一个数组中。 将这个数组排序，然后遍历所有元素得到正确顺序的值。 用遍历得到的值，创建一个新的有序链表。 # -*- coding: utf-8 -*- # @Time : 2020/3/29 1:14 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 23.py # @Software : PyCharm # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def mergeKLists(self, lists): # head = ListNode(-1) result = [] for cur in lists: while cur: result.append(cur.val) cur = cur.next head = ListNode(-1) cur = head result.sort() for i in result: cur.next = ListNode(i) cur = cur.next return head.next if __name__ == '__main__': solution = Solution() head_1 = ListNode(1) node_2 = ListNode(4) node_4 = ListNode(5) head_1.next = node_2 node_2.next = node_4 head_2 = ListNode(1) node_3 = ListNode(3) node_4_copy = ListNode(4) head_2.next = node_3 node_3.next = node_4_copy head_3 = ListNode(2) node_6 = ListNode(6) head_3.next = node_6 tmp = [head_1, head_2, head_3] result = solution.mergeKLists(tmp) while result: print(result.val) result = result.next ","date":"1010-77-37","objectID":"/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["leetcode"],"title":"23 合并K个排序链表","uri":"/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"leetcode，24 两两交换链表中的节点","date":"1010-77-37","objectID":"/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","tags":["leetcode"],"title":"24 两两交换链表中的节点","uri":"/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode"],"content":" 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-\u003e2-\u003e3-\u003e4, 你应该返回 2-\u003e1-\u003e4-\u003e3. # -*- coding: utf-8 -*- # @Time : 2020/3/29 14:34 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 24.py # @Software : PyCharm class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def swapPairs(self, head): cur = head if cur is None or cur.next is None: return cur tmp = list() while cur: tmp.append(cur) cur = cur.next pre = ListNode(None) cur = pre length = len(tmp) final_node = None if length % 2 == 1: final_node = tmp[-1] for node_index in range(1, length, 2): cur.next = tmp[node_index] cur = cur.next cur.next = tmp[node_index - 1] cur = cur.next cur.next = final_node return pre.next if __name__ == '__main__': solution = Solution() head_1 = ListNode(1) node_2 = ListNode(2) node_3 = ListNode(3) node_4 = ListNode(4) head_1.next = node_2 node_2.next = node_3 node_3.next = node_4 result = solution.swapPairs(head_1) while result: print(result.val) result = result.next ","date":"1010-77-37","objectID":"/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:0:0","tags":["leetcode"],"title":"24 两两交换链表中的节点","uri":"/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode"],"content":"leetcode，41 缺失的第一个正数","date":"1010-77-37","objectID":"/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/","tags":["leetcode"],"title":"41 缺失的第一个正数","uri":"/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"},{"categories":["leetcode"],"content":"给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 提示： 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。 ","date":"1010-77-37","objectID":"/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/:0:0","tags":["leetcode"],"title":"41 缺失的第一个正数","uri":"/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"},{"categories":["leetcode"],"content":"leetcode，48 旋转图像","date":"1010-77-37","objectID":"/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","tags":["leetcode"],"title":"48 旋转图像","uri":"/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"},{"categories":["leetcode"],"content":"给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] ","date":"1010-77-37","objectID":"/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/:0:0","tags":["leetcode"],"title":"48 旋转图像","uri":"/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"},{"categories":["leetcode"],"content":"leetcode，54 螺旋矩阵","date":"1010-77-37","objectID":"/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/","tags":["leetcode"],"title":"54 螺旋矩阵","uri":"/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"categories":["leetcode"],"content":"给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解决方案 这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小 首先设定上下左右边界 其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界 判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案 若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理 不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案 class Solution: def spiralOrder(self, matrix): if not matrix: return matrix result = [] # 高 row_length = len(matrix) # 几列 col_length = len(matrix[0]) # 上边界 up = 0 # 下边界 down = row_length # 左边界 left = 0 # 右边界 right = col_length # 上下游标 row_cur = 0 # 左右游标 col_cur = 0 while True: # print(\"left = {}, right = {}, up = {}, down = {}\".format(left, right, up, down)) for col_cur in range(left, right): # print(\"1 {}\".format(matrix[row_cur][col_cur])) result.append(matrix[row_cur][col_cur]) # 更新上边界 up += 1 if up \u003e= down: break for row_cur in range(up, down): # print(\"2 {}\".format(matrix[row_cur][col_cur])) result.append(matrix[row_cur][col_cur]) # 更新右边界 right -= 1 if right \u003c= left: break for col_cur in range(right - 1, left - 1, -1): # print(\"3 {}\".format(matrix[row_cur][col_cur])) result.append(matrix[row_cur][col_cur]) # 更新下边界 down -= 1 if down \u003c= up: break for row_cur in range(down - 1, up - 1, -1): # print(\"4 {}\".format(matrix[row_cur][col_cur])) result.append(matrix[row_cur][col_cur]) # 更新左边界 left += 1 if left \u003e= right: break return result if __name__ == '__main__': solution = Solution() matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] result = solution.spiralOrder(matrix) print(result) ","date":"1010-77-37","objectID":"/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/:0:0","tags":["leetcode"],"title":"54 螺旋矩阵","uri":"/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"categories":["python","werkzeug"],"content":"Werkzeug是什么？ Werkzeug是一个基于WSGI的Web应用框架（说框架可能不合理，官方文档给出的是应用程序库）。想要了解更多请看官方文档 为什么要了解Werkzeug？ 因为目前所用的web框架为Flask，而Flask是以Werkzeug为基础的，所以绕不开Werkzeug了。 基础知识 WSGI Python 生成器 非常简单的网络知识 ","date":"23230-66-16","objectID":"/werkzeug_sc_1/:0:0","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(1)","uri":"/werkzeug_sc_1/"},{"categories":["python","werkzeug"],"content":"从哪开始呢？ 熟悉目录层级 参照Werkzeug官方文档给出的示例，重点关注Request,Response,run_simple from werkzeug.wrappers import Request, Response def application(environ, start_response): request = Request(environ) text = 'Hello %s!' % request.args.get('name', 'World') response = Response(text, mimetype='text/plain') return response(environ, start_response) \"\"\" 省略超多内容 \"\"\" class Shortly(object): def __init__(self, config): self.redis = redis.Redis(config['redis_host'], config['redis_port']) def dispatch_request(self, request): return Response('Hello World!') def wsgi_app(self, environ, start_response): request = Request(environ) response = self.dispatch_request(request) return response(environ, start_response) def __call__(self, environ, start_response): return self.wsgi_app(environ, start_response) def create_app(redis_host='localhost', redis_port=6379, with_static=True): app = Shortly({ 'redis_host': redis_host, 'redis_port': redis_port }) if with_static: app.wsgi_app = SharedDataMiddleware(app.wsgi_app, { '/static': os.path.join(os.path.dirname(__file__), 'static') }) return app if __name__ == '__main__': from werkzeug.serving import run_simple app = create_app() run_simple('127.0.0.1', 5000, app, use_debugger=True, use_reloader) Request、Response、run_simple（最不重要的） 之后的文章就重点关注以上三个，而且肯定会延伸到Werkzeug的其他地方（源码），不必担心，肯定会有所涉猎。 讲真，感觉run_simple可以不重点关注，希望不要打脸 ","date":"23230-66-16","objectID":"/werkzeug_sc_2/:0:0","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(2)","uri":"/werkzeug_sc_2/"},{"categories":["python","werkzeug"],"content":"Werkzeug Request 源码解析 代码示例： from werkzeug.wrappers import Request, Response def application(environ, start_response): request = Request(environ) text = 'Hello %s!' % request.args.get('name', 'World') response = Response(text, mimetype='text/plain') return response(environ, start_response) 请注意，之后Request和Response的相关源码都会围绕Werkzeug给出的以上代码讲解。 Request 类 ","date":"23230-66-16","objectID":"/werkzeug_sc_3/:0:0","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(3)","uri":"/werkzeug_sc_3/"},{"categories":["python","werkzeug"],"content":"文件定位 src/werkzeug/wrappers/request.py ","date":"23230-66-16","objectID":"/werkzeug_sc_3/:0:1","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(3)","uri":"/werkzeug_sc_3/"},{"categories":["python","werkzeug"],"content":"作用 根据Request类的名称其实就可以知道，Request类是处理请求的，实际上，通过阅读相关代码，Request类的作用确实如此 ","date":"23230-66-16","objectID":"/werkzeug_sc_3/:0:2","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(3)","uri":"/werkzeug_sc_3/"},{"categories":["python","werkzeug"],"content":"分析 class Request( BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin, CORSRequestMixin, CommonRequestDescriptorsMixin, ): \"\"\"Full featured request object implementing the following mixins: - :class:`AcceptMixin` for accept header parsing - :class:`ETagRequestMixin` for etag and cache control handling - :class:`UserAgentMixin` for user agent introspection - :class:`AuthorizationMixin` for http auth handling - :class:`~werkzeug.wrappers.cors.CORSRequestMixin` for Cross Origin Resource Sharing headers - :class:`CommonRequestDescriptorsMixin` for common headers \"\"\" ​ 根据注释可知，除了BaseRequest类之外，其他的Mixin类都是作为添加高级方法的类。而且Request类也没有初始化方法，所以可以将注意力从Request转移到BaseRequest类上面。 BaseRequest 类 截取以上代码示例的代码 request = Request(environ) 调用父类BaseRequest的__init__方法 def __init__(self, environ, populate_request=True, shallow=False): self.environ = environ if populate_request and not shallow: self.environ[\"werkzeug.request\"] = self self.shallow = shallow ","date":"23230-66-16","objectID":"/werkzeug_sc_3/:0:3","tags":["flask","python","werkzeug"],"title":"Werkzeug 源码解析(3)","uri":"/werkzeug_sc_3/"},{"categories":["leetcode"],"content":"leetcode，两数相加","date":"23230-66-37","objectID":"/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":["leetcode"],"title":"02 两数相加","uri":"/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4) 输出：7 -\u003e 0 -\u003e 8 原因：342 + 465 = 807 代码 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" list_1 = \"\" list_2 = \"\" if not l1 and not l2: return 0 while l1: list_1 += str(l1.val) l1 = l1.next num_1 = int(list_1[::-1]) if list_1 else 0 while l2: list_2 += str(l2.val) l2 = l2.next num_2 = int(list_2[::-1]) if list_2 else 0 sum = list(str(num_1 + num_2)[::-1]) head = ListNode(sum[0]) cur = head for i in range(1, len(sum)): cur.next = ListNode(sum[i]) cur = cur.next return head ","date":"23230-66-37","objectID":"/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:0:0","tags":["leetcode"],"title":"02 两数相加","uri":"/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"leetcode，无重复字符的最长子串","date":"23230-66-37","objectID":"/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["leetcode"],"title":"03 无重复字符的最长子串","uri":"/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["leetcode"],"content":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 解决方法（可以进行改进） 采用 滑动窗口 算法，详见html class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if not s: return 0 uq = set(s) uq_length = len(uq) windows = s[0] left = 0 right = 1 max_len = 1 for i in range(1, len(s)): flag_index = windows.find(s[i]) if flag_index == -1: windows += s[i] right += 1 else: left = flag_index + 1 right += 1 windows = windows[left:] + s[i] if max_len \u003c len(windows): max_len = len(windows) return max_len ","date":"23230-66-37","objectID":"/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:0:0","tags":["leetcode"],"title":"03 无重复字符的最长子串","uri":"/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["leetcode"],"content":"leetcode，04 寻找两个有序数组的中位数","date":"23230-66-37","objectID":"/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":["leetcode"],"title":"04 寻找两个有序数组的中位数","uri":"/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["leetcode"],"content":" 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" nums1.extend(nums2) nums1.sort() length = len(nums1) if length % 2 == 1: return float(nums1[length // 2]) else: return float(((nums1[length // 2] + nums1[length // 2 - 1])) / 2) ","date":"23230-66-37","objectID":"/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","tags":["leetcode"],"title":"04 寻找两个有序数组的中位数","uri":"/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["leetcode"],"content":"leetcode，05 马拉车算法","date":"23230-66-37","objectID":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/","tags":["leetcode"],"title":"05 马拉车算法","uri":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"},{"categories":["leetcode"],"content":"https://blog.csdn.net/liuwei0604/article/details/50414542 马拉车算法可以在线性时间复杂度内求出一个字符串的最长回文字串。其核心思想跟 KMP 相似，即反复利用已掌握的情况。 ","date":"23230-66-37","objectID":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/:0:0","tags":["leetcode"],"title":"05 马拉车算法","uri":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"},{"categories":["leetcode"],"content":"1.整体思路 这个算法的主要思路是维护一个跟原串 str 一样长的数组 lens。lens[i] 表示以 str[i] 为中点的回串其中一边的长度。这里有的人把中点算进去，有的人记录两边的长度，其实都一样，我这里是只记录一边的长度，不包括中点。比如 \"CDCDE\" str: [C, D, C, D, E] lens: [0, 1, 1, 0, 0] 那么 lens 里最大的自然就对应最长回串的中点了。所以这个算法的核心就是如何快速计算 lens。 ","date":"23230-66-37","objectID":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/:0:1","tags":["leetcode"],"title":"05 马拉车算法","uri":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"},{"categories":["leetcode"],"content":"2.预处理 回文有奇偶长度两种情况，通过补充间隔符可以将这两种情况化简为奇数长度。 比如 ABA 补充为 #A#B#A# 中点还是 B，ABBA 补充为 #A#B#B#A# 中点为 #，最后可以去掉。 算法用 JavaScript 写，我将原串转为数组，间隔符就用 null。 最后在两侧补上哨兵点方便遍历中止。我用了 NaN。所以看起来是这样 var arr = [NaN, null] for (let i = 0; i \u003c str.length; i += 1) { arr.push(str[i]) arr.push(null) } arr.push(NaN) ","date":"23230-66-37","objectID":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/:0:2","tags":["leetcode"],"title":"05 马拉车算法","uri":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"},{"categories":["leetcode"],"content":"3.详解 马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 首先我们解决下奇数和偶数的问题，在每个字符间插入 \"#\"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 \"^\" 和 \"$\"，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 首先我们解决下奇数和偶数的问题，在每个字符间插入 \"#\"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 \"^\" 和 \"$\"，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 \"#\" 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 \"#c#b#c#b#c#\"。而去掉 # 恢复到原来的字符串，变成 \"cbcbc\"，它的长度刚好也就是 5。 4.求原字符串下标 用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。 例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。 5.求每个 P [ i ] 接下来是算法的关键了，它充分利用了回文串的对称性。 我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。 让我们考虑求 P [ i ] 的时候，如下图。 用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。 但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。 (1)超出了R 当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。 (2) P [ i_mirror ] 遇到了原字符串的左边界 此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 \"#\" == \"#\"，之后遇到了 \"^\" 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。 (3)i 等于了 R 此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。 6.考虑 C 和 R 的更新 就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。 此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。 public String preProcess(String s) { int n = s.length(); if (n == 0) { return \"^$\"; } String ret = \"^\"; for (int i = 0; i \u003c n; i++) ret += \"#\" + s.charAt(i); ret += \"#$\"; return ret; } // 马拉车算法 public String longestPalindrome2(String s) { String T = preProcess(s); int n = T.length(); int[] P = new int[n]; int C = 0, R = 0; for (int i = 1; i \u003c n - 1; i++) { int i_mirror = 2 * C - i; if (R \u003e i) { P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R } else { P[i] = 0;// 等于 R 的情况 } // 碰到之前讲的三种情况时候，需要利用中心扩展法 while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) { P[i]++; } // 判断是否需要更新 R if (i + P[i] \u003e R) { C = i; R = i + P[i]; } } // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i = 1; i \u003c n - 1; i++) { if (P[i] \u003e maxLen) { maxLen = P[i]; centerIndex = i; } } int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标 return s.substring(start, start + maxLen); } class Solution: def longestPalindrome(self, s): format_s = self.pre_process(s) length = len(format_s) ps = [0] * length center = 0 right = 0 for current in range(1, length - 1): current_mirror = 2 * center - current if (current + ps[current_mirror]) \u003c right and (current_mirror - 1) != 0: ps[current] = ps[current_mirror] elif (current + ps[current_mirror]) \u003c right and (current_mirror - 1) == 0: i = 1 while (current - i) \u003e= 0 and (current + i) \u003c length and format_s[current - i] == format_s[current + i]: ps[current] += 1 i+=1 if ps[current] \u003c ps[current_mirror]: ps[current] = ps[current_mirror] else: i = 1 while (current - i) \u003e= 0 and (current + i) \u003c length and format_s[current - i] == format_s[ current + i]: ps[current] += 1 i += 1 if ps[current] + center \u003e right: center = current right = ps[current] + center max_length = 0 center_index = 0 for i in range(1, length -1): if ps[i] \u003e max_length: max_length = ps[i] center_index = i start = (center_index - max_length) // 2 return s[start:start + max_length] def pre_process(self, s): result = \"#\" for i in range(len(s)): result += s[i] result += '#' return result if __name__ == '__main__': solution = Solution() result = solution.longestPalindrome(\"ababcbab\") print(result","date":"23230-66-37","objectID":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/:0:3","tags":["leetcode"],"title":"05 马拉车算法","uri":"/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"},{"categories":["leetcode"],"content":"leetcode，06 Z 字形变换","date":"23230-66-37","objectID":"/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","tags":["leetcode"],"title":"06 Z 字形变换","uri":"/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"categories":["leetcode"],"content":"将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2: 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G ","date":"23230-66-37","objectID":"/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/:0:0","tags":["leetcode"],"title":"06 Z 字形变换","uri":"/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"categories":["leetcode"],"content":"题解 算法: 这个 Z 字型其实是这样的： 对于前面的 3行的 示例1 , 它的字符数分布是这样的： 对于前面的 4 行的 示例2 , 它的字符数分布是这样的： 那么对于 n 行的字符数分布是这样的： 如上图所示，我们可以发现： 1.当前行 curRow 为 0 或 n-1 时，箭头发生反向转折。 方法一： 从左到右按箭头方向迭代 s ，将每个字符添加到合适的行。之后从上到下遍历行即可。 我们假定 n=numRows : 代码如下 class Solution: def convert(self, s, numRows): length = len(s) row_num = numRows if length \u003c= row_num or row_num == 1: return s result = ['']*row_num turn = False current = 0 for c in s: result[current] += c if current == 0 or current == (row_num - 1): turn = not turn current += 1 if turn else -1 r = '' for s in result: r += s return r if __name__ == '__main__': solution = Solution() solution.convert('LEETCODEISHIRING', 3) 因为只需遍历一次，所以时间复杂度为 O(len(s))‘O(len(s))‘ ","date":"23230-66-37","objectID":"/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/:0:1","tags":["leetcode"],"title":"06 Z 字形变换","uri":"/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"categories":["leetcode"],"content":"leetcode，07 整数反转","date":"23230-66-37","objectID":"/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","tags":["leetcode"],"title":"07 整数反转","uri":"/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"categories":["leetcode"],"content":" 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 class Solution: def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" flag = True if x \u003c 0: flag = False tmp = str(x)[::-1] if flag else '-' + str(x)[1:][::-1] result = int(tmp) if result \u003c -2 ** 31 or result \u003e (2 ** 31 - 1): return 0 else: return result ","date":"23230-66-37","objectID":"/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/:0:0","tags":["leetcode"],"title":"07 整数反转","uri":"/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"categories":["leetcode"],"content":"leetcode，08 字符串转换整数","date":"23230-66-37","objectID":"/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/","tags":["leetcode"],"title":"08 字符串转换整数","uri":"/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"},{"categories":["leetcode"],"content":"请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 示例 1: 输入: \"42\" 输出: 42 示例 2: 输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−2^31) 。 class Solution: def myAtoi(self, str): fixed = str.strip() if not fixed: return 0 symbol = ['+', '-'] result = '' for i in range(0, len(fixed)): if fixed[i] == '+' and i == 0: continue elif (fixed[i] == '-' and i == 0) or fixed[i].isdigit(): result += fixed[i] else: break if not result or result == '-' or result == '+': return 0 int_max = 2 ** 31 - 1 int_min = -2 ** 31 if int(result) \u003e int_max: return int_max elif int(result) \u003c int_min: return int_min return int(result) if __name__ == '__main__': solution = Solution() result = solution.myAtoi(\" 0000000000012345678\") print(result) ","date":"23230-66-37","objectID":"/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/:0:0","tags":["leetcode"],"title":"08 字符串转换整数","uri":"/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"},{"categories":["leetcode"],"content":"leetcode，09 回文数","date":"23230-66-37","objectID":"/09-%E5%9B%9E%E6%96%87%E6%95%B0/","tags":["leetcode"],"title":"09 回文数","uri":"/09-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["leetcode"],"content":" 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ class Solution: def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" if str(x) == str(x)[::-1]: return True else: return False ","date":"23230-66-37","objectID":"/09-%E5%9B%9E%E6%96%87%E6%95%B0/:0:0","tags":["leetcode"],"title":"09 回文数","uri":"/09-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["leetcode"],"content":"leetcode，11 盛最多水的容器","date":"23230-66-37","objectID":"/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":["leetcode"],"title":"11 盛最多水的容器","uri":"/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["leetcode"],"content":" 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 class Solution: def maxArea(self, height): length = len(height) max = 0 left_index = 0 right_index = length - 1 while left_index \u003c right_index: area = min(height[left_index], height[right_index]) * (right_index - left_index) if max \u003c area: max = area if height[left_index] \u003c height[right_index]: while left_index \u003c right_index: if height[left_index] \u003c height[left_index + 1]: left_index = left_index + 1 break else: left_index = left_index + 1 else: right_index = right_index - 1 while right_index \u003c left_index: if height[right_index] \u003c height[right_index - 1]: right_index = right_index - 1 break else: right_index -= 1 return max \"\"\" 时间复杂度为O(n)， 空间复杂度为O(1) 思路：left、right游标分别从列表左右两端向中间靠拢 1、计算以left、right为左右游标的容量（取游标指向的值中较小的作为容器高度） 2、比较left、right两个游标指向值的大小，较小的往下一个位置移动， 否则随便选择一个游标下移，在本程序中固定选择右边的游标下移 3、重复步骤1 的计算，直到程序结束 \"\"\" class Solution: def maxArea(self, height: list) -\u003e int: max = 0 left = 0 right = len(height) - 1 while left \u003c right: l = left #暂存左边游标的位置 r = right #暂存右边游标的位置 if height[left] \u003c height[right]: h = height[left] left += 1 else: h = height[right] right -= 1 tmp = h * (r - l) #计算当前容器的容量 max = tmp if tmp \u003e max else max return max ","date":"23230-66-37","objectID":"/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/:0:0","tags":["leetcode"],"title":"11 盛最多水的容器","uri":"/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["leetcode"],"content":"leetcode，12 整数转罗马数","date":"23230-66-37","objectID":"/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/","tags":["leetcode"],"title":"12 整数转罗马数","uri":"/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/"},{"categories":["leetcode"],"content":"罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: \"III\" 示例 2: 输入: 4 输出: \"IV\" 示例 3: 输入: 9 输出: \"IX\" 示例 4: 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5： 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. class Solution: def intToRoman(self, num): # store = {'I': 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IV\": 4, \"IX\": 9, \"XL\": 40, \"XC\": 90, # \"CD\": 400, \"CM\": 900} store = {1: \"I\", 5: \"V\", 10: \"X\", 50: 'L', 100: 'C', 500: 'D', 1000: 'M', 4: 'IV', 9: 'IX', 40: 'XL', 90: 'XC', 400: 'CD', 900: 'CM'} # store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True)) store_list = sorted(store.keys(), reverse=True) print(store_list) result = [] index = 0 while True: for i in range(index, len(store_list)): value = store_list[i] if value \u003c= num: index = i tmp = store_list[index] num = num - tmp result.append(store[tmp]) break if num == 0: break return ''.join(result) ","date":"23230-66-37","objectID":"/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/:0:0","tags":["leetcode"],"title":"12 整数转罗马数","uri":"/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/"},{"categories":["leetcode"],"content":"leetcode，13 罗马数转整数","date":"23230-66-37","objectID":"/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/","tags":["leetcode"],"title":"13 罗马数转整数","uri":"/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode"],"content":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. # -*- coding: utf-8 -*- # @Time : 2018/12/2 16:48 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 13.py # @Software : PyCharm class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" # store = {1: \"I\", 5: \"V\", 10: \"X\", 50: 'L', 100: 'C', 500: 'D', 1000: 'M', 4: 'IV', 9: 'IX', 40: 'XL', 90: 'XC', # 400: 'CD', # 900: 'CM'} store = {'I': 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IV\": 4, \"IX\": 9, \"XL\": 40, \"XC\": 90, \"CD\": 400, \"CM\": 900} # store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True)) result = [] length = len(s) index = 0 while index \u003c length: if (index +1) \u003c length and (s[index] + s[index + 1]) in store.keys(): result.append(store[s[index] + s[index + 1]]) index += 2 else: result.append(store[s[index]]) index += 1 tmp = 0 for i in result: tmp += i return tmp if __name__ == '__main__': solution = Solution() # print(solution.romanToInt(\"III\")) print(solution.romanToInt(\"IV\")) ","date":"23230-66-37","objectID":"/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/:0:0","tags":["leetcode"],"title":"13 罗马数转整数","uri":"/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode"],"content":"leetcode，14 最长公共前缀","date":"23230-66-37","objectID":"/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","tags":["leetcode"],"title":"14 最长公共前缀","uri":"/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["leetcode"],"content":"编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 # -*- coding: utf-8 -*- # @Time : 2018/12/2 22:48 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 14.py # @Software : PyCharm class Solution: def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" length = len(strs) if length == 0 or (length == 1 and strs[0] == ''): return \"\" result = [] min_length = len(min(strs, key=len)) index = 0 while index \u003c min_length: flag = True all = None for value in strs: if all is None: all = value[index] continue if all == value[index]: continue else: flag = False break if not flag: break else: index += 1 result.append(all) return ''.join(result) if __name__ == '__main__': solution = Solution() # print(solution.longestCommonPrefix([\"flower\", \"flow\", \"flight\"])) print(solution.longestCommonPrefix([\"\", \"\"])) ","date":"23230-66-37","objectID":"/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:0:0","tags":["leetcode"],"title":"14 最长公共前缀","uri":"/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["leetcode"],"content":"leetcode，17 电话号码的字母组合","date":"23230-66-37","objectID":"/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","tags":["leetcode"],"title":"17 电话号码的字母组合","uri":"/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["leetcode"],"content":" 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 ","date":"23230-66-37","objectID":"/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:0:0","tags":["leetcode"],"title":"17 电话号码的字母组合","uri":"/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["leetcode"],"content":"示例: 输入：\"23\" 输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 方法：回溯 回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。 给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。 如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。 如果还有数字需要被输入： 遍历下一个数字所对应的所有映射的字母。 将当前的字母添加到组合最后，也就是 combination = combination + letter 。 重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。 问题转化成了从根节点到空节点一共有多少条路径； class Solution: def letterCombinations(self, digits: str): if len(digits) == 0: return [] number_al_dict = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } if len(digits) == 1: return [i for i in number_al_dict[digits[0]]] tmp = [] output = [] def backtrack(path, next_numbers): if len(next_numbers) == 0: tmp.append(path) output.append(\"\".join(path)) return for letter in number_al_dict[next_numbers[0]]: # if letter in path: # continue path.append(letter) backtrack(path, next_numbers[1:]) path.pop() backtrack([], digits) return output ","date":"23230-66-37","objectID":"/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:0:1","tags":["leetcode"],"title":"17 电话号码的字母组合","uri":"/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["leetcode"],"content":"leetcode，18 四数之和","date":"23230-66-37","objectID":"/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["leetcode"],"title":"18 四数之和","uri":"/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["leetcode"],"content":" 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 ### 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 解法1：回溯法 class Solution: def fourSum(self, nums, target: int): if len(nums) \u003c 4: return [] output = [] def backtrack(path, next): if len(path) == 4: output.append(sorted(path)) return for index, element in enumerate(next): path.append(element) backtrack(path, next[index + 1:]) path.pop() backtrack([], nums) result = [] for element in output: if sum(element) == target and element not in result: result.append(element) return result ","date":"23230-66-37","objectID":"/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["leetcode"],"title":"18 四数之和","uri":"/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["leetcode"],"content":"leetcode，21 合并两个有序列表","date":"23230-66-37","objectID":"/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/","tags":["leetcode"],"title":"21 合并两个有序列表","uri":"/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"},{"categories":["leetcode"],"content":"将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-\u003e2-\u003e4, 1-\u003e3-\u003e4 输出：1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4 方法 2：迭代 想法 我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。 算法 首先，我们设定一个哨兵节点 \"prehead\" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。 在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 # -*- coding: utf-8 -*- # @Time : 2020/3/27 23:37 # @Author : affectalways # @Site : # @Contact : affectalways@gmail.com # @File : 21_.py # @Software : PyCharm # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode): # head = ListNode(-1) head = ListNode(-1) cur = head while l1 and l2: if l1.val \u003c= l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 if l2 is None else l2 return head.next if __name__ == '__main__': solution = Solution() head_1 = ListNode(1) node_2 = ListNode(2) node_4 = ListNode(4) head_1.next = node_2 node_2.next = node_4 head_2 = ListNode(1) node_3 = ListNode(3) node_4_copy = ListNode(4) head_2.next = node_3 node_3.next = node_4_copy result = solution.mergeTwoLists(head_1, head_2) while result: print(result.val) result = result.next ","date":"23230-66-37","objectID":"/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/:0:0","tags":["leetcode"],"title":"21 合并两个有序列表","uri":"/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"},{"categories":["leetcode"],"content":"leetcode，31 下一个排列","date":"23230-66-37","objectID":"/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","tags":["leetcode"],"title":"31 下一个排列","uri":"/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["leetcode"],"content":" 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 “下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。 以 1,2,3,4,5,6 为例，其排列依次为： 123456 123465 123546 ... 654321 算法推导 如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析： 1.我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。 2.我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要： （1）在尽可能靠右的低位进行交换，需要从后向前查找 （2）将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换 （3）将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列 以上就是求“下一个排列”的分析过程。 算法过程 标准的“下一个排列”算法可以描述为： 1.从后向前查找第一个**==相邻升序==**的元素对 (i,j)，满足 A[i] \u003c A[j]。此时 [j,end) 必然是降序 2.在 [j,end) 从后向前查找第一个满足 A[i] \u003c A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」 3.将 A[i] 与 A[k] 交换 4.可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序 5.如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4 可视化 以求 12385764 的下一个排列为例： 首先从后向前查找第一个相邻升序的元素对 (i,j)。这里 i=4，j=5，对应的值为 5，7： 然后在 [j,end) 从后向前查找第一个大于 A[i] 的值 A[k]。这里 A[i] 是 5，故 A[k] 是 6： 将 A[i] 与 A[k] 交换。这里交换 5、6： 这时 [j,end) 必然是降序，逆置 [j,end)，使其升序。这里逆置 [7,5,4]： 因此，12385764 的下一个排列就是 12386457。 最后再可视化地对比一下这两个相邻的排列（橙色是蓝色的下一个排列）： class Solution: def nextPermutation(self, nums) -\u003e None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" length = len(nums) guard = -1 guard_index = length + 1 index = length - 1 while (index - 1) \u003e= 0: if nums[index - 1] \u003c nums[index]: guard = nums[index - 1] guard_index = index - 1 break index = index - 1 # print(\"guard_index = {}, guard = {}\".format(guard_index, guard)) if guard_index == (length + 1): return nums.sort(reverse=False) cur_index = length - 1 while cur_index \u003e guard_index: if nums[cur_index] \u003e guard: break cur_index -= 1 if cur_index \u003e= length: cur_index = index nums[cur_index], nums[guard_index] = nums[guard_index], nums[cur_index] for i in range(guard_index + 1, length - 1): for j in range(guard_index + 1, length - 1): if nums[j] \u003e nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] ","date":"23230-66-37","objectID":"/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/:0:0","tags":["leetcode"],"title":"31 下一个排列","uri":"/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["leetcode"],"content":"leetcode，55 跳跃游戏","date":"23230-66-37","objectID":"/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","tags":["leetcode"],"title":"55 跳跃游戏","uri":"/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"categories":["leetcode"],"content":"给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路： 如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。 如果可以一直跳到最后，就成功了。 class Solution: def canJump(self, nums) -\u003e bool: length = len(nums) k = 0 for i in range(length): if i \u003e k: return False k = max(k, k + nums[i]) return True ","date":"23230-66-37","objectID":"/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/:0:0","tags":["leetcode"],"title":"55 跳跃游戏","uri":"/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"categories":["leetcode"],"content":"leetcode，两数相加","date":"23230-66-37","objectID":"/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":["leetcode"],"title":"（2）两数相加","uri":"/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4) 输出：7 -\u003e 0 -\u003e 8 原因：342 + 465 = 807 代码 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" list_1 = \"\" list_2 = \"\" if not l1 and not l2: return 0 while l1: list_1 += str(l1.val) l1 = l1.next num_1 = int(list_1[::-1]) if list_1 else 0 while l2: list_2 += str(l2.val) l2 = l2.next num_2 = int(list_2[::-1]) if list_2 else 0 sum = list(str(num_1 + num_2)[::-1]) head = ListNode(sum[0]) cur = head for i in range(1, len(sum)): cur.next = ListNode(sum[i]) cur = cur.next return head ","date":"23230-66-37","objectID":"/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:0:0","tags":["leetcode"],"title":"（2）两数相加","uri":"/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"leetcode，01 两数之和相加","date":"22220-66-44","objectID":"/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/","tags":["leetcode"],"title":"01 两数之和相加","uri":"/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解法一 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if not len(nums): return [] for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j] 解法二 利用Python创建字典（即hash），同时有效避免了key相同的情况 class Solution: def twoSum(self, nums, target): dic = {} for i in range(len(nums)): if str(target - nums[i]) in dic: return [dic[str(target - nums[i])], i] dic[str(nums[i])] = i ","date":"22220-66-44","objectID":"/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/:0:0","tags":["leetcode"],"title":"01 两数之和相加","uri":"/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"leetcode，01 两数之和相加","date":"22220-66-44","objectID":"/01%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/","tags":["leetcode"],"title":"01 两数之和相加","uri":"/01%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解法一 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if not len(nums): return [] for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j] 解法二 利用Python创建字典（即hash），同时有效避免了key相同的情况 class Solution: def twoSum(self, nums, target): dic = {} for i in range(len(nums)): if str(target - nums[i]) in dic: return [dic[str(target - nums[i])], i] dic[str(nums[i])] = i ","date":"22220-66-44","objectID":"/01%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/:0:0","tags":["leetcode"],"title":"01 两数之和相加","uri":"/01%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"leetcode，两数之和相加","date":"22220-66-44","objectID":"/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/","tags":["leetcode"],"title":"（1）两数之和相加","uri":"/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["leetcode"],"content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解法一 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if not len(nums): return [] for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j] 解法二 利用Python创建字典（即hash），同时有效避免了key相同的情况 class Solution: def twoSum(self, nums, target): dic = {} for i in range(len(nums)): if str(target - nums[i]) in dic: return [dic[str(target - nums[i])], i] dic[str(nums[i])] = i ","date":"22220-66-44","objectID":"/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/:0:0","tags":["leetcode"],"title":"（1）两数之和相加","uri":"/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/"},{"categories":["python","WSGI"],"content":"WSGI 是个什么东西？ 实际的生产环境中，Python应用程序是放在服务器的http server（比如Apache、Nginx等）上的。现在的问题是http server（之后以服务器代称）怎么把接收到的请求传递给Python应用程序？这就是WSGI做的事情。 WSGI（Web Server Gateway Interface）即Web服务器网关接口，解耦了服务器（Apache、Nginx等）和Python应用程序，是Python开发者只需要关注Python应用程序的开发。 Web Server：即HTTP Server，接收用户的请求并返回响应信息；分为以下两部分： 服务器，如Apache、Nginx等 Python应用程序，负责处理业务逻辑 ","date":"20200-66-01","objectID":"/wsgi_kl_1/:1:0","tags":["flask","python","wsgi"],"title":"WSGI 理解（1）","uri":"/wsgi_kl_1/"},{"categories":["python","WSGI"],"content":"HTTP Server 实现 服务器每接收到一个请求就调用一次Python Application。服务器作用如下 接收HTTP请求 提供environ和回调函数start_response，并传给callable object 调用callable object 以下是PEP-3333提供的示例 import os, sys enc, esc = sys.getfilesystemencoding(), 'surrogateescape' def unicode_to_wsgi(u): # Convert an environment variable to a WSGI \"bytes-as-unicode\" string return u.encode(enc, esc).decode('iso-8859-1') def wsgi_to_bytes(s): return s.encode('iso-8859-1') def run_with_cgi(application): \"\"\" application: 是Python Application中的callable object \"\"\" # 构造environ变量，dict类型，里面的内容是一次HTTP请求的环境变量 environ = {k: unicode_to_wsgi(v) for k,v in os.environ.items()} environ['wsgi.input'] = sys.stdin.buffer environ['wsgi.errors'] = sys.stderr environ['wsgi.version'] = (1, 0) environ['wsgi.multithread'] = False environ['wsgi.multiprocess'] = True environ['wsgi.run_once'] = True if environ.get('HTTPS', 'off') in ('on', '1'): environ['wsgi.url_scheme'] = 'https' else: environ['wsgi.url_scheme'] = 'http' headers_set = [] headers_sent = [] # 把响应信息写到终端 def write(data): out = sys.stdout.buffer if not headers_set: raise AssertionError(\"write() before start_response()\") elif not headers_sent: # Before the first output, send the stored headers status, response_headers = headers_sent[:] = headers_set out.write(wsgi_to_bytes('Status: %s\\r\\n' % status)) for header in response_headers: out.write(wsgi_to_bytes('%s: %s\\r\\n' % header)) out.write(wsgi_to_bytes('\\r\\n')) out.write(data) out.flush() # 定义start_response回调函数 def start_response(status, response_headers, exc_info=None): if exc_info: try: if headers_sent: # Re-raise original exception if headers sent raise exc_info[1].with_traceback(exc_info[2]) finally: exc_info = None # avoid dangling circular ref elif headers_set: raise AssertionError(\"Headers already set!\") headers_set[:] = [status, response_headers] # Note: error checking on the headers should happen here, # *after* the headers are set. That way, if an error # occurs, start_response can only be re-called with # exc_info set. return write result = application(environ, start_response) try: # 处理application返回的结果（可迭代） for data in result: if data: # don't send headers until body appears write(data) if not headers_sent: write('') # send headers now if body was empty finally: if hasattr(result, 'close'): result.close() ","date":"20200-66-01","objectID":"/wsgi_kl_1/:2:0","tags":["flask","python","wsgi"],"title":"WSGI 理解（1）","uri":"/wsgi_kl_1/"},{"categories":["python","WSGI"],"content":"中间件Middleware Middlerware是位于Http Server和Python Application之间的功能组件。 对于Http Server而言，Middlerware就是应用程序；对于Python Application而言，Middlerware就是Http Server。Middleware对Http Server和Python Application是透明的，把从Http Server接收到的请求进行处理并向后传递，一直传递给Python Application，最后把Python Application的处理结果返回给Http Server。如下图： Middlerware组件可执行以下功能： 根据 url 把用户请求调度到不同的 Python Application 中。 负载均衡，转发用户请求 预处理 XSL 等相关数据 限制请求速率，设置白名单 PS：WSGI 的 middleware 体现了 unix 的哲学之一：do one thing and do it well。 本例实现了一个关于异常处理的 middleware（摘自）： from sys import exc_info from traceback import format_tb class ExceptionMiddleware(object): \"\"\"The middleware we use.\"\"\" def __init__(self, app): self.app = app def __call__(self, environ, start_response): \"\"\"Call the application can catch exceptions.\"\"\" appiter = None # just call the application and send the output back # unchanged but catch exceptions try: appiter = self.app(environ, start_response) for item in appiter: yield item # if an exception occours we get the exception information # and prepare a traceback we can render except: e_type, e_value, tb = exc_info() traceback = ['Traceback (most recent call last):'] traceback += format_tb(tb) traceback.append('%s: %s' % (e_type.__name__, e_value)) # we might have not a stated response by now. try # to start one with the status code 500 or ignore an # raised exception if the application already started one. try: start_response('500 INTERNAL SERVER ERROR', [ ('Content-Type', 'text/plain')]) except: pass yield '\\n'.join(traceback) # wsgi applications might have a close function. If it exists # it *must* be called. if hasattr(appiter, 'close'): appiter.close() ","date":"20200-66-01","objectID":"/wsgi_kl_1/:3:0","tags":["flask","python","wsgi"],"title":"WSGI 理解（1）","uri":"/wsgi_kl_1/"},{"categories":["python","WSGI"],"content":"Python Application Python Application端必须定义一个 callable object，callable object 可以是以下三者之一： function/method class instance with a __call__ method callable object必须满足以下两个条件： 接收两个参数：environ（字典，WSGI的环境信息）、start_response（响应请求的函数, 返回HTTP status、headers给server） 返回一个可迭代的值（iterable） 重点内容： environ和start_response由http server提供并实现 environ变量是包含环境变量的字典 Python Application内部在返回前调用start_response start_response也是一个callable，接收两个必要的参数，status和response_headers callable object代码实现 1.function/method def application(environ, start_response): # 调用服务器程序提供的 start_response，填入两个参数 start_response('200 OK', [('Content-Type', 'text/json')]) return [] 2.class class ApplicationClass(object): def __init__(self, environ, start_response): self.environ = environ self.start_response = start_response def __iter__(self): self.start_response('200 OK', [('Content-Type', 'text/json')]) yield \"随便\" 使用方式 for result in ApplicationClass(environ, start_response): do_somthing(result) 3.instance with a call method class ApplicationClass(object): def __init__(self): pass def __call__(self, environ, start_response): start_response('200 OK', [('Content-Type', 'text/json')]) yield \"anything\" 使用方式 app = ApplicationClass() for result in app(environ, start_response): do_something(result) ","date":"20200-66-01","objectID":"/wsgi_kl_1/:4:0","tags":["flask","python","wsgi"],"title":"WSGI 理解（1）","uri":"/wsgi_kl_1/"},{"categories":["python","WSGI"],"content":"参考链接 PEP-3333 巨佬 ","date":"20200-66-01","objectID":"/wsgi_kl_1/:4:1","tags":["flask","python","wsgi"],"title":"WSGI 理解（1）","uri":"/wsgi_kl_1/"},{"categories":["blog","hugo"],"content":"Hugo 添加评论功能","date":"17170-66-44","objectID":"/hugo_comment/","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"不能评论! Hugo 是一个强大的静态网页生成器，使用 go 开发，速度贼快。不过 Hugo 还比较年轻，没有像 NexT 那样功能强大，成熟稳定的主题。所以很多东西需要自己动手撸。 比如评论系统。 评论系统排名 valine \u003e gitalk \u003e gitment \u003e livere \u003e 畅言 ","date":"17170-66-44","objectID":"/hugo_comment/:0:0","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"关于Valine 官方网址： «https://valine.js.org/\u003e\u003e 其特性不一一赘述，官方网址有介绍 ","date":"17170-66-44","objectID":"/hugo_comment/:1:0","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"添加评论区 目前博客使用的主题是meme 不同的主题可能有所区别，但原理大都类似 ","date":"17170-66-44","objectID":"/hugo_comment/:2:0","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"原理？ Hugo 会将 Markdown 文档 按照 主题 (包括 HTML 模板、CSS、JavaScript 等) 编译成静态网页 那么我们只需要将 Valine作为一个 \u003cdiv\u003e 插入到 HTML 模板中，然后在 config.toml 中添加相关配置，就可以添加评论区了 ","date":"17170-66-44","objectID":"/hugo_comment/:2:1","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"Leancloud相关配置 评论系统依赖于leancloud，所以需要先在leancloud中进行相关的准备工作。 登录 或 注册 LeanCloud 登录成功后，进入后台点击左上角的创建应用： 创建好应用，进入应用，左边栏找到 设置 ，然后点击 应用Key，此时记录出现的 App ID 和 App Key，后面配置文件中会用到： 因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 Class，左边栏找到并点击 存储，点击 创建Class: 创建两个存储Class，分别命名为: Counter 和 Comment; 还需要为应用添加安全域名，左边栏点击 设置，找到 安全中心，点击后会看到 安全域名 设置框，输入博客使用的域名，点击保存即可： ","date":"17170-66-44","objectID":"/hugo_comment/:3:0","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"config.toml开启comment 将enableComments = false设置为enableComments = true 将enableValine = false设置为enableValine = true 添加 Valine 参数项： ## Valine enableValine = true valineAppId = \"************\" valineAppKey = \"*****************\" valinePlaceholder = \"Just go go\" valinePath = \"\" valineAvatar = \"mm\" valineMeta = [\"nick\", \"mail\", \"link\"] valinePageSize = 10 valineLang = \"zh-cn\" valineVisitor = false valineHighlight = true valineAvatarForce = false valineRecordIP = false valineServerURLs = \"\" valineEmojiCDN = \"\" valineEmojiMaps = {} valineEnableQQ = false valineRequiredFields = [] 上面几项内容的含义，这里简单一说，具体还是要看 Valine官网中配置相关的内容： 参数 用途 enable 这是用于主题中配置的，不是官方Valine的参数，true时控制开启此评论系统 appId 这是在 leancloud 后台应用中获取的，也就是上面提到的 App ID appKey 这是在 leancloud 后台应用中获取的，也就是上面提到的 App Key notify 用于控制是否开启邮件通知功能，具体参考邮件提醒配置 verify 用于控制是否开启评论验证码功能 avatar 用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：头像配置 placehoder 评论框的提示符 visitor 控制是否开启文章阅读数的统计功能i, 详情阅读文章阅读数统计 ","date":"17170-66-44","objectID":"/hugo_comment/:3:1","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"修改主题文件 主要是修改主题中评论相关的布局文件 themes\\meme\\layouts\\partials\\components\\comments.html，按照 Valine快速开始 添加 Valine 相关代码，找到以下位置 {{ if .Site.Params.enableValine }} {{- end }} 添加的 Valine 评论的代码如下： {{ if .Site.Params.enableValine }} \u003cdiv id=\"vcomments\"\u003e\u003c/div\u003e \u003cscript src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"\u003e\u003c/script\u003e \u003cscript src='//unpkg.com/valine/dist/Valine.min.js'\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e new Valine({ el: '#vcomments' , appId: '{{ .Site.Params.valineAppId }}', appKey: '{{ .Site.Params.valineAppKey }}', notify: '{{ .Site.Params.valineNotify }}', verify: '{{ .Site.Params.valineVerify }}', avatar:'{{ .Site.Params.valineAvatar }}', placeholder: '{{ .Site.Params.valinePlaceholder }}', visitor: '{{ .Site.Params.valineVisitor }}' }); \u003c/script\u003e {{ end }} 可以看到上述代码中引用了配置文件中的相关参数，这样以后修改配置就不用修改代码了，只需要改配置文件 config.toml。 ","date":"17170-66-44","objectID":"/hugo_comment/:3:2","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/hugo_comment/"},{"categories":["blog","hugo"],"content":"Hugo 让 GitHub Pages被索引到","date":"17170-66-29","objectID":"/hugo_seo/","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/hugo_seo/"},{"categories":["blog","hugo"],"content":"居然都找不到！ 其实Blog我主要是用来做一些记录，突然看到有博客提到GitHub Pages屏蔽了百度的爬虫，所以百度是搜索不到GitHub Pages上的网页的。 什么？所以百度搜索搜不到我的个人博客？不死心，尝试一下，找得到github、gist主页，但是就是找不到github.io后缀的网页。除了百度之外，我还尝试了Bing、Google，都没有。 ","date":"17170-66-29","objectID":"/hugo_seo/:1:0","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/hugo_seo/"},{"categories":["blog","hugo"],"content":"如何让搜索引擎索引到呢？ 发现流行的搜索引擎居然都找不到博客，那就需要赶紧找解决方法。Google和Bing还不清楚是怎么回事，但网上流传的email回复内容都点明了Github Pages禁止了百度爬虫的爬去，似乎原因是百度爬虫爬得太过于频繁，会严重影响服务器性能。针对百度爬虫的问题，大家找了很多方法。自建服务器托管博客、将博客放在Gitlab上或者CDN方法都不在我的选择范围内，因为暂时我还没有购买服务器或者域名的打算，所以决定放弃百度……但不管怎么样Bing和Google还是要设置好的！ ","date":"17170-66-29","objectID":"/hugo_seo/:2:0","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/hugo_seo/"},{"categories":["blog","hugo"],"content":"Google 添加资源 在google搜索页面输入“site:affectalways.github.io”就可以看到这个网页是否被google索引到，如果没被索引到，在搜索结果页面就会直接提示你使用Google Search Console。登录后，如果是首次使用在Search Console中以下界面中选择“网页”类型资源，并将博客完整url填入其中，我填入“https://affectalways.github.io”。注意http或者https，www等最好能完全正确。 如果已经添加过资源，则需要点击左上角的按钮，然后和上面一样地添加资源即可。 资源添加后，需要验证你对该网站有所有权。Google提供了几种方法，我选择了三种方式： HTML验证文件上传 只需要根据要求，下载HTML验证文件，把文件放在站点根目录的static目录下（以本网站为例：affectalways/static） HTML标记 config.toml中的googleSiteVerification = \"\" 设置为 googleSiteVerification = 不为空 找到themes/meme/layouts/partials/head.html中的 {{- with .Site.Params.googleSiteVerification }} \u003cmeta name=\"google-site-verification\" content=\"\" /\u003e {{- end }} 把content内容改为给定的内容，然后执行hugo命令，就可以验证了 Google Analytics 先到Google Analytics创建一个账号，并登录。 新建一个资源，填完后获得tracking code。 更新config.toml文件，把enableGoogleAnalytics设为true，trackingCodeType设为gtag（两个选择gtag和analytics，因为affectalways.github.io使用的是Google Analytics给定的gtag.js，所以设置为gtag），trackingID设为获取到的tracking code。然后执行hugo命令，就可以验证了。 站点地图 在左侧点击“站点地图”，并在右侧点添加/测试站点地图，并添加url，我的是https://affectalways.github.io/sitemap.xml ","date":"17170-66-29","objectID":"/hugo_seo/:2:1","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/hugo_seo/"},{"categories":["blog","hugo"],"content":"Bing 相似地，在Bing网站管理登陆、添加网站url。 然后在左侧点击“配置我的网站\u003eSitemaps”，并在右侧加上sitemap的url，点击提交。 ","date":"17170-66-29","objectID":"/hugo_seo/:2:2","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/hugo_seo/"},{"categories":["blog","hugo"],"content":"百度不死心的尝试 不死心的失败了 ","date":"17170-66-29","objectID":"/hugo_seo/:2:3","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/hugo_seo/"},{"categories":["blog","hugo"],"content":"Hugo 添加tags等分类","date":"17170-66-37","objectID":"/hugo_tags/","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/hugo_tags/"},{"categories":["blog","hugo"],"content":"Hugo Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在这里查看。 分类taxonomy有3个概念： Taxonomy 分类: 可以用来对内容进行分类的类别 Term 术语: 分类的一个键 Value 值: 分配给这个Term的具体内容 例如我需要增加3个分类，分别是： tag：文章标签 topic：文章主题/文章系列 category：文章分类 以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如hugo，Value是打上这个标签的对应网页。 ","date":"17170-66-37","objectID":"/hugo_tags/:0:0","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/hugo_tags/"},{"categories":["blog","hugo"],"content":"配置分类 需要在 config.toml 中增加分类。还是这个例子，则需要增加如下内容： [taxonomies] tag = \"tags\" category = \"categories\" 而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为： title: \"Hugo添加tags等分类\" date: 2020-06-17T20:19:37+08:00 tags: [\"hugo\"] draft: true 当然实际上，Hugo默认会产生 tags 和 categories 的分类，如果只需要这两个，可以不用在 config.toml 中声明就在post头部使用。 ","date":"17170-66-37","objectID":"/hugo_tags/:0:1","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/hugo_tags/"},{"categories":["blog","hugo"],"content":"分类集合查看 使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。 还是以tag为例： example.com/tags/ 会列出tags中的所有术语； example.com/tags/docker 会列出tags标为docker的所有网页列表。 额外知识点： ","date":"17170-66-37","objectID":"/hugo_tags/:0:2","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/hugo_tags/"},{"categories":["blog","hugo"],"content":"keywords、description meta标签的一个很重要的功能就是设置关键字，来帮助你的主页被各大搜索引擎登录，提高网站的访问量。在这个功能中，最重要的就是对Keywords和description的设置。因为按照搜索引擎的工作原理,搜索引擎首先派出机器人自动检索页面中的keywords和decription，并将其加入到自己的数据库，然后再根据关键词的密度将网站排序。因此，我们必须设置好关键字，来提高页面的搜索点击率。使用如下： keywords: - hugo - blog - 博客 - 建站 description: \"Hugo 添加tags等分类\" keywords需要进行配置： 在themes\\meme\\layouts\\partials\\header.html的 \u003cheader class=\"header\"{{ if and (eq .Site.Params.headerLayout \"flex\") 内部添加 就可以了\r description是hugo支持的，不需要配置 ","date":"17170-66-37","objectID":"/hugo_tags/:0:3","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/hugo_tags/"},{"categories":["blog","hugo"],"content":"Hugo 建站（2）Blog","date":"16160-66-53","objectID":"/hugo_install_2/","tags":["hugo"],"title":"Hugo blog（2）","uri":"/hugo_install_2/"},{"categories":["blog","hugo"],"content":"Introduction 正如上一篇说的，我选择了Hugo作为静态网页生成器。为何要放弃Hexo，换成Hugo呢？ 主要是出于以下考虑： 1.Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。 2.同样得益于go，Hugo的安装配置看上去也并不麻烦；Hugo可以很轻松的被编译成二进制文件安装、运行。不必像Hexo一样依赖Node.js，也不必安装一堆依赖 Hugo的安装配置看上去也并不麻烦，同样得益于go， 安装 直接在这里选择合适的版本。 下载好后解压，将解压出来的可执行文件 (格式为 .exe)，放到自己喜欢的目录下。直接可以使用，不需要安装。 但要记住一定要将你选择的文件夹路径加入到环境变量 PATH 中。 PS：由于theme选择的是meme，需要下载extended版本的hugo； 初始化 下面，初始化博客路径。首先需要选择一个路径来存放我们的博客，在你选好的路径下执行： hugo new site myBlog 这条命令会创建一个名为myBlog（可以使用任意名字）的文件夹来存放你的博客。执行 cd myBlog 命令进入文件夹。 此时目录结构应该是这样的 . └── myBlog ├── config.toml / config.yaml / config.json ├── content │ └── ... ├── layouts │ └── ... ├── themes │ └── ... ├── static │ └── ... ├── archetypes │ └── ... ├── data │ └── ... └── ... 其中： config.toml 是网站的配置文件，Hugo还可使用 config.yaml 或者 config.json 进行配置。 content 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。 layouts 文件夹存放 .html 格式的模板。模板确定了静态网站渲染的样式。 themes 文件夹存放网站使用的theme主题模板。 static 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。 archetypes 文件夹存放网站预设置的文件模板头部，当使用 hugo new 时即可生成一个带有该头部的实例。 data 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。 配置theme 可以在这里找自己喜欢的主题。我暂时选择有搜索功能的meme，将主题clone到themes目录下： git clone https://github.com/忘了/meme.git themes/meme 然后将themes/meme/exampleSite/config.toml模板配置文件复制到根目录，然后根据此文件来配置你的设置。 PS：一定要把config.yaml中的theme修改为你使用的主体名称。比如我用的主题是meme，config.yaml文件就设置theme=“meme” 创建新页面 创建一个新页面 hugo new about.md 此时 content 文件夹下就多了一个 about.md 文件，打开文件就可以看到时间、文件名等信息已经自动生成了 --- title: \"about\" date: 2020-06-16T23:30:53+08:00 draft: true --- 两条 --- 间的信息是文章的配置信息，有的信息是自动生成的 (如：title、date 等)，简单介绍以下各项配置 以下项目是自动生成的: title: # 文章标题 date: # 写作时间 draft: # 是否为草稿，如果为 true 需要在命令中加入 --buildDrafts 参数才会生成这个文档 以下项目需要自行添加: description: # 描述 tags: # 标签，用于文章分类 等等 自动生成 和 执行添加 的内容并不是绝对的，你可以根据自己的喜好配置模板文件 archetypes/default.md 生成网站 设置完config.toml 后我们执行以下命令 hugo server --buildDrafts -w 此时你就可以在 http://localhost:1313 访问到你的博客了。 此时你的博客目录下就会多出一个public目录，这是Hugo生成的网站。 简单介绍一下两个参数： --buildDrafts: 生成被标记为 「草稿」 的文档 -w: 监控更改，如果发生更改直接显示到博客上 PS：但此时只能在本地访问 (相当于预览博客，如果与期望值不符，可以随时更改)，如果想发布到 Github Pages 上需要先将文章配置信息中的 draft: 改为 false ， 然后执行命令 hugo GitHub Pages部署 参考这里，在Github Pages有四种类型，而对于非组织型用户来说有两种，一种是用户的个人网站，网页域名为 username.github.io，另一种为Project的主页，网页域名为 username.github.io/projectname。Github Pages对于Project主页的源码要求有了修改，现在也可以放置在master上，之前版本中必须放在gh-pages 分支上，不过这里暂且不提，主要还是关心用户个人主页。 这就需要你在Github上建立一个以 username.github.io 为名称的repository，对于我来说就是 affectalways.github.io。此外，需要将Hugo生成的所有静态网页push到这个repository的master分支上。现在就可以用这个域名打开个人网站了。 Hugo没有提供自动发布到GitHub Pages的功能。需要将public中的内容手动上传到Github上。 首先执行命令cd public进入到public目录，然后执行 git init git remote add origin https://github.com/Github 用户名/Github 用户名.github.io.git git add . git commit -m \"[介绍，随便写点什么，比如日期]\" git push （若是第一次发布，需要用到--set-upstream） ","date":"16160-66-53","objectID":"/hugo_install_2/:0:0","tags":["hugo"],"title":"Hugo blog（2）","uri":"/hugo_install_2/"},{"categories":["blog","hugo"],"content":"Hugo 建站（1）Blog","date":"16160-66-34","objectID":"/hugo_install_1/","tags":["hugo"],"title":"Hugo blog（1）","uri":"/hugo_install_1/"},{"categories":["blog","hugo"],"content":"初始 养个Blog的想法从很早就有了，但是… 从本科开始就一直想要一个自己的Blog，一直没有行动。本身我就没有记日志的习惯，也没有需求和冲动写下什么东西，虽然有时想记下学的内容，但有道云笔记就够了，也没什么写技术博客的想法。除了很久之前偶尔在CSDN写了几篇入门级文章，也就没有其他了。此外，虽说博客最重要的是内容，但没有一个好的生态环境和前端界面设计，至少对于我而言，没有任何兴趣花时间在上面，原谅我是外观主义者。对于界面设计，CSDN或者博客园实在不敢恭维，尤其是CSDN。自建网站之前也尝试过，恩，还要使用服务器，花钱。我得承认，当时作为本科生的我，太过局限于学校课堂，并未走出去看看，对于网络信息的运用和挖掘也更多停留在看看答案、找找软件、翻翻视频的基础使用上，最多也就是查看下算法之类的。 最近，特别是正式工作快一年了，更多地接触了“网络世界”的信息和知识，拓宽了实页。随着自我学习机会和时间愈少，碎片化学习和感想也愈多，加上虽然网上知识丰富，但内容驳杂，过段时间想再查找却需要对这些信息重新筛选、略感费劲，再加上工作后个人体悟良多，于是又一次萌生个人博客的想法。 难产 选择恐惧症+控制狂的特质决定了我家Blog的难产… 尽管现在有许多像知乎专栏这样现代化的界面和良好的用户群的网站可以让人直接在上面写作，但我还是更倾向于GitHub Pages，与GitHub非常紧密的关系是该倾向性很重要的原因（这对码农而言，非常有诱惑力）。 GitHub Pages搭建个人博客，使用的是轻量级的静态网页，网上已经有了很多教程和方案。几天前遇到了三种方案：Jekyll、Hexo、Hugo。Jekyll据说可定制化和功能很强大，但是ruby个人真的很不能接受。Hexo是国人教程最多的，国外口碑也非常好，看到外国的一句评论说，缺点就是大多数内容都是中文，英文教程少，哈哈。Hexo是基于Node.js，对于程序员相当友好。不过这次我决定选择另一个Framework，使用Hugo。Hugo是用现在大热的go语言写的，据说编译起来比Hexo还会快很多。而且我最近在学go… 开始 开始吧 那就开始吧 ","date":"16160-66-34","objectID":"/hugo_install_1/:0:0","tags":["hugo"],"title":"Hugo blog（1）","uri":"/hugo_install_1/"},{"categories":["blog","hugo"],"content":"使用Hugo + GitHub Pages搭建个人博客","date":"16160-66-14","objectID":"/hugo_install/","tags":["hugo"],"title":"使用Hugo + GitHub Pages搭建个人博客","uri":"/hugo_install/"},{"categories":["blog","hugo"],"content":"​ Hugo：是一种通用的网站框架。严格来说，这类应用应该被称作静态网站生成器。这类应用将 Markdown 文件和主题一起编译成由 HTML、CSS、JavaScript 组成的静态网页。 ​ 然后上传到 GitHub 上，通过 GitHub 提供的静态页面托管服务 (GitHub Pages) 进行访问。 ​ 这里就写一篇文章来记录一下踩过的坑。 ","date":"16160-66-14","objectID":"/hugo_install/:0:0","tags":["hugo"],"title":"使用Hugo + GitHub Pages搭建个人博客","uri":"/hugo_install/"},{"categories":null,"content":"面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1-\u003e2-\u003e3-\u003e4-\u003e5 和 k = 2 输出： 4 说明： 给定的 k 保证是有效的。 思路 经典的快慢指针问题 反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。 设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点 class Solution(object): def kthToLast(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: int \"\"\" if head is None: return None left = head right = head count = 0 while count \u003c k: right = right.next count += 1 while right: left = left.next right = right.next return left.val ","date":"1010-11-00","objectID":"/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":null,"title":"","uri":"/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"1108. IP 地址无效化 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。 所谓无效化 IP 地址，其实就是用 \"[.]\" 代替了每个 \".\"。 示例 1： 输入：address = \"1.1.1.1\" 输出：\"1[.]1[.]1[.]1\" 示例 2： 输入：address = \"255.100.50.0\" 输出：\"255[.]100[.]50[.]0\" 提示： 给出的 address 是一个有效的 IPv4 地址 代码 class Solution(object): def defangIPaddr(self, address): \"\"\" :type address: str :rtype: str \"\"\" return address.replace('.', '[.]') ","date":"1010-11-00","objectID":"/1108-ip%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/:0:0","tags":null,"title":"","uri":"/1108-ip%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"},{"categories":null,"content":"1252. 奇数值单元格的数目 给你一个n行m列的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。 请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。 示例 1： 输入：n = 2, m = 3, indices = [[0,1],[1,1]] 输出：6 解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。 第一次增量操作后得到 [[1,2,1],[0,1,0]]。 最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。 示例 2： 输入：n = 2, m = 2, indices = [[1,1],[0,0]] 输出：0 解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。 提示： 1 \u003c= n \u003c= 50 1 \u003c= m \u003c= 50 1 \u003c= indices.length \u003c= 100 0 \u003c= indices[i][0] \u003c n 0 \u003c= indices[i][1] \u003c m 代码 class Solution(object): def oddCells(self, n, m, indices): \"\"\" :type n: int :type m: int :type indices: List[List[int]] :rtype: int \"\"\" recy = [[0 for i in range(m)] for j in range(n)] for item in indices: for x in range(n): recy[x][item[1]] += 1 for y in range(m): recy[item[0]][y] += 1 count = 0 for i in range(n): for j in range(m): if recy[i][j] % 2 == 1: count += 1 return count ","date":"1010-11-00","objectID":"/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/:0:0","tags":null,"title":"","uri":"/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/"},{"categories":null,"content":"1281. 整数的各位积和之差 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1： 输入：n = 234 输出：15 解释： 各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2： 输入：n = 4421 输出：21 解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 提示： 1 \u003c= n \u003c= 10^5 代码 class Solution(object): def subtractProductAndSum(self, n): \"\"\" :type n: int :rtype: int \"\"\" mul = 1 ad = 0 while n \u003e 0: tmp = n % 10 mul *= tmp ad += tmp n //= 10 return mul - ad ","date":"1010-11-00","objectID":"/1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/:0:0","tags":null,"title":"","uri":"/1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/"},{"categories":null,"content":"1323. 6 和 9 组成的最大数字 给你一个仅由数字 6 和 9 组成的正整数 num。 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。 请返回你可以得到的最大数字。 示例 1： 输入：num = 9669 输出：9969 解释： 改变第一位数字可以得到 6669 。 改变第二位数字可以得到 9969 。 改变第三位数字可以得到 9699 。 改变第四位数字可以得到 9666 。 其中最大的数字是 9969 。 示例 2： 输入：num = 9996 输出：9999 解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。 示例 3： 输入：num = 9999 输出：9999 解释：无需改变就已经是最大的数字了。 提示： 1 \u003c= num \u003c= 10^4 num 每一位上的数字都是 6 或者 9 。 代码 class Solution(object): def maximum69Number(self, num): \"\"\" :type num: int :rtype: int \"\"\" return int(str(num).replace('6', '9', 1)) ","date":"1010-11-00","objectID":"/1323-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/:0:0","tags":null,"title":"","uri":"/1323-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/"},{"categories":null,"content":"1431. 拥有最多糖果的孩子 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示 2 \u003c= candies.length \u003c= 100 1 \u003c= candies[i] \u003c= 100 1 \u003c= extraCandies \u003c= 50 代码 class Solution(object): def kidsWithCandies(self, candies, extraCandies): \"\"\" :type candies: List[int] :type extraCandies: int :rtype: List[bool] \"\"\" max_val = max(candies) result = [False] * len(candies) for index, item in enumerate(candies): if (item + extraCandies) \u003e= max_val: result[index] = True return result ","date":"1010-11-00","objectID":"/1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/:0:0","tags":null,"title":"","uri":"/1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/"},{"categories":null,"content":"1480. 一维数组的动态和 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： 1 \u003c= nums.length \u003c= 1000 -10^6 \u003c= nums[i] \u003c= 10^6 代码 class Solution(object): def runningSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" if not nums: return [] result = list() result.append(nums[0]) for ind in range(1, len(nums)): result.append(result[ind - 1] + nums[ind]) return result ","date":"1010-11-00","objectID":"/1480-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/:0:0","tags":null,"title":"","uri":"/1480-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/"},{"categories":null,"content":"剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1： 输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2： 输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" 限制： 1 \u003c= k \u003c s.length \u003c= 10000 代码 class Solution(object): def reverseLeftWords(self, s, n): \"\"\" :type s: str :type n: int :rtype: str \"\"\" return s[n:] + s[:n] if __name__ == '__main__': solution = Solution() result = solution.reverseLeftWords(s=\"abcdefg\", n=2) print(result) ","date":"1010-11-00","objectID":"/58offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"","uri":"/58offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"LCP 01. 猜数字 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？ 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。 示例 1： 输入：guess = [1,2,3], answer = [1,2,3] 输出：3 解释：小A 每次都猜对了。 示例 2： 输入：guess = [2,2,3], answer = [3,2,1] 输出：1 解释：小A 只猜对了第二次。 限制： guess的长度 = 3 answer的长度 = 3 guess的元素取值为 {1, 2, 3} 之一。 answer的元素取值为 {1, 2, 3} 之一。 代码 class Solution(object): def game(self, guess, answer): \"\"\" :type guess: List[int] :type answer: List[int] :rtype: int \"\"\" count = 0 for index in range(len(guess)): if guess[index] == answer[index]: count += 1 return count ","date":"1010-11-00","objectID":"/lcp-01-%E7%8C%9C%E6%95%B0%E5%AD%97/:0:0","tags":null,"title":"","uri":"/lcp-01-%E7%8C%9C%E6%95%B0%E5%AD%97/"},{"categories":null,"content":"LCP 01. 猜数字 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？ 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。 示例 1： 输入：guess = [1,2,3], answer = [1,2,3] 输出：3 解释：小A 每次都猜对了。 示例 2： 输入：guess = [2,2,3], answer = [3,2,1] 输出：1 解释：小A 只猜对了第二次。 限制： guess的长度 = 3 answer的长度 = 3 guess的元素取值为 {1, 2, 3} 之一。 answer的元素取值为 {1, 2, 3} 之一。 代码 class Solution(object): def game(self, guess, answer): \"\"\" :type guess: List[int] :type answer: List[int] :rtype: int \"\"\" count = 0 for index in range(len(guess)): if guess[index] == answer[index]: count += 1 return count ","date":"1010-11-00","objectID":"/lcp01%E7%8C%9C%E6%95%B0%E5%AD%97/:0:0","tags":null,"title":"","uri":"/lcp01%E7%8C%9C%E6%95%B0%E5%AD%97/"},{"categories":null,"content":" title: \"665非递减数列\" date: 2020-07-28T22:55:18+08:00 keywords: - leetcode - 数组 - hugo - blog categories: [\"leetcode\", \"数组\"] draft: false 665. 非递减数列 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 \u003c= i \u003c= n-2)，总满足 nums[i] \u003c= nums[i + 1]。 示例 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明： 1 \u003c= n \u003c= 10 ^ 4 - 10 ^ 5 \u003c= nums[i] \u003c= 10 ^ 5 解题思路 遍历数组，初始count = 0，如果当前元素值比它下一个元素值大，则count += 1，当count \u003e 1时，直接返回false。 另外，在遍历数组的过程中，如果遇到 “特殊情况”，可以直接返回false；当循环正常结束则返回true 代码 func checkPossibility(nums []int) bool { if len(nums) == 1 { return true } var count int = 0 for index, value := range nums { if index == 0 { continue } if value \u003c nums[index-1] { count += 1 } if count \u003e 1 { return false } } return true } 但是！！！ 提交后，运行过程 输入: [3,4,2,3] 输出 true 预期结果 false 所以要考虑特殊情况 现在就需要nums[i-2] \u003c= nums[i-1] \u003e nums[i] \u003c= nums[i+1]这个条件了 最终代码 func checkPossibility(nums []int) bool { if len(nums) \u003c= 2 { return true } var count int = 0 for index, value := range nums { if index == 0 { continue } if value \u003c nums[index-1] { count += 1 if nums[index-1] \u003e nums[index+1] \u0026\u0026 nums[index-2] \u003e value { return false } } if count \u003e 1 { return false } } return true } ","date":"1010-11-00","objectID":"/665%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/:0:0","tags":null,"title":"","uri":"/665%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"},{"categories":null,"content":" title: \"0207 链表相交\" date: 2020-07-15T21:20:33+08:00 tags: [\"leetcode\"] keywords: - leetcode - blog - 博客 - 领扣 - 0207 链表相交 - 算法 - 链表 description: \"leetcode，0207 链表相交\" categories: [\"leetcode\", \"链表\"] draft: false 面试题 02.07. 链表相交 我竟然没读懂题！！！！！！！！！！！ 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 1.如果两个链表没有交点，返回 null 。 2.在返回结果后，两个链表仍须保持原有的结构。 3.可假定整个链表结构中没有循环。 4.程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 思路 双指针什么的，技巧性有点强。最朴素的做法是求长度 1.第一次遍历两个链表，记录长度 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址） 代码 class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: len_a = 0 len_b = 0 cur_a = headA cur_b = headB # 1.第一次遍历两个链表，记录长度 while cur_a: len_a += 1 cur_a = cur_a.next while cur_b: len_b += 1 cur_b = cur_b.next # 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步 cur_a = headA cur_b = headB while len_b \u003e len_a: cur_b = cur_b.next len_b -= 1 while len_a \u003e len_b: cur_a = cur_a.next len_a -= 1 # 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址） while cur_a: if cur_a == cur_b: return cur_a cur_a = cur_a.next cur_b = cur_b.next return None def create_list(sequence): headA = None cur = None for i in sequence: node = ListNode(i) if headA is None: headA = cur = node continue cur.next = node cur = cur.next return headA if __name__ == '__main__': intersectVal = 8 listA = [4, 1, 8, 4, 5] headA = create_list(listA) listB = [5, 0, 1, 8, 4, 5] headB = create_list(listB) skipA = 2 skipB = 3 ","date":"1010-11-00","objectID":"/0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/:0:0","tags":null,"title":"","uri":"/0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"},{"categories":null,"content":" title: \"0207 链表相交\" date: 2020-07-15T21:20:33+08:00 tags: [\"leetcode\"] keywords: - leetcode - blog - 博客 - 领扣 - 0207 链表相交 - 算法 - 链表 description: \"leetcode，0207 链表相交\" categories: [\"leetcode\", \"链表\"] draft: false 面试题 02.07. 链表相交 我竟然没读懂题！！！！！！！！！！！ 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 1.如果两个链表没有交点，返回 null 。 2.在返回结果后，两个链表仍须保持原有的结构。 3.可假定整个链表结构中没有循环。 4.程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 思路 双指针什么的，技巧性有点强。最朴素的做法是求长度 1.第一次遍历两个链表，记录长度 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址） 代码 class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: len_a = 0 len_b = 0 cur_a = headA cur_b = headB # 1.第一次遍历两个链表，记录长度 while cur_a: len_a += 1 cur_a = cur_a.next while cur_b: len_b += 1 cur_b = cur_b.next # 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步 cur_a = headA cur_b = headB while len_b \u003e len_a: cur_b = cur_b.next len_b -= 1 while len_a \u003e len_b: cur_a = cur_a.next len_a -= 1 # 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址） while cur_a: if cur_a == cur_b: return cur_a cur_a = cur_a.next cur_b = cur_b.next return None def create_list(sequence): headA = None cur = None for i in sequence: node = ListNode(i) if headA is None: headA = cur = node continue cur.next = node cur = cur.next return headA if __name__ == '__main__': intersectVal = 8 listA = [4, 1, 8, 4, 5] headA = create_list(listA) listB = [5, 0, 1, 8, 4, 5] headB = create_list(listB) skipA = 2 skipB = 3 ","date":"1010-11-00","objectID":"/0207%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/:0:0","tags":null,"title":"","uri":"/0207%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"},{"categories":null,"content":" title: \"Offer 06. 从尾到头打印链表\" date: 2020-07-15T21:20:33+08:00 tags: [\"leetcode\"] keywords: - leetcode - blog - 博客 - 领扣 - Offer 06. 从尾到头打印链表 - 算法 - 链表 description: \"leetcode，Offer 06. 从尾到头打印链表\" categories: [\"leetcode\", \"链表\"] draft: false 剑指 Offer 06. 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 \u003c= 链表长度 \u003c= 10000 思路 ## 方法一：栈 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。 创建一个栈，用于存储链表的节点 创建一个指针，初始时指向链表的头节点 当指针指向的元素非空时，重复下列操作： 将指针指向的节点压入栈内 将指针移到当前节点的下一个节点 获得栈的大小 size，创建一个数组 print，其大小为 size 创建下标并初始化 index = 0 重复 size 次下列操作： 从栈内弹出一个节点，将该节点的值存到 print[index] 将 index 的值加 1 返回 print ## 复杂性分析 时间复杂度：O(n)O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。 空间复杂度：O(n)O(n)。额外使用一个栈存储链表中的每个节点。 代码 class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def reversePrint(self, head): \"\"\" :type head: ListNode :rtype: List[int] \"\"\" if head is None: return [] stack = [] while head: stack.append(head.val) head = head.next stack.reverse() return stack # result = None # cur = None # for node in stack: # if result is None: # result = node # cur = result # continue # cur.next = node # cur = cur.next # return result def create_list(sequence): headA = None cur = None for i in sequence: node = ListNode(i) if headA is None: headA = cur = node continue cur.next = node cur = cur.next return headA if __name__ == '__main__': solution = Solution() head = create_list([1, 3, 2]) result = solution.reversePrint(head) ","date":"1010-11-00","objectID":"/offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"","uri":"/offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":" title: \"Offer 06. 从尾到头打印链表\" date: 2020-07-15T21:20:33+08:00 tags: [\"leetcode\"] keywords: - leetcode - blog - 博客 - 领扣 - Offer 06. 从尾到头打印链表 - 算法 - 链表 description: \"leetcode，Offer 06. 从尾到头打印链表\" categories: [\"leetcode\", \"链表\"] draft: false 剑指 Offer 06. 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 \u003c= 链表长度 \u003c= 10000 思路 ## 方法一：栈 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。 创建一个栈，用于存储链表的节点 创建一个指针，初始时指向链表的头节点 当指针指向的元素非空时，重复下列操作： 将指针指向的节点压入栈内 将指针移到当前节点的下一个节点 获得栈的大小 size，创建一个数组 print，其大小为 size 创建下标并初始化 index = 0 重复 size 次下列操作： 从栈内弹出一个节点，将该节点的值存到 print[index] 将 index 的值加 1 返回 print ## 复杂性分析 时间复杂度：O(n)O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。 空间复杂度：O(n)O(n)。额外使用一个栈存储链表中的每个节点。 代码 class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution(object): def reversePrint(self, head): \"\"\" :type head: ListNode :rtype: List[int] \"\"\" if head is None: return [] stack = [] while head: stack.append(head.val) head = head.next stack.reverse() return stack # result = None # cur = None # for node in stack: # if result is None: # result = node # cur = result # continue # cur.next = node # cur = cur.next # return result def create_list(sequence): headA = None cur = None for i in sequence: node = ListNode(i) if headA is None: headA = cur = node continue cur.next = node cur = cur.next return headA if __name__ == '__main__': solution = Solution() head = create_list([1, 3, 2]) result = solution.reversePrint(head) ","date":"1010-11-00","objectID":"/offer06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"","uri":"/offer06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"}]