[{"categories":["leetcode","栈"],"content":"20. 有效的括号 给定一个只包括 ‘('，')'，'{'，'}'，'['，']’ 的字符串，判断字符串是否有效。\n有效字符串需满足：\n​\t1.左括号必须用相同类型的右括号闭合。 ​\t2.左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。\n示例 1:\n输入: \"()\"\r输出: true\r示例 2:\n输入: \"()[]{}\"\r输出: true\r示例 3:\n输入: \"(]\"\r输出: false\r示例 4:\n输入: \"([)]\"\r输出: false\r示例 5:\n输入: \"{[]}\"\r输出: true\r解题思路\n栈\r代码\nclass Solution:\rdef isValid(self, s):\r\"\"\"\r:type s: str\r:rtype: bool\r\"\"\"\rsign_dict = {')': '(', '}': '{', ']': '['}\rtmp_list = []\rif len(s) % 2 != 0:\rreturn False\rfor element in s:\rif element in sign_dict.keys():\rif not len(tmp_list):\rreturn False\rbefore = tmp_list.pop()\rif sign_dict[element] != before:\rreturn False\relse:\rtmp_list.append(element)\rif len(tmp_list):\rreturn False\rreturn True\r","description":"","tags":["leetcode"],"title":"20有效的括号","uri":"/posts/leetcode/%E6%A0%88/20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"},{"categories":["算法"],"content":"Backtracking Algorithm In this tutorial, you will learn what a backtracking algorithm is. Also, you will find an example of a backtracking approcah.\nA backtracking algorithm is a problem-solving algorithm that uses a brute force approach for finding the desired output.\nThe Brute force approach tries out all the possible solutions and chooses the desired/best solutions.\rThe term backtracking suggests that if the current solution is not suitable, then backtrack and try other solutions. Thus, recursion is used in this approach.\nThis approach is used to solve problems that have multiple solutions.\nBacktracking algorithm is applied to some specific types of problems,\n Decision problem used to find a feasible solution of the problem. Optimisation problem used to find the best solution that can be applied. Enumeration problem used to find the set of all feasible solutions of the problem.  Example Green is the start point, blue is the intermediate point, red are points with no feasible solution, dark green is end solution.\nHere, when the algorithm propagates to an end to check if it is a solution or not, if it is then returns the solution otherwise backtracks to the point one step behind it to find track to the next point to find solution.\nStep 1 − if current_position is goal, return success\rStep 2 − else,\rStep 3 − if current_position is an end point, return failed.\rStep 4 − else, if current_position is not end point, explore and repeat above steps.\rBacktracking Algorithm backtrack(x)\rif x is not a solution\rreturn false\rif x is a new solution\radd to list of solutions\rbacktrack(expand x)\rLet’s use this backtracking problem to find the solution to N-Queen Problem.\nIn N-Queen problem, we are given an NxN chessboard and we have to place n queens on the board in such a way that no two queens attack each other. A queen will attack another queen if it is placed in horizontal, vertical or diagonal points in its way. Here, we will do 4-Queen problem.\nHere, the binary output for n queen problem with 1’s as queens to the positions are placed.\n{0 , 1 , 0 , 0}\r{0 , 0 , 0 , 1}\r{1 , 0 , 0 , 0}\r{0 , 0 , 1 , 0}\rFor solving n queens problem, we will try placing queen into different positions of one row. And checks if it clashes with other queens. If current positioning of queens if there are any two queens attacking each other. If they are attacking, we will backtrack to previous location of the queen and change its positions. And check clash of queen again.\nProcedure Step 1 − Start from 1st position in the array.Step 2 − Place queens in the board and check. Do,\rStep 2.1 − After placing the queen, mark the position as a part of the solution and then recursively check if this will lead to a solution.\rStep 2.2 − Now, if placing the queen doesn’t lead to a solution and trackback and go to step (a) and place queens to other rows.\rStep 2.3 − If placing queen returns a lead to solution return TRUE.\rStep 3 − If all queens are placed return TRUE.\rStep 4 − If all rows are tried and no solution is found, return FALSE.\rselect from：\nhttps://www.programiz.com/dsa/backtracking-algorithm\nhttps://www.tutorialspoint.com/introduction-to-backtracking\n","description":"","tags":["算法"],"title":"回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["leetcode","数组"],"content":"78. 子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n**说明：**解集不能包含重复的子集。\n示例:\n输入: nums = [1,2,3]\r输出:\r[\r[3],\r[1],\r[2],\r[1,2,3],\r[1,3],\r[2,3],\r[1,2],\r[]\r]\r","description":"","tags":["leetcode"],"title":"78子集","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/78%E5%AD%90%E9%9B%86/"},{"categories":["leetcode","数组"],"content":"34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n你的算法时间复杂度必须是 O(log n) 级别。\n如果数组中不存在目标值，返回 [-1, -1]。\n示例 1:\n输入: nums = [5,7,7,8,8,10], target = 8\r输出: [3,4]\r示例 2:\n输入: nums = [5,7,7,8,8,10], target = 6\r输出: [-1,-1]\r思路\n算法复杂度O(log n)，一看就是二分了\r解题步骤\n","description":"","tags":["leetcode"],"title":"34在排序数组中查找元素的第一个和最后一个位置","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"categories":["leetcode","数组"],"content":"31. 下一个排列 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须原地修改，只允许使用额外常数空间。\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,2\r3,2,1 → 1,2,3\r1,1,5 → 1,5,1\r思路\n1.我们希望下一个数**比当前数大**，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。\r2.我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：\r1.在**尽可能靠右的低位**进行交换，需要**从后向前查找**\r2.将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换\r3.将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列\r解题步骤\n  从后往前找到第一对两个连续的数字，并且满足条件A[i]\u003cA[i+1], A[i+1: end]肯定是降序排列的\n  现在需要从A[i+1: end]中找到最接近A[i]的值，记做A[j]\n  交换A[i]和A[j]\n  把A[i+1: end] 按升序排序，就是最后的结果\n  代码\nclass Solution:\rdef nextPermutation(self, nums) -\u003e None:\r\"\"\"\rDo not return anything, modify nums in-place instead.\r\"\"\"\rif len(nums) \u003c 2: return\rfor i in range(len(nums) - 2, -1, -1):\rif nums[i] \u003c nums[i + 1]:\rfor j in range(len(nums) - 1, i, -1):\rif nums[j] \u003e nums[i]:\rnums[i], nums[j] = nums[j], nums[i]\rbreak\rnums[i + 1:] = sorted(nums[i + 1:])\rreturn\rreturn nums.sort()\r","description":"","tags":["leetcode"],"title":"31下一个排列","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["leetcode","数组"],"content":"18. 四数之和 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断nums中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例：\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\r满足要求的四元组集合为：\r[\r[-1, 0, 0, 1],\r[-2, -1, 1, 2],\r[-2, 0, 0, 2]\r]\r思路\n参考15三数之和，只不过是增加一层循环，还是使用两个指针\r代码\nfunc fourSum(nums []int, target int) [][]int {\rif len(nums) \u003c 4 {\rreturn nil\r}\r// 生序排序\rsort.Ints(nums)\r// 遍历、收集等于targe的组合\rvar equals [][]int\rfor i := 0; i \u003c len(nums)-3; i++ {\r// 第一个元素去重\rif i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] {\rcontinue\r}\rfor j := i + 1; j \u003c len(nums)-2; j++ {\r// 第二个元素去重\rif j \u003e i+1 \u0026\u0026 nums[j] == nums[j-1] {\rcontinue\r}\rk, l := j+1, len(nums)-1\rfor k \u003c l {\rsum := nums[i] + nums[j] + nums[k] + nums[l]\rdistance := sum - target\rif distance == 0 {\requals = append(equals, []int{nums[i], nums[j], nums[k], nums[l]})\r}\rif distance \u003e 0 {\r// 第四个元素去重\rfor cur := l; l \u003e k \u0026\u0026 nums[l] == nums[cur]; l-- {\r}\r} else {\r// 第三个元素去重\rfor cur := k; k \u003c l \u0026\u0026 nums[k] == nums[cur]; k++ {\r}\r}\r}\r}\r}\rreturn equals\r}\r","description":"","tags":["leetcode"],"title":"18四数之和","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["leetcode","数组"],"content":"16. 最接近的三数之和 给定一个包括 n 个整数的数组nums和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n示例：\n输入：nums = [-1,2,1,-4], target = 1\r输出：2\r解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\r提示：\n3 \u003c= nums.length \u003c= 10^3\r-10^3 \u003c= nums[i] \u003c= 10^3\r-10^4 \u003c= target \u003c= 10^4\r思路\n同15三数之和类似\r代码\npackage main\rimport (\r\"fmt\"\r\"math\"\r\"sort\"\r)\rfunc threeSumClosest(nums []int, target int) int {\rsort.Ints(nums)\rvar length int = len(nums)\rvar result int\rif length \u003c 3 {\rreturn result\r}\rtmp := int(math.NaN())\rfor index, value := range nums {\rvar left int = index + 1\rvar right int = length - 1\rfor left \u003c right {\rsum := value + nums[left] + nums[right]\rdiff := sum - target\rvar abs_diff = math.Abs(float64(diff))\rif diff == 0 {\rreturn sum\r} else if diff \u003c 0 {\rif abs_diff \u003c math.Abs(float64(tmp)) {\rtmp = int(abs_diff)\rresult = sum\r}\rleft += 1\r} else if diff \u003e 0 {\rif abs_diff \u003c math.Abs(float64(tmp)) {\rtmp = int(abs_diff)\rresult = sum\r}\rright -= 1\r}\r}\r}\rreturn result\r}\rfunc main() {\rheight := []int{-1, 2, 1, -4}\rresult := threeSumClosest(height, 1)\rfmt.Print(result)\r}\r","description":"","tags":["leetcode"],"title":"16最接近的三数之和","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["leetcode","数组"],"content":"15. 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n**注意：**答案中不可以包含重复的三元组。\n示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\r满足要求的三元组集合为：\r[\r[-1, 0, 1],\r[-1, -1, 2]\r]\r思路\n摘自https://leetcode-cn.com/problems/3sum/solution/man-hua-jue-bu-wu-ren-zi-di-xiang-kuai-su-kan-dong/\r本题的暴力题解可以仿照二数之和，直接三层遍历，取和为 0 的三元组，并记录下来，最后再去重。但是作为一个有智慧的人，我们不能这么去做。\r因为我们的目标是找数，当然使用指针的方式最简单。假若我们的数组为：\n[-1, 0, 1, 2, -1, -4]\r求解过程如下：首先我们先把数组排个序（原因一会儿说），排完序长这样：\n因为我们要同时找三个数，所以采取固定一个数，同时用双指针来查找另外两个数的方式。所以初始化时，我们选择固定第一个元素（当然，这一轮走完了，这个蓝框框我们就要也往前移动），同时将下一个元素和末尾元素分别设上 left 和 right 指针。画出图来就是下面这个样子：\n现在已经找到了三个数，当然是计算其三值是否满足三元组。但是这里因为我们已经排好了序，如果**固定下来的数（上面蓝色框框）本身就大于 0，那三数之和必然无法等于 0 **。比如下面这种：\n然后自然用脚指头也能想到，我们需要移动指针。现在我们的排序就发挥出用处了，如果和大于 0，那就说明 right 的值太大，需要左移。如果和小于 0，那就说明 left 的值太小，需要右移。(上面这个思考过程是本题的核心) 整个过程如下图所示：\n其中：在第 6 行时，因为三数之和大于 0，所以 right 进行了左移。最后一行，跳过了重复的 -1。\n然后啰嗦一句，因为我们需要处理重复值的情况。除了固定下来的i值（蓝框框），left 和 right 当然也是需要处理重复的情况，所以对于 left 和 left+1，以及 right 和 right-1，我们都单独做一下重复值的处理。（其实没啥处理，就是简单的跳过）\n代码\npackage main\rimport (\r\"fmt\"\r\"sort\"\r)\rfunc threeSum(nums []int) [][]int {\rsort.Ints(nums)\rvar result [][]int\rlength := len(nums)\rif length \u003c 3 {\rreturn result\r}\rfor index, value := range nums {\rif value \u003e 0 {\rreturn result\r}\rif index \u003e 0 \u0026\u0026 nums[index] == nums[index-1] {\rcontinue\r}\rleft := index + 1\rright := length - 1\rfor left \u003c right {\rsum := nums[left] + nums[right] + value\rif sum == 0 {\rresult = append(result, []int{value, nums[left], nums[right]})\rfor left \u003c right \u0026\u0026 nums[left] == nums[left+1] {\rleft += 1\r}\rfor left \u003c right \u0026\u0026 nums[right] == nums[right-1] {\rright -= 1\r}\rleft += 1\rright -= 1\r} else if sum \u003c 0 {\rleft += 1\r} else {\rright -= 1\r}\r}\r}\rreturn result\r}\rfunc main() {\rnums := []int{-1, 0, 1, 2, -1, -4}\rresult := threeSum(nums)\rfmt.Print(result)\r}\r","description":"","tags":["leetcode"],"title":"15三数之和","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["leetcode","数组"],"content":"11. 盛最多水的容器 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器，且 n 的值至少为 2。\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\r示例：\n输入：[1,8,6,2,5,4,8,3,7]\r输出：49\r解题思路\n双指针\r代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func maxArea(height []int) int { result := 0 length := len(height) if length \u003c= 1 { return result } left := 0 right := length - 1 var m, n int for left \u003c right { m = right - left if height[right] \u003c height[left] { n = height[right] right -= 1 } else { n = height[left] left += 1 } square := m * n if square \u003e result { result = square } } return result }   ","description":"","tags":["leetcode"],"title":"11盛最多水的容器","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["AMQP"],"content":"Message Structure A message has two parts: a payload and a label (routing key). The payload is the data that you want to transmit. The label (routing key) describes the payload and the RabbitMQ messaging system uses this to determine who will receive a copy of your message.\nUnlike TCP — where you need to specify the sender and receiver — AMQP only describes the message with a label. This label includes an exchange name and can optionally include a topic tag. RabbitMQ then sends the label to the interested receivers. This communication is “send-and-forget” and one-directional — see Understanding Messaging: Part One — The Basics for more information on this concept.\nConsumers and Producers Put simply, producers create messages and consumers receive them. Your application can be a producer when it needs to send a message to another application or it can be a consumer when it needs to receive a message.\nProducers Producers create messages and publish (send) them to a broker server (in this case, RabbitMQ). Producers create messages and label them for routing.\nConsumers Consumers attach to a broker server and subscribe to a queue, which is like a named mailbox. Whenever a message arrives in a particular mailbox, RabbitMQ sends it to one of the subscribed/listening consumers. Labels attached to the message are not passed along during routing. As a result, the consumer should only receive one part of the message — the payload. RabbitMQ does not reveal the producer/sender unless the producer includes that message in the message payload. Figure 2 (below) outlines this process.\nRouting a Message There are three parts to any successful routing of a message in AMQP architecture:\n Exchanges: Where producers publish their message Queues: Where consumers receive the message Bindings: How the messages are routed from the exchange to a particular queue  Queues Queues are like named mailboxes — this is where sent messages wait to be consumed. When a consumer subscribes to a queue, messages are sent immediately to the subscribed consumer.\nExchanges and Bindings So how does a message reach a queue? Whenever you want to deliver a message to a consumer, you must first send it to an exchange. Then, based on certain rules or routing keys, RabbitMQ will decide to which queue it should deliver the message.\nRules — or routing keys — enable you to bind queues to exchanges. RabbitMQ will try to match the routing key in the message to those used in the bindings. The message will then be delivered to the queue based on one of three types of exchange: fanout, topic, or direct.\nFanout Exchange This type of exchange will broadcast all of the messages that it receives to all of the queues bound to it. Any routing key provided with the published message will be ignored.\nTopic Exchange In this type of exchange, messages are sent to queues based on the routing key. This means that messages sent to a topic exchange must have a specific routing key that must be a list of words, delimited by dots (example, ‘acs.deviceoperations.’). The wording is limited to 255 bytes.\nThe binding key must be in the same format as the routing key. As a result, a message sent with a particular routing key will be delivered to every queue that is bound with the matching binding key.\nThe binding key allows for these expression rules:\n* (star) can substitute for exactly one word # (hash) can substitute for zero or more words\nWhen a queue is bound with “#” (hash) binding key, it will receive all messages, regardless of the routing key, like in fanout exchange.\nDirect Exchange When a queue is declared, it is automatically bound to the exchange that uses the queue name as a routing key. If the routing key matches, then the message is delivered to the corresponding queue.\n摘自：https://www.incognito.com/tutorials/understanding-messaging-part-two-rabbitmq-2/\r","description":"","tags":["AMQP"],"title":"AMQP_整体","uri":"/posts/amqp/amqp_%E6%95%B4%E4%BD%93/"},{"categories":["AMQP"],"content":"What is Messaging? Today, real-time information is constantly required and available. This needs easy ways to be routed to multiple receivers reliably and quickly. Integration solutions have to deal with a few fundamental challenges:\n Networks are unreliable. Integration solutions have to transport data from one computer to another across networks, causing delays or interruptions. Networks are slow. Sending data across a network is much slower than making a local call. Any two applications are different. Integration solutions need to transmit information between systems that use different programming languages, operating platforms, and data formats. An integration solution needs to be able to interface with all these different technologies. Applications change over time. An integration solution has to keep pace with changes in the applications that it connects. It should also minimize the dependencies from one system to another by using loose coupling between applications.  Messaging is a type of technology that helps you overcome the above challenges through asynchronous, program-to-program communication. Messaging enables software applications to connect and scale by separating the sending and receiving of data. There are several important concepts to understand:\n Programs communicate by sending packets of data (messages) to each other. Channels (or queues) are logical pathways that connect the programs and convey messages. A sender or producer is a program that sends a message by writing the message to a channel. A receiver or consumer is a program that receives a message by reading it from a channel.  Important Messaging Concepts  Send and forget. The sending application sends the message to the message channel (queue). Once that step is complete, the sender can move onto other work while the messaging system transmits the message in the background. The sender does not have to wait for the consumer to receive and process the message. Store and forward. The messaging system stores the message, either in memory or on disk, and delivers the message to the receiver’s computer.  Why Use a Messaging System? Messaging capabilities are provided by a separate software system called a messaging system. A messaging system manages the channels that define the paths of communication between the applications and the sending and receiving of messages. The main task of a messaging system is to reliably move messages from the sender’s computer to the receiver’s computer.\nThe benefits of messaging include:\n Remote communication. Messaging enables separate applications to communicate and transfer data. Platform/language integration. When connecting multiple computer systems via remote communication, it’s likely that these systems use different languages, technologies, and platforms. A messaging system allows these disparate to integrate. Asynchronous communication. Messaging enables a “send and forget” approach to communication. The sender does not have to wait for the receiver to receive and process the message. Variable timing. With synchronous communication, the caller must wait for the receiver to finish processing the call before the caller can receive the result and continue. This means that the caller can only make calls as fast as the receiver can perform them. Conversely, asynchronous communication allows the sender to batch requests to the receiver at its own pace and for the receiver to consume the requests at its own different pace. Reliable communication. The messaging uses a “store and forward” approach to transmitting messages. The data is packaged as messages, which are atomic, independent units. When the sender sends a message, the messaging system stores the message and then delivers it by forwarding the message to the receiver’s computer. Topic-based messages. Receivers can register to consume messages selectively based on particular topics of interest.  RabbitMQ is an asynchronous messaging system that can be be used to allow disparate applications share data via a common protocol, Advanced Message Queuing Protocol (AMQP). This protocol was designed to be an open standard that would solve the vast majority of messaging needs and topologies. RabbitMQ is the messaging system used in Incognito Auto Configuration Server.\nFurther Reading For more information on message components and how the processes work in RabbitMQ, refer to Understanding Messaging: Part Two — RabbitMQ.\n摘自：https://www.incognito.com/tips-and-tutorials/understanding-messaging-part-one-the-basics-2/\r","description":"","tags":["AMQP"],"title":"AMQP_消息","uri":"/posts/amqp/amqp_%E6%B6%88%E6%81%AF/"},{"categories":["AMQP"],"content":"AMQP是什么？ Advanced Message Queuing Protocol (AMQP) 是一种开放标准协议，面向消息的应用层协议。\nAMQP是一种应用层协议，可以让客户端应用程序和消息中间件之间进行通信。\nAMQP AMQP：应用层协议，专注于进程间的通信，是二进制协议，因此被认为是紧凑协议，这意味着通过AMQP发送的所有数据都是二进制数据。二进制协议可避免通过网络发送无用的数据。\n总体而言，AMQP的目标是通过TCP/IP连接进行消息传递，并保证消息的可靠性，安全性。\nAMQP模型 通常，消息由生产者（producer）产生，并发送给消息代理（broker）【broker包含exchange和queue】，然后交换机（Exchange）根据消息中提供的交换类型和路由键（routing key）将消息发送到队列（queue），最终被消费者（subscriber）使用。\rAMQP组成部分 生产者（Producer）\n产生消息\r消费者\n使用消息\r消息队列（QUEUE） 消息队列（QUEUE）充当缓冲区，用于存储稍后使用的消息。\r在创建时，消息队列（QUEUE）可以使用很多属性进行定义。例如，可以将消息队列（QUEUE）标记为持久，自动删除或者互斥，此处互斥是指同一时间只能由一个连接使用该队列，并且在该连接关闭时删除此队列。\r交换机（Exchange）\n交换机（Exchange）是用来发送消息的AMQP实体。交换机（Exchange）拿到一个消息后会将消息给一个或多个消息队列（Queue）。\rAMQP定义了消息代理（broker）需要提供四种交换机类型（\rDirect exchange（直连交换机）、\rFanout exchange（扇型交换机）、\rTopic exchange（主题交换机）、\rHeaders exchange（头交换机）\r）\r交换机（Exchange）有两个状态：持久状态和暂存状态。\r1.持久状态的交换机（Exchange）会在消息代理（broker）重启后依然存在\r2.暂停状态的交换机（Exchange）不会在消息代理（broker）重启后存在\r绑定（Binding）\n绑定（Binding）是交换机（Exchange）把消息（Message）传给消费队列（QUEUE）遵循的规则\r如果要指示交换机“E”把消息交给消息队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作是由消息中定义的路由键（Routing key）决定交换机（Exchange）绑定到哪个消息队列（QUEUE）。\r路由键（Routing key）的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\r打个比方：\r队列（queue）是我们想要去的位于纽约的目的地\r交换机（exchange）是JFK机场\r绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条\r连接（Connection）\nAMQP中的连接（Connection）是应用程序和AMQP代理（broker）之间的网络连接，例如TCP/IP套接字连接。\r通道（Channels）\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\r在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\r一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\r虚拟主机（vhost）\n虚拟主机（vhost）提供了一种在代理（broker）中隔离应用程序的方法。\r不同的用户可以对不同的虚拟主机具有不同的访问权限。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\r","description":"","tags":["AMQP"],"title":"AMQP介绍","uri":"/posts/amqp/amqp%E4%BB%8B%E7%BB%8D/"},{"categories":["leetcode","数组"],"content":"219. 存在重复元素 II 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。\n示例 1:\n输入: nums = [1,2,3,1], k = 3\r输出: true\r示例 2:\n输入: nums = [1,0,1,1], k = 1\r输出: true\r示例 3:\n输入: nums = [1,2,3,1,2,3], k = 2\r输出: false\r思路\n1.贪心\n2.哈希表\n1、维护一个哈希表m，存储每个数字上次出现的位置\r2、遍历nums\r3、如果nums[i]这个数字，上次出现过，且，出现的位置和现在距离小于k，可以直接返回true\r代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import \"fmt\" func containsNearbyDuplicate(nums []int, k int) bool { dict := make(map[int]int) for index, value := range nums { if _, exists := dict[value]; exists \u0026\u0026 (index-dict[value]) \u003c= k { return true } dict[value] = index } return false } func main() { nums := []int{1, 2, 3, 1} k := 3 result := containsNearbyDuplicate(nums, k) fmt.Print(result) }   ","description":"","tags":["leetcode"],"title":"219存在重复元素2","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/219%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"},{"categories":["python","werkzeug"],"content":"wsgi.py开讲 wsgi.py封装了一系列方法，现在讲几个自认为是常用的方法。\nget_current_url方法\n（1）作用：\n获取当前请求的URL\r（2）使用案例：\n\t\u003e\u003e\u003e from werkzeug.test import create_environ\r\u003e\u003e\u003e env = create_environ(\"/?param=foo\", \"http://localhost/script\")\r\u003e\u003e\u003e get_current_url(env)\r'http://localhost/script/?param=foo'\r\u003e\u003e\u003e get_current_url(env, root_only=True)\r'http://localhost/script/'\r\u003e\u003e\u003e get_current_url(env, host_only=True)\r'http://localhost/'\r\u003e\u003e\u003e get_current_url(env, strip_querystring=True)\r'http://localhost/script/'\r（3）代码（感觉没有什么内容可说）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  def get_current_url( environ, root_only=False, strip_querystring=False, host_only=False, trusted_hosts=None, ): tmp = [environ[\"wsgi.url_scheme\"], \"://\", get_host(environ, trusted_hosts)] # tmp.append， tmp是list类型，list.append方法，cat指向tmp.append cat = tmp.append if host_only: return uri_to_iri(f\"{''.join(tmp)}/\") cat(url_quote(environ.get(\"SCRIPT_NAME\", \"\").encode(\"latin1\")).rstrip(\"/\")) cat(\"/\") if not root_only: cat(url_quote(environ.get(\"PATH_INFO\", \"\").encode(\"latin1\").lstrip(b\"/\"))) if not strip_querystring: qs = get_query_string(environ) if qs: cat(f\"?{qs}\") # uri_to_iri是把URI地址转换成IRI格式（IRI包含Unicode字符，URI是ASCII字符编码） return uri_to_iri(\"\".join(tmp))   host_is_trusted方法 （1）作用\n检查主机是否可行\r（2）使用案例\nwsgi.py get_host方法159行有用到\r（3）代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  def host_is_trusted(hostname, trusted_list): if not hostname: return False # str -\u003e list if isinstance(trusted_list, str): trusted_list = [trusted_list] def _normalize(hostname): # 把port去除，只获取host if \":\" in hostname: hostname = hostname.rsplit(\":\", 1)[0] return _encode_idna(hostname) try: hostname = _normalize(hostname) except UnicodeError: return False for ref in trusted_list: if ref.startswith(\".\"): ref = ref[1:] suffix_match = True else: suffix_match = False try: ref = _normalize(ref) except UnicodeError: return False if ref == hostname: return True if suffix_match and hostname.endswith(b\".\" + ref): return True return False   get_host方法\n（1）作用\n返回运行环境主机\r（2）使用案例\npass\r（3）代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  def get_host(environ, trusted_hosts=None): if \"HTTP_HOST\" in environ: # HTTP_HOST 在environ rv = environ[\"HTTP_HOST\"] if environ[\"wsgi.url_scheme\"] == \"http\" and rv.endswith(\":80\"): # 获取除:80端口的主机号 rv = rv[:-3] elif environ[\"wsgi.url_scheme\"] == \"https\" and rv.endswith(\":443\"): # 获取除:443端口的主机号 rv = rv[:-4] else: rv = environ[\"SERVER_NAME\"] if (environ[\"wsgi.url_scheme\"], environ[\"SERVER_PORT\"]) not in ( (\"https\", \"443\"), (\"http\", \"80\"), ): # 获取主机+端口 rv += f\":{environ['SERVER_PORT']}\" # 判断是否可信 if trusted_hosts is not None: # 用到了host_is_trusted方法了 if not host_is_trusted(rv, trusted_hosts): from .exceptions import SecurityError raise SecurityError(f'Host \"{rv}\" is not trusted') return rv   get_content_length方法\n（1）作用\n获取来自WSGI环境的内容长度\r（2）使用案例\npass\r（3）代码，实在没什么好讲的\n1 2 3 4 5 6 7 8 9 10 11  def get_content_length(environ): # 块读取，直接返回None if environ.get(\"HTTP_TRANSFER_ENCODING\", \"\") == \"chunked\": return None content_length = environ.get(\"CONTENT_LENGTH\") if content_length is not None: try: return max(0, int(content_length)) except (ValueError, TypeError): pass   get_query_string方法\n（1）作用\n获取对应的URL字段\r（2）使用案例\npass\r（3）代码\n1 2 3 4 5 6 7  def get_query_string(environ): # 获取environ中的QUERY_STRING对应的值，并以latin1格式进行编码 qs = environ.get(\"QUERY_STRING\", \"\").encode(\"latin1\") # QUERY_STRING really should be ascii safe but some browsers # will send us some unicode stuff (I am looking at you IE). # In that case we want to urllib quote it badly. return url_quote(qs, safe=\":\u0026%=+$!*'(),\")   ","description":"","tags":["werkzeug"],"title":"Werkzeug 源码解析(4)","uri":"/posts/werkzeug/werkzeug_sc_4/"},{"categories":["leetcode","数组"],"content":"643. 子数组最大平均数 I 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。\n示例 1:\n输入: [1,12,-5,-6,50,3], k = 4\r输出: 12.75\r解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\r注意:\n1 \u003c= k \u003c= n \u003c= 30,000。\r所给数据范围 [-10,000，10,000]。\r思路\n滑动窗口\r1、维护一个长度为k的窗口，和窗口当前的和sum\r2、遍历nums，每碰到一个新元素时，都要相应的从sum中减去退出窗口的值，加上新加入窗口的值\r3、看看当然的sum是不是比以往的都大，是的话，记录到max里面去\r4、最后返回max/k就好了\r代码\npackage main\rimport \"fmt\"\rfunc findMaxAverage(nums []int, k int) float64 {\rvar sum, max int\rfor i := 0; i \u003c k; i++ {\rsum += nums[i]\r}\rmax = sum\rfor i := k; i \u003c len(nums); i++ {\rsum += nums[i] - nums[i-k]\rif sum \u003e max {\rmax = sum\r}\r}\rreturn float64(max) / float64(k)\r}\rfunc main() {\rnums := []int{1, 12, -5, -6, 50, 3}\rk := 4\rresult := findMaxAverage(nums, k)\rfmt.Print(result)\r}\r","description":"","tags":["leetcode"],"title":"643子数组最大平均数","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/643%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/"},{"categories":["leetcode","数组"],"content":"1346. 检查整数及其两倍数是否存在 给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。\n更正式地，检查是否存在两个下标 i 和 j 满足：\ni != j\r0 \u003c= i, j \u003c arr.length\rarr[i] == 2 * arr[j]\r示例 1：\n输入：arr = [10,2,5,3]\r输出：true\r解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。\r示例 2：\n输入：arr = [7,1,14,11]\r输出：true\r解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。\r示例 3：\n输入：arr = [3,1,7,11]\r输出：false\r解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。\r提示：\n2 \u003c= arr.length \u003c= 500\r-10^3 \u003c= arr[i] \u003c= 10^3\r","description":"","tags":["leetcode"],"title":"1346检查整数及其两倍数是否存在","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/1346%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"},{"categories":["leetcode","数组"],"content":"605. 种花问题 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。\n示例 1:\n输入: flowerbed = [1,0,0,0,1], n = 1\r输出: True\r示例 2:\n输入: flowerbed = [1,0,0,0,1], n = 2\r输出: False\r注意:\n数组内已种好的花不会违反种植规则。\r输入的数组长度范围为 [1, 20000]。\rn 是非负整数，且不会超过输入数组的大小。\r思路\n遍历数组：\r（1）对第一个元素，本身是0右边是0即可种花\r（2）对于中间元素，本身是0，左右两边都是0，可以种花\r（3）对于最后一个元素，本身是0，左边是0，可以种花\r代码\npackage main\rimport \"fmt\"\rfunc canPlaceFlowers(flowerbed []int, n int) bool {\rlength := len(flowerbed)\rvar count int\rfor i, value := range flowerbed {\rif value == 0 \u0026\u0026 (i == 0 || flowerbed[i-1] == 0) \u0026\u0026 (i == length-1 || flowerbed[i+1] == 0) {\rflowerbed[i] = 1\rcount += 1\r}\r}\rreturn count \u003e= n\r}\rfunc main() {\rflowerbed := []int{1, 0, 0, 0, 1}\rn := 1\rresult := canPlaceFlowers(flowerbed, n)\rfmt.Print(result)\r}\r","description":"","tags":["leetcode"],"title":"605种花问题","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/605%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"},{"categories":["leetcode","数组"],"content":"167. 两数之和 II - 输入有序数组 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n说明:\n返回的下标值（index1 和 index2）不是从零开始的。\r你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\r示例:\n输入: numbers = [2, 7, 11, 15], target = 9\r输出: [1,2]\r解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\r思路\n双指针\r初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。\r代码\npackage main\rimport \"fmt\"\rfunc twoSum(numbers []int, target int) []int {\rlength := len(numbers)\rvar right int = length - 1\rvar left int = 0\rfor left \u003c right {\rsum := numbers[left] + numbers[right]\rif sum == target {\rbreak\r} else if sum \u003c target {\rleft += 1\r} else {\rright -= 1\r}\r}\rreturn []int{left + 1, right + 1}\r}\rfunc main() {\rnumbers := []int{2, 7, 11, 15}\rtarget := 9\rresult := twoSum(numbers, target)\rfmt.Print(result)\r}\r","description":"","tags":["leetcode"],"title":"167两数之和2","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2/"},{"categories":["leetcode","数组"],"content":"118. 杨辉三角 给定一个非负整数 *numRows，*生成杨辉三角的前 numRows 行。\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n示例:\n输入: 5\r输出:\r[\r[1],\r[1,1],\r[1,2,1],\r[1,3,3,1],\r[1,4,6,4,1]\r]\r思路\n1.杨辉三角每层的i的值都是上层决定的m[i]+m[i+1]的和\r2 第一个元素需要特殊处理一下，我们可以在每层头部增加一个数字是0的元素\r","description":"","tags":["leetcode"],"title":"118杨辉三角","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/118%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"},{"categories":["leetcode","数组"],"content":"665. 非递减数列 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。\n我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 \u003c= i \u003c= n-2)，总满足 nums[i] \u003c= nums[i + 1]。\n示例 1:\n输入: nums = [4,2,3]\r输出: true\r解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。\r示例 2:\n输入: nums = [4,2,1]\r输出: false\r解释: 你不能在只改变一个元素的情况下将其变为非递减数列。\r说明：\n1 \u003c= n \u003c= 10 ^ 4\r- 10 ^ 5 \u003c= nums[i] \u003c= 10 ^ 5\r解题思路\n遍历数组，初始count = 0，如果当前元素值比它下一个元素值大，则count += 1，当count \u003e 1时，直接返回false。\r另外，在遍历数组的过程中，如果遇到 “特殊情况”，可以直接返回false；当循环正常结束则返回true\r代码\nfunc checkPossibility(nums []int) bool {\rif len(nums) == 1 {\rreturn true\r}\rvar count int = 0\rfor index, value := range nums {\rif index == 0 {\rcontinue\r}\rif value \u003c nums[index-1] {\rcount += 1\r}\rif count \u003e 1 {\rreturn false\r}\r}\rreturn true\r}\r但是！！！\n提交后，运行过程\r输入:\r[3,4,2,3]\r输出\rtrue\r预期结果\rfalse\r所以要考虑特殊情况\n现在就需要nums[i-2] \u003c= nums[i-1] \u003e nums[i] \u003c= nums[i+1]这个条件了\r最终代码\nfunc checkPossibility(nums []int) bool {\rif len(nums) \u003c= 2 {\rreturn true\r}\rvar count int = 0\rfor index, value := range nums {\rif index == 0 {\rcontinue\r}\rif value \u003c nums[index-1] {\rcount += 1\rif nums[index-1] \u003e nums[index+1] \u0026\u0026 nums[index-2] \u003e value {\rreturn false\r}\r}\rif count \u003e 1 {\rreturn false\r}\r}\rreturn true\r}\r","description":"","tags":["leetcode"],"title":"665非递减数列","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/665%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"},{"categories":["leetcode","数组"],"content":"1160. 拼写单词 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n示例 1：\n输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\r输出：6\r解释： 可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。\r示例 2：\n输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\r输出：10\r解释：\r可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。\r提示：\n1 \u003c= words.length \u003c= 1000\r1 \u003c= words[i].length, chars.length \u003c= 100\r所有字符串中都仅包含小写英文字母\r思路\n对于一个单词 word，只要其中的每个字母的数量都不大于 chars 中对应的字母的数量，那么就可以用 chars 中的字母拼写出 word。\r代码\nfunc countCharacters(words []string, chars string) int {\rcount := 0\rfor _, word := range words {\rflag := true\rfor _, value := range word {\rif flag \u0026\u0026 strings.Count(word, string(value)) \u003e strings.Count(chars, string(value)) {\rflag = false\r}\r}\rif flag {\rcount += len(word)\r}\r}\rreturn count\r}\r","description":"","tags":["leetcode"],"title":"1160拼写单词","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/1160%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"},{"categories":["leetcode","数组"],"content":"674. 最长连续递增序列 给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。\n示例 1:\n输入: [1,3,5,4,7]\r输出: 3\r解释: 最长连续递增序列是 [1,3,5], 长度为3。\r尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2:\n输入: [2,2,2,2,2]\r输出: 1\r解释: 最长连续递增序列是 [2], 长度为1。\r注意：数组长度不会超过10000。\n思路\n滑动窗口...\r代码\nfunc findLengthOfLCIS(nums []int) int {\rlength := len(nums)\rif length \u003c= 1 {\rreturn length\r}\rvar count int = 1\rvar max_length int = 1\rfor index, value := range nums {\rif index == 0 {\rcontinue\r}\rif value \u003e nums[index-1] {\rcount += 1\r} else {\rindex += 1\rcount = 1\r}\rif max_length \u003c count {\rmax_length = count\r}\r}\rreturn max_length\r}\r","description":"","tags":["leetcode"],"title":"674最长连续递增序列","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/674%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"},{"categories":["leetcode","数组"],"content":"剑指 Offer 53 - II. 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n示例 1:\n输入: [0,1,3]\r输出: 2\r示例 2:\n输入: [0,1,2,3,4,5,6,7,9]\r输出: 8\r限制：\n1 \u003c= 数组长度 \u003c= 10000\r解题思路 思路一：依次遍历\n(1) 从头开始依次遍历数组每一位元素。\r(2) 找到第一位值不等于索引的元素，则缺失值为当前索引。\r代码\npackage main\rimport \"fmt\"\rfunc missingNumber(nums []int) int {\rfor index, value := range nums {\rif index == 0 {\rcontinue\r}\rif (value - nums[index-1]) \u003e 1 {\rreturn value - 1\r}\r}\rreturn 0\r}\rfunc main() {\rnums := []int{0, 1, 3}\rnumber := missingNumber(nums)\rfmt.Println(number)\r}\r思路二：二分查找\n(1) 根据二分查找找到第一个元素值不等于索引的索引就是缺失值。\r(2) 元素值都和索引相等则缺失值等于数组长度。\rclass Solution {\rpublic int missingNumber(int[] nums) {\r// 定义左右指针分别指向数组元素值的边界。\rint left = 0, right = nums.length;\rwhile (left \u003c right) {\r// 找到中间值。\rint mid = left + (right - left) / 2;\rif (nums[mid] \u003e mid) {\r// 数组索引值与索引不对应，则缺失值在左侧。\rright = mid;\r} else {\r// 数组索引值等于索引，则缺失值在右侧。\rleft = mid + 1;\r}\r}\rreturn right;\r}\r}\r","description":"","tags":["leetcode"],"title":"Offer53 0~n-1中缺失的数字","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/offer530~n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["算法","桶排序"],"content":"介绍\n​\t桶排序（Bucket sort），是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。\n桶排序并不是比较排序，他不受到下限的影响。\n步骤\n桶排序以下列程序进行：\n1.设置一个定量的数组当作空桶子。\r2.寻访序列，并且把项目一个一个放到对应的桶子去。\r3.对每个不是空的桶子进行排序。\r4.从不是空的桶子里把项目再放回原来的序列中。\r说明\n假设有些整数，范围在1-100之间。现在有n=10的序列要进行排序\nOriginal array\r+-------------------------------------------------+\r| 6 | 28 | 96 | 14 | 74 | 37 | 9 | 71 | 91 | 36 |\r+-------------------------------------------------+\r  Create：创建一定数量的空桶，这里我们建立与原始数组长度相等的空桶（10个）。每个空桶对应区间为0~9、10~19、20~29、30~39、40~49、50~59、60~69、70~79、80~89、90-99的区间\nBucket array\r+-------------------------------------------------+\r| | | | | | | | | | |\r+-------------------------------------------------+\r^ ^\r| |\r| |\r| holds values in range 11 to 20\rholds values in range 1 to 10\r  Scout：将原始序列中的元素，放入到对应的桶里\nBucket array\r6,9 14 28 37,36 74,71 96,91\r| | | | | |\r+-v----v----v----v-------------------v---------v--+\r| | | | | | | | | | |\r+-------------------------------------------------+\r  Sort：排序所有非空桶中的元素，桶内排序可以采用任意排序算法\nBucket array\rsort sort sort sort sort sort\r--- -- -- ----- ----- -----\r6,9 14 28 36,37 71,74 91,96\r| | | | | |\r+-v----v----v----v-------------------v---------v--+\r| | | | | | | | | | |\r+-------------------------------------------------+\r  Gather：排序完成后，再把所有桶中元素依序放回原始序列\nOriginal array\r+-------------------------------------------------+\r| 6 | 9 | 14 | 28 | 36 | 37 | 71 | 74 | 91 | 96 |\r+-------------------------------------------------+\r  ","description":"","tags":["算法"],"title":"桶排序","uri":"/posts/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["golang"],"content":"GoLand 2020版破解教程\n本教程适用于GoLand 2020 1.4版本，其他版本理论上是一致的。\nGoLand下载地址\n下载地址\n激活步骤\n  下载GoLand\n  下载破解补丁文件，jetbrains-agent-latest.zip破解补丁下载地址\n  安装GoLand，正常安装即可\n  进入激活界面，选择免费试用（Evaluate for free）\n  用GoLand随便打开一个已存在的项目（或者创建一个）\n  拖入zip文件\n  按箭头操作即可\n  查看是否激活成功\n点击Help --\u003e About\r","description":"","tags":["go"],"title":"Goland 2020版破解","uri":"/posts/golang/goland2020%E7%89%88%E7%A0%B4%E8%A7%A3/"},{"categories":["leetcode","数组"],"content":"1051. 高度检查器 学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。\n请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。\n注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。\n示例：\n输入：heights = [1,1,4,2,1,3]\r输出：3 解释：\r当前数组：[1,1,4,2,1,3]\r目标数组：[1,1,1,2,3,4]\r在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。\r在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。\r在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。\r示例 2：**\n输入：heights = [5,1,2,3,4]\r输出：5\r示例 3：\n输入：heights = [1,2,3,4,5]\r输出：0\r提示：\n1 \u003c= heights.length \u003c= 100\r1 \u003c= heights[i] \u003c= 100\r解题思路\n首先我们其实并不关心排序后得到的结果，我们想知道的只是在该位置上，与最小的值是否一致\r1.先排序\r2.然后遍历，比较对应下标的元素是否相同，不同加1\r代码\npackage main\rimport (\r\"fmt\"\r\"sort\"\r)\rfunc heightChecker(heights []int) int {\rlength := len(heights)\r// todo: 切片和数组的本质区别是什么\r// todo: 有上述疑问，是因为 var copy_heights []int 会报错！！\rvar copy_heights = make([]int, length)\rcopy(copy_heights, heights)\rsort.Ints(heights)\rvar count int\rfor index, value := range heights {\rif copy_heights[index] != value {\rcount += 1\r}\r}\rreturn count\r}\rfunc main() {\rvar heights = []int{5, 1, 2, 3, 4}\rcount := heightChecker(heights)\rfmt.Println(count)\r}\r","description":"","tags":["leetcode"],"title":"1051高度检查器","uri":"/posts/leetcode/%E6%95%B0%E7%BB%84/1051%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。\n示例：\n给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 k = 2.\r返回链表 4-\u003e5.\r解题思路\n1.快指针和慢指针相差k\r2.快指针到达链尾，慢指针所指方向就是倒数第k个链表\r代码\nclass Solution(object):\rdef getKthFromEnd(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: ListNode\r\"\"\"\rfast = head\rfor i in range(k):\rfast = fast.next\rcur = head\rwhile fast:\rcur = cur.next\rfast = fast.next\rreturn cur\r解题思路\n1.获取链表长度\r2.开始遍历（链表长度-k）次数\r代码\nclass Solution(object):\rdef getKthFromEnd(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: ListNode\r\"\"\"\rlength = 0\rcur = head\rwhile cur:\rlength += 1\rcur = cur.next\rcur = head\rindex = length - k\rfor i in range(index):\rcur = cur.next\rreturn cur\r","description":"leetcode，Offer22 链表中倒数第K个节点","tags":["leetcode"],"title":"Offer22链表中倒数第K个节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"141. 环形链表 给定一个链表，判断链表中是否有环。\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\r输出：true\r解释：链表中有一个环，其尾部连接到第二个节点。\r示例 2：\n输入：head = [1,2], pos = 0\r输出：true\r解释：链表中有一个环，其尾部连接到第一个节点。\r示例 3：\n输入：head = [1], pos = -1\r输出：false\r解释：链表中没有环。\r进阶：\n你能用 O(1)（即，常量）内存解决此问题吗？\n 思路\n当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。\r根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。\r代码\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/22 22:19\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 141.py\r# @Software : PyCharm # -*- coding: utf-8 -*-\r# @Time : 2020/7/16 22:27\r# @Author : affectalways\r# @Site :\r# @Contact : affectalways@gmail.com\r# @File : 0201.py\r# @Software : PyCharm\r# Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef hasCycle(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: bool\r\"\"\"\rif not head:\rreturn False\rfast = head.next\rslow = head\rwhile fast != slow:\rif fast is None or fast.next is None:\rreturn False\rslow = slow.next\rfast = fast.next.next\rreturn True\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 3, 2, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.hasCycle(head)\rtraversal_link(result)\r","description":"leetcode，141 环形链表","tags":["leetcode"],"title":"141环形链表","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["python"],"content":"郑重声明：本篇文章非原创，摘自https://www.zlovezl.cn/articles/instagram-pycon-2017/\nPyCon 简介 PyCon 是全世界最大的以 Python 编程语言 为主题的技术大会。大会由 Python 社区组织，每年举办一次。在大会上，来自世界各地的 Python 用户与核心开发者齐聚一堂，共同分享 Python 世界的新鲜事、Python 语言的应用案例、使用技巧等等内容。\nInstagram 简介 Instagram 是一款移动端的照片与视频分享软件，由 Kevin Systrom 和 Mike Krieger 在 2010 年创办。Instagram 在发布后开始快速流行。于 2012 年被 Facebook 以 10 亿美元的价格收购。而当时 Instagram 的员工仅有区区 13 名。\n如今，Instagram 的总注册用户达到 30 亿，月活用户超过 7 亿 （作为对比，微信最新披露的月活跃用户为 9.38 亿）。而令人吃惊的是，这么高的访问量背后，竟完全是由以速度慢著称的 Python + Django 支撑。\n在 Python 2017 上，Instagram 的工程师们带来了一个有关 Python 在 Instagram 的主题演讲，同时还分享了 Instagram 如何将整个项目运行环境升级到 Python 3 的故事。\n本文为该次演讲的内容摘要。\nPython @Instagram 为什么选择 Python 和 Django Instagram 选择 Django 的原因很简单，Instagram 的两位创始人 (Kevin Systrom and Mike Krieger) 都是产品经理出身。在他们想要创造 Instagram 时，Django 是他们所知道的最稳定和成熟的技术之一。\n时至今日，即使已经拥有超过 30 亿的注册用户。Instagram 仍然是 Python 和 Django 的重度使用者。Instagram 的工程师 Hui Ding 说到： 『一直到用户 ID 已经超过了 32bit int 的限额（约为 20 亿），Django 本身仍然没有成为我们的瓶颈所在。』\n不过，除了使用 Django 的原生功能外，Instagram 还对 Django 做了很多定制化工作：\n  扩展 Django Models 使其支持 Sharding （一种数据库分片技术），Instagram Engneering 博客专门为这件事情写过一篇博客，可参阅：Sharding \u0026 IDs at Instagram\n  手动关闭 GC（垃圾回收）来提升 Python 内存管理效率，他们同样也写过一篇博客来说明这件事情：Dismissing Python Garbage Collection at Instagram\n  在位于不同地理位置的多个数据中心部署整套系统\n  Python 语言的优势所在 Instagram 的联合创始人 Mike Krieger 说过： 『我们的用户根本不关心 Instagram 使用了哪种关系数据库，他们当然也不关心 Instagram 是用什么编程语言开发的。』\n所以，Python 这种 简单 而且 实用至上 的编程语言最终赢得了 Instagram 的青睐。他们认为，使用 Python 这种简单的语言有助于塑造 Instagram 的工程师文化，那就是：\n 专注于定位问题、解决问题 - 而不是工具本身的各种花花绿绿的特性 使用那些经过市场验证过的成熟技术方案 - 而不用被工具本身的问题所烦扰 用户至上：专注于用户所能看到的新特性，为用户带去价值  但是，即使使用 Python 语言有这么多好处，它还是很慢，不是吗？\n不过，这对于 Instagram 不是问题，因为他们认为：『Instagram 的最大瓶颈在于开发效率，而不是代码的执行效率』\n At Instagram, our bottleneck is development velocity, not pure code execution.\n 所以，最终的结论是：你完全可以使用 Python 语言来实现一个超过几十亿用户使用的产品，而根本不用担心语言或框架本身的性能瓶颈。\n如何提升运行效率 但是，即使是选用了拥有诸多好处的 Python 和 Django。在 Instagram 的用户数迅速增长的过程中，性能问题还是出现了：服务器数量的增长率已经慢慢的超过了用户增长率。Instagram 是怎么应对这个问题的呢？\n他们使用了这些手段来缓解性能问题：\n 开发工具来帮助调优：Instagram 开发了很多涵盖各个层面的工具，来帮助他们进行性能调优以及找到性能瓶颈。 使用 C/C++ 来重写部分组件：把那些稳定而且对性能最敏感的组件，使用 C 或 C++ 来重写，比如访问 memcache 的 library。 使用 Cython：Cython 也是他们用来提升 Python 效率的法宝之一。  除了上面这些手段，他们还在探索异步 IO 以及新的 Python Runtime 所能带来的性能可能性。\n升级到 Python 3 在相当长的一段时间，Instagram 都跑在 Python 2.7 + Django 1.3 的组合之上。在这个已经落后社区很多年的环境上，他们的工程师们还打了非常非常多的小 patch。难道他们要被永远卡在这个版本上吗？\n所以，在经过一系列的讨论后，他们最终做出一个重大的决定：升级到 Python 3！！\n事实上，Instagram 目前已经完成了将运行环境迁移到 Python 3 的工作 - 他们的整套服务已经在 Python 3 上跑了好几个月了。那么他们是怎么做到的呢？接下来便是由 Instagram 工程师 Lisa guo 带来的 Instagram 如何迁移到 Python 3 的故事。\nInstagram 升级到 Python 3 的故事 为什么要升级到 Python 3 对于 Instagram 来说，下面这些因素是推动他们将运行环境迁移到 Python 3 的主要原因：\n1. 新特性：类型注解 Type Annotations 看看下面这段代码：\ndef compose_from_max_id(max_id):\r'''@param str max_id'''\r图中函数的 max_id 参数究竟是什么类型呢？int？tuple？或是 list? 等等，函数文档里面说它是 str 类型。\n但随着时间推移，万一这个参数的类型发生变化了呢？如果某位粗心的工程师修改代码的同时忘了更新文档，那就会给函数的使用者带来很大麻烦，最终还不如没有注释呢。\n2. 性能 Instagram 的整个 Django Stack 都跑在 uwsgi 之上，全部使用了同步的网络 IO。这意味着同一个 uwsgi 进程在同一时间只能接收并处理一个请求。这让如何调优每台机器上应该运行的 uwsgi 进程数成了一个麻烦事：\n为了更好利用 CPU，使用更多的进程数？但那样会消耗大量的内存。而过少的进程数量又会导致 CPU 不能被充分利用。\n为此，他们决定跳过 Python 2 中哪些蹩脚的异步 IO 实现 （可怜的 gevent、tornado、twisted 众），直接升级到 Python 3，去探索标准库中的 asyncio 模块所能带来的可能性。\n3. 社区 因为 Python 社区已经停止了对 Python 2 的支持。如果把整个运行环境升级到 Python 3，Instagram 的工程师们就能和 Python 社区走的更近，可以更好的把他们的工作回馈给社区。\n确定迁移方案 在 Instagram，进行 Python 3 的迁移需要必须满足两个前提条件：\n 不停机，不能有任何的服务因此不可用 不能影响产品新特性的开发  但是，在 Instagram 的开发环境中，要满足上面这两点来完成迁移到 Python 3.6 这种庞大的工程是非常困难的。\n基于主分支的开发流程 即便使用了以多分支功能著称的 git，Instagram 所有的开发工作都是主要在 master 分支上进行的，Instagram 所奉行的开发哲学是：『不管是多大的新特性或代码重构，都应该拆解成较小的 Commit 来进行。』\n那些被合并进 master 分支的代码，都将在一个小时内被发布到线上环境。**而这样的发布过程每天将会发生上百次。**在这么频繁的发布频率下，如何在满足之前的那两个前提下来完成迁移变得尤其困难。\n被弃用的迁移方案 创建一个新分支\n很多人在处理这类问题时，第一个蹦进脑子的想法就是： 『让我们创建一个分支，当我们开发完后，再把分支合并进来』\n但在 Instagram 这么高的迭代频率上，使用一个独立分支并不是好主意：\n Instagram 的 Codebase 每天都在频繁更新，在开发 Python 3 分支的过程中，让新分支与现有 master 分支保持同步开销极大，同时极易出错 最终将 Python 3 分支这个改动非常多的分支合并回 Master 拥有非常高的风险 只有少数几个工程师在 Python 3 分支上专职负责升级工作，其他想帮助迁移工作的工程师无法参与进来  挨个替换接口\n还有一个方案就是，挨个替换 Instagram 的 API 接口。但是 Instagram 的不同接口共享着很多通用模块。这个方案要实施起来也非常困难。\n微服务\n还有一个方案就是将 Instagram 改造成微服务架构。通过将那些通用模块重写成 Python 3 版本的微服务来一步步完成迁移工作。\n但是这个方案需要重新组织海量的代码。同时，当发生在进程内的函数调用变成 RPC 后 ，整个站点的延迟会变大。此外，更多的微服务也会引入更高的部署复杂度。\n所以，既然 Instagram 的开发哲学是：小步前进，快速迭代。他们最终决定的方案是：一步一步来，最终让 master 分支上的代码同时兼容 Python 2 和 Python 3 。\n开始迁移工作 既然要让整个 codebase 同时兼容 Python 2 和 Python 3，那么首先要符合这点的就是那些被大量使用的第三方 package。针对第三方 package，Instagram 做到了下面几点：\n 拒绝引入所有不兼容 Python 3 的新 package 去掉所有不再使用的 package 替换那些不兼容 Python 3 的 package  在代码的迁移过程中，他们使用了工具 modernize 来帮助他们。\n使用 modernize 时，有一个小技巧：每次修复多个文件的一个兼容问题，而不是一下修复一个文件中的多个兼容问题。 这样可以让 Code Review 过程简单很多，因为 Reviewer 每次只需要关注一个问题。\n使用单元测试来帮助迁移 对于 Python 这种灵活性极强的动态语言来说，除了真正去执行代码外，几乎没有其他比较好的检查代码错误的手段。\n前面提到，Instagram 所有被合并到 master 的代码提交会在一个小时内上线到线上环境，但这不是没有前提条件的。在上线前，所有的提交都需要通过成千上万个单元测试。\n于是，他们开始加入 Python 3 来执行所有的单元测试。一开始，只有极少数的单元测试能够在 Python 3 环境下通过，但随着 Instagram 的工程师们不断的修复那些失败的单元测试，最终所有的单元测试都可以在 Python 3 环境下成功执行。\n单元测试的局限性 但是，单元测试也是有局限性的：\n Instagram 的单元测试没有做到 100% 的代码覆盖率 很多第三方模块都使用了 mock 技术，而 mock 的行为与真实的线上服务可能会有所不同  所以，当所有的单元测试都被修复后，他们开始在线上正式使用 Python 3 来运行服务。\n这个过程并不是一蹴而就的。首先，所有的 Instagram 工程师开始访问到这些使用 Python 3 来执行的新服务，然后是 Facebook 的所有雇员，随后是 0.1%、20% 的用户，最终 Python 3 覆盖到了所有的 Instagram 用户。\n迁移过程的技术问题 Instagram 在迁移到 Python 3 时碰到很多问题，下面是最典型的几个：\nUnicode 相关的字符串问题 Python 3 相比 Python 2 最大的改动之一，就是在语言内部对 unicode 的处理。\n在 Python 2 中，文本类型 （也就是 unicode） 和二进制类型 （也就是 str） 的边界非常模糊。很多函数的参数既可以是文本，也可以是二进制。但是在 Python 3 中，文本类型和二进制类型的字符串被完全的区分开了。\n于是，下面这段在 Python 2 下可以正常运行的代码在 Python 3 下就会报错：\nmymac = hmac.new('abc')\rTypeError: key: expected bytes or bytearray, but got 'str'\r解决办法其实很简单，只要加上判断：如果 value 是文本类型，就将其转换为二进制。如下所示：\nvalue = 'abc'\rif isinstance(value, six.text_type):\rvalue = value.encode(encoding='utf-8')\rmymac = hmac.new(value)\r但是，在整个代码库中，像上面这样的情况非常多。作为开发人员，如果需要在调用每个函数时都要想想： 这里到底是应该编码成二进制，或者是解码成文本呢？ 将会是非常大的负担。\n于是 Instagram 封装了一些名为 ensure_str()、ensure_binary()、ensure_text() 的帮助函数，开发人员只需对那些不确定类型的字符串，使用这些帮助函数先做一次转换就好。\nmymac = hmac.new(ensure_binary('abc'))\r不同 Python 版本的 pickle 差异 Instagram 的代码中大量使用了 pickle。比如用它序列化某个对象，然后将其存储在 memcache 中。如下面的代码所示：\nmemcache_data = pickle.dumps(data, pickle.HIGHEST_PROTOCOL)\rdata = pickle.loads(memcache_data)\r问题在于，Python 2 与 Python 3 的 pickle 模块是有差别的。\n如果上文的第一行代码，刚好是由 Python 3 运行的服务进行序列化后存入 memcache。而反序列化的过程却是由 Python 2 进行，那代码运行时就会出现下面的错误：\nValueError: unsupported pickle protocol: 4\r这是由于在 Python 3 中，pickle.HIGHEST_PROTOCOL 的值为 4，而 Python 2 中的的 pickle 最高支持的版本号却是 2。那么如何解决这个问题呢？\nInstagram 最终选择让 Python 2 和 Python 3 使用完全不同的 namespace 来访问 memcache。通过将二者的数据读写完全隔开来解决这个问题。\n迭代器 在 Python 3 中，很多内置函数被修改成了只返成迭代器 Iterator：\nmap()\rfilter()\rdict.items()\r迭代器有诸多好处，最大的好处就是，使用迭代器不需要一次性分配大量内存，所以它的内存效率比较高。\n但是迭代器有一个天然的特点，当你对某个迭代器做了一次迭代，访问完它的内容后，就没法再次访问那些内容了。迭代器中的所有内容都只能被访问一次。\n在 Instagram 的 Python 3 迁移过程中，就因为迭代器的这个特性被坑了一次，看看下面这段代码：\nCYTHON_SOURCES = [a.pyx, b.pyx, c.pyx]\rbuilds = map(BuildProcess, CYTHON_SOURCES)\rwhile any(not build.done() for build in builds):\rpending = [build for build in builds if not build.started()]\r\u003cdo some work\u003e\r这段代码的用处是挨个编译 Cython 源文件。当他们把运行环境切换到 Python 3 后，一个奇怪的问题出现了：**CYTHON_SOURCES 中的第一个文件永远都被跳过了编译。**为什么呢？\n这都是迭代器的锅。在 Python 3 中，map() 函数不再返回整个 list，而是返回一个迭代器。\n于是，当第二行代码生成 builds 这个迭代器后，第三行代码的 while 循环迭代了 builds，刚好取出了第一个元素。于是之后的 pending 对象便里面永远少了那第一个元素。\n这个问题解决起来也挺简单的，你只要手动的吧 builds 转换成 list 就可以了：\nbuilds = list(map(BuildProcess, CYTHON_SOURCES))\r但是这类 bug 非常难定位到。如果用户的 feeds 里面永远少了那最新的第一条，用户很少会注意到。\n字典的顺序 看看下面这段代码：\n\u003e\u003e\u003e testdict = {'a': 1, 'b': 2, 'c': 3}\r\u003e\u003e\u003e json.dumps(testdict)\r它会输出什么结果呢？\n# Python2\r'{\"a\": 1, \"c\": 3, \"b\": 2}'\r# Python 3.5.1\r'{\"c\": 3, \"b\": 2, \"a\": 1}' # or\r'{\"c\": 3, \"a\": 1, \"b\": 2}'\r# Python 3.6\r'{\"a\": 1, \"b\": 2, \"c\": 3}'\r在不同的 Python 版本下，这个 json dumps 的结果是完全不一样的。甚至在 3.5.1 中，它会完全随机的返回两个不同的结果。Instagram 有一段判断配置文件是否发生变动的模块，就是因为这个原因出了问题。\n这个问题的解决办法是，在调用 json.dumps 传入 sort_keys=True 参数：\n\u003e\u003e\u003e json.dumps(testdict, sort_keys=True)\r'{\"a\": 1, \"b\": 2, \"c\": 3}'\r迁移到 Python 3.6 后的性能提升 当 Instagram 解决了这些奇奇怪怪的版本差异问题后，还有一个巨大的谜题困扰着他们：性能问题。\n在 Instagram，他们使用两个主要指标来衡量他们的服务性能：\n 每次请求产生的 CPU 指令数（越低越好） 每秒能够处理的请求数（越高越好）  所以，当所有的迁移工作完成后，他们非常惊喜的发现：第一个性能指标，每次请求产生的 CPU 指令数居然足足下降了 12% ！！！\n但是，按理说第二个指标 - 每秒请求数也应该获得接近 12% 的提升。不过最后的变化却是 0%。究竟是出了什么问题呢？\n他们最终定位到，是由于不同 Python 版本下的内存优化配置不同，导致 CPU 指令数下降带来的性能提升被抵消了。那为什么不同 Python 版本下的内存优化配置会不一样呢？\n这是他们用来检查 uwsgi 配置的代码：\nif uwsgi.opt.get('optimize_mem', None) == 'True':\roptimize_mem()\r注意到那段 ... ... == 'True' 了吗？在 Python 3 中，这个条件判断总是不会被满足。问题就在于 unicode。在将代码中的 'True' 换成 b'True'（也就是将文本类型换成二进制，这种判断在 Python 2 中完全不区分的）后，问题解决了。\n所以，最终因为加上了一个小小的字母 ‘b’，程序的整体性能提升了 12%。\n结论 在今年二月份，Instagram 的后端代码的运行环境完全切换到了 Python 3 下：\n当所有的代码都都迁移到 Python 3 运行环境后：\n 节约了 12% 的整体 CPU 使用率（Django/uwsgi） 节约了 30% 的内存使用（celery）  同时，在整个迁移期间，Instagram 的月活用户经历了从 4 亿到 6亿 的巨大增长。产品也发布了评论过滤、直播等非常多新功能。\n那么，那几个最开始驱动他们迁移到 Python 3 的目的呢？\n 类型注解：Instagram 的整个 codebase 里已经有 2% 的代码添加上了类型注解，同时他们还开发了一些工具来辅助开发者添加类型提示 asyncio：他们在单个接口中利用 asynio 平行的去做多件事情，最终降低了 20-30% 的请求延迟。 社区：他们与 Intel 的工程师联合，帮助他们更好的对 CPU 利用率进行调优。同时还开发了很多新的工具，帮助他们进行性能调优  Instagram 带给我们的启示 Instagram 的演讲视频时间不长，但是内容很丰富，在编写此文前，我完全没有想到最终的文章会这么长。\n那么，Instagram 的视频可以给我们哪些启示呢？\n Python + Django 的组合完全可以负载用户数以 10 亿记的服务，如果你正准备开始一个项目，放心使用 Python 吧！ 完善的单元测试对于复杂项目是非常有必要的。如果没有那『成千上万的单元测试』。很难想象 Instagram 的迁移项目可以成功进行下去。 开发者和同事也是你的产品用户，利用好他们。用他们为你的新特性发布前多一道测试。 完全基于主分支的开发流程，可以给你更快的迭代速度。前提是拥有完善的单元测试和持续部署流程。 Python 3 是大势所趋，如果你正准备开始一个新项目，无需迟疑，拥抱 Python 3 吧！  ","description":"python，Instagram在PyCon2017的演讲摘要","tags":["python"],"title":"Instagram在PyCon2017的演讲摘要","uri":"/posts/python/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 18. 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n返回删除后的链表的头节点。\n**注意：**此题对比原题有改动\n示例 1:\n输入: head = [4,5,1,9], val = 5\r输出: [4,1,9]\r解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9.\r示例 2:\n输入: head = [4,5,1,9], val = 1\r输出: [4,5,9]\r解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9.\r说明：\n 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点  思路： 删除值为 val 的节点可分为两步：定位节点、修改引用。\n定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。 修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。\n算法流程：\n1.特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。\r2.初始化： pre = head , cur = head.next 。\r3.定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。\r4.保存当前节点索引，即 pre = cur 。\r5.遍历下一节点，即 cur = cur.next 。\r6.删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next 。（若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。\r7.返回值： 返回链表头部节点 head 即可。\r# -*- coding: utf-8 -*-\r# @Time : 2020/7/18 23:44\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : offer18.py\r# @Software : PyCharm class ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef deleteNode(self, head, val):\r\"\"\"\r:type head: ListNode\r:type val: int\r:rtype: ListNode\r\"\"\"\rif head.val == val:\rreturn head.next\rpre, cur = head, head.next\rwhile cur and cur.val != val:\rpre, cur = cur, cur.next\rif cur:\rpre.next = cur.next\rreturn head\rdef create_link(tmp):\rcur = head = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([4, 5, 1, 9])\rtraversal_link(head)\r","description":"leetcode，Offer18删除链表的节点","tags":["leetcode"],"title":"Offer18删除链表的节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1：\n输入：[1,2,3,4,5]\r输出：此列表中的结点 3 (序列化形式：[3,4,5])\r返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\r注意，我们返回了一个 ListNode 类型的对象 ans，这样：\rans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\r示例 2：\n输入：[1,2,3,4,5,6]\r输出：此列表中的结点 4 (序列化形式：[4,5,6])\r由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\r提示：\n 给定链表的结点数介于 1 和 100 之间。  思路\n方法一：数组\n链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。\r方法二：单指针法\n我们可以对方法一进行空间优化，省去数组 A。\r我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。\r方法三：快慢指针法\n\r我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。\r代码\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/16 23:03\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 876.py\r# @Software : PyCharm # Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef middleNode(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rslow = fast = head\rwhile fast and fast.next:\rslow = slow.next\rfast = fast.next.next\rreturn slow\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 4, 5])\rsolution = Solution()\rnode = solution.middleNode(head)\rprint(node.val)\r","description":"leetcode，876 链表的中间结点","tags":["leetcode"],"title":"876链表的中间结点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/876%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.01. 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n示例1:\n 输入：[1, 2, 3, 3, 2, 1]\r输出：[1, 2, 3]\r示例2:\n 输入：[1, 1, 1, 1, 2]\r输出：[1, 2]\r提示：\n 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。  进阶：\n如果不得使用临时缓冲区，该怎么解决？\n思路\n哈希 O(n) 哈希表存储出现过的元素，如果当前节点出现过，就删掉\n我们从链表的头节点head 开始进行遍历，遍历的指针记为cur。由于头节点一定不会被删除，因此我们可以枚举待移除节点的前驱节点pre，减少编写代码的复杂度。\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/16 22:27\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 0201.py\r# @Software : PyCharm # Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef removeDuplicateNodes(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rif not head:\rreturn head\rtmp = {head.val}\rpre = head\rcur = pre.next\rwhile cur:\rif cur.val in tmp:\rpre.next = cur.next\rcur = cur.next\relse:\rtmp.add(cur.val)\rpre = pre.next\rcur = cur.next\rreturn head\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 3, 2, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.removeDuplicateNodes(head)\rtraversal_link(result)\r双指针 固定p指针，右侧q指针扫描，然后移动p，指针q再次扫描 时间复杂度 O(n^2)\n# Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef removeDuplicateNodes(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rp = head\rwhile p:\rq = p\rwhile q.next:\rif q.next.val == p.val:\rq.next = q.next.next\relse:\rq = q.next\rp = p.next\rreturn head\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 3, 2, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.removeDuplicateNodes(head)\rtraversal_link(result)\r","description":"leetcode，0201 移除重复节点","tags":["leetcode"],"title":"0201移除重复节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0201%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"剑指 Offer 24. 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例:\n输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL\r输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL\r限制：\n0 \u003c= 节点个数 \u003c= 5000\r思路\n# Definition for singly-linked list.\rclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef reverseList(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: ListNode\r\"\"\"\rcur = head\rpre = None\rwhile cur:\rafter = cur.next\rcur.next = pre\rpre = cur\rcur = after\rreturn pre\rdef create_link(tmp):\rhead = None\rcur = None\rfor i in tmp:\rnode = ListNode(i)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rcur = head\rwhile cur:\rprint(cur.val)\rcur = cur.next\rif __name__ == '__main__':\rhead = create_link([1, 2, 3, 4, 5])\r# traversal_link(head)\rsolution = Solution()\rcur = solution.reverseList(head)\rtraversal_link(cur)\r","description":"leetcode，Offer24 反转链表","tags":["leetcode"],"title":"Offer24 反转链表","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","链表"],"content":"1290. 二进制链表转整数 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。\n请你返回该链表所表示数字的 十进制值 。\n示例 1：\n输入：head = [1,0,1]\r输出：5\r解释：二进制数 (101) 转化为十进制数 (5)\r示例 2：\n输入：head = [0]\r输出：0\r示例 3：\n输入：head = [1]\r输出：1\r示例 4：\n输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\r输出：18880\r示例 5：\n输入：head = [0,0]\r输出：0\r提示：\n链表不为空。\r链表的结点总数不超过 30。\r每个结点的值不是 0 就是 1。\r思路\n如果一个十进制的数字，999要和1拼接，需要999*10+1 = 999∗10+1=9991\r如果一个二进制的数字，110要和1拼接，需要110*2+1 = 110∗2+1=1101 （注意按照二进制的方法计算）\r代码\nclass Solution(object):\rdef getDecimalValue(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: int\r\"\"\"\rresult = 0\rwhile head:\rresult = head.val + (result \u003c\u003c 1)\rhead = head.next\rreturn result\r","description":"leetcode，1290 二进制链表转整数","tags":["leetcode"],"title":"1290二进制链表转整数","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/1290%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["leetcode","链表"],"content":"面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动\n示例：\n输入： 1-\u003e2-\u003e3-\u003e4-\u003e5 和 k = 2\r输出： 4\r说明：\r给定的 k 保证是有效的。\n思路\n经典的快慢指针问题\n\r反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。\r设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点\rclass Solution(object):\rdef kthToLast(self, head, k):\r\"\"\"\r:type head: ListNode\r:type k: int\r:rtype: int\r\"\"\"\rif head is None:\rreturn None\rleft = head\rright = head\rcount = 0\rwhile count \u003c k:\rright = right.next\rcount += 1\rwhile right:\rleft = left.next\rright = right.next\rreturn left.val\r","description":"leetcode，02.02. 返回倒数第 k 个节点","tags":["leetcode"],"title":"02.02返回倒数第 k 个节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0202%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。\n示例：\n输入：单向链表a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef中的节点c\r结果：不返回任何数据，但该链表变为a-\u003eb-\u003ed-\u003ee-\u003ef\r代码\nclass Solution(object):\rdef deleteNode(self, node):\r\"\"\"\r:type node: ListNode\r:rtype: void Do not return anything, modify node in-place instead.\r\"\"\"\rnode.val = node.next.val\rnode.next = node.next.next\r解题思路 删除当前节点 必须知道prev节点， 这里只能访问当前节点，就只能先将next节点的值赋值给当前结点, 再把next节点干掉\n","description":"leetcode，02.03. 删除中间节点","tags":["leetcode"],"title":"02.03删除中间节点","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0203%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["leetcode","链表"],"content":"面试题 02.06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/) 编写一个函数，检查输入的链表是否是回文的。\n示例 1：\n输入： 1-\u003e2\r输出： false 示例 2：\n输入： 1-\u003e2-\u003e2-\u003e1\r输出： true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n思路\n1. 快慢指针遍历到链表中间，快指针走两步、慢指针走一步，最后慢指针的位置就是链表中间（画个示例图就知道了，虽然我这看的是该题的评论，不太明白，然后画了个图就了解了）\r2. 从中间开始反转链表后半段\r3. 从原链表头和反转后的链表头开始比较 value\r代码\n# -*- coding: utf-8 -*-\r# @Time : 2020/7/15 21:27\r# @Author : affectalways\r# @Site : # @Contact : affectalways@gmail.com\r# @File : 0206.py\r# @Software : PyCharm class ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef get_middle(self, head):\r\"\"\"用快慢指针获取中间节点\"\"\"\rleft = right = head\rwhile right and right.next:\rleft = left.next\rright = right.next.next\rreturn left\rdef reverse_link(self, head):\r\"\"\"反转链表\"\"\"\rcur = head\rpre = None\rwhile cur:\rafter = cur.next\rcur.next = pre\rpre = cur\rcur = after\rreturn pre\rdef isPalindrome(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: bool\r\"\"\"\rif head is None:\rreturn True\r# 获取中间节点\rmiddle_node = self.get_middle(head)\r# 反转链表\rfirst = head\rsecond = self.reverse_link(middle_node)\rwhile second:\rif first.val != second.val:\rreturn False\rfirst = first.next\rsecond = second.next\rreturn True\rdef create_link(tmp):\rhead = None\rcur = head\rfor val in tmp:\rnode = ListNode(val)\rif head is None:\rhead = node\rcur = head\relse:\rcur.next = node\rcur = cur.next\rreturn head\rdef traversal_link(head):\rwhile head:\rprint(head.val)\rhead = head.next\rif __name__ == '__main__':\rhead = create_link([1, 1, 1, 1])\r# traversal_link(head)\rsolution = Solution()\rresult = solution.isPalindrome(head)\rprint(result)\r","description":"leetcode，0206 回文链表","tags":["leetcode"],"title":"0206回文链表","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0206%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["python","werkzeug"],"content":"Werkzeug是什么？ Werkzeug是一个基于WSGI的Web应用框架（说框架可能不合理，官方文档给出的是应用程序库）。想要了解更多请看官方文档\n为什么要了解Werkzeug？ 因为目前所用的web框架为Flask，而Flask是以Werkzeug为基础的，所以绕不开Werkzeug了。\n基础知识  WSGI Python 生成器 非常简单的网络知识  ","description":"","tags":["werkzeug"],"title":"Werkzeug 源码解析(1)","uri":"/posts/werkzeug/werkzeug_sc_1/"},{"categories":["python","werkzeug"],"content":"从哪开始呢？   熟悉目录层级\n  参照Werkzeug官方文档给出的示例，重点关注Request,Response,run_simple\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  from werkzeug.wrappers import Request, Response def application(environ, start_response): request = Request(environ) text = 'Hello %s!' % request.args.get('name', 'World') response = Response(text, mimetype='text/plain') return response(environ, start_response) \"\"\" 省略超多内容 \"\"\" class Shortly(object): def __init__(self, config): self.redis = redis.Redis(config['redis_host'], config['redis_port']) def dispatch_request(self, request): return Response('Hello World!') def wsgi_app(self, environ, start_response): request = Request(environ) response = self.dispatch_request(request) return response(environ, start_response) def __call__(self, environ, start_response): return self.wsgi_app(environ, start_response) def create_app(redis_host='localhost', redis_port=6379, with_static=True): app = Shortly({ 'redis_host': redis_host, 'redis_port': redis_port }) if with_static: app.wsgi_app = SharedDataMiddleware(app.wsgi_app, { '/static': os.path.join(os.path.dirname(__file__), 'static') }) return app if __name__ == '__main__': from werkzeug.serving import run_simple app = create_app() run_simple('127.0.0.1', 5000, app, use_debugger=True, use_reloader)     Request、Response、run_simple（最不重要的） 之后的文章就重点关注以上三个，而且肯定会延伸到Werkzeug的其他地方（源码），不必担心，肯定会有所涉猎。\n讲真，感觉run_simple可以不重点关注，希望不要打脸\n","description":"","tags":["werkzeug"],"title":"Werkzeug 源码解析(2)","uri":"/posts/werkzeug/werkzeug_sc_2/"},{"categories":["python","werkzeug"],"content":"Werkzeug Request 源码解析 代码示例：\nfrom werkzeug.wrappers import Request, Response\rdef application(environ, start_response):\rrequest = Request(environ)\rtext = 'Hello %s!' % request.args.get('name', 'World')\rresponse = Response(text, mimetype='text/plain')\rreturn response(environ, start_response)\r请注意，之后Request和Response的相关源码都会围绕Werkzeug给出的以上代码讲解。\nRequest 类 文件定位 src/werkzeug/wrappers/request.py\n作用 根据Request类的名称其实就可以知道，Request类是处理请求的，实际上，通过阅读相关代码，Request类的作用确实如此\n分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Request( BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin, CORSRequestMixin, CommonRequestDescriptorsMixin, ): \"\"\"Full featured request object implementing the following mixins: - :class:`AcceptMixin` for accept header parsing - :class:`ETagRequestMixin` for etag and cache control handling - :class:`UserAgentMixin` for user agent introspection - :class:`AuthorizationMixin` for http auth handling - :class:`~werkzeug.wrappers.cors.CORSRequestMixin` for Cross Origin Resource Sharing headers - :class:`CommonRequestDescriptorsMixin` for common headers \"\"\"   ​\t根据注释可知，除了BaseRequest类之外，其他的Mixin类都是作为添加高级方法的类。而且Request类也没有初始化方法，所以可以将注意力从Request转移到BaseRequest类上面。\nBaseRequest 类 截取以上代码示例的代码\nrequest = Request(environ)\r调用父类BaseRequest的__init__方法\n1 2 3 4 5  def __init__(self, environ, populate_request=True, shallow=False): self.environ = environ if populate_request and not shallow: self.environ[\"werkzeug.request\"] = self self.shallow = shallow   ","description":"","tags":["werkzeug"],"title":"Werkzeug 源码解析(3)","uri":"/posts/werkzeug/werkzeug_sc_3/"},{"categories":["python","WSGI"],"content":"WSGI 是个什么东西？ 实际的生产环境中，Python应用程序是放在服务器的http server（比如Apache、Nginx等）上的。现在的问题是http server（之后以服务器代称）怎么把接收到的请求传递给Python应用程序？这就是WSGI做的事情。\nWSGI（Web Server Gateway Interface）即Web服务器网关接口，解耦了服务器（Apache、Nginx等）和Python应用程序，是Python开发者只需要关注Python应用程序的开发。\n Web Server：即HTTP Server，接收用户的请求并返回响应信息；分为以下两部分：\n 服务器，如Apache、Nginx等 Python应用程序，负责处理业务逻辑   HTTP Server 实现 服务器每接收到一个请求就调用一次Python Application。服务器作用如下\n 接收HTTP请求 提供environ和回调函数start_response，并传给callable object 调用callable object  以下是PEP-3333提供的示例\nimport os, sys\renc, esc = sys.getfilesystemencoding(), 'surrogateescape'\rdef unicode_to_wsgi(u):\r# Convert an environment variable to a WSGI \"bytes-as-unicode\" string\rreturn u.encode(enc, esc).decode('iso-8859-1')\rdef wsgi_to_bytes(s):\rreturn s.encode('iso-8859-1')\rdef run_with_cgi(application):\r\"\"\"\rapplication: 是Python Application中的callable object\r\"\"\"\r# 构造environ变量，dict类型，里面的内容是一次HTTP请求的环境变量\renviron = {k: unicode_to_wsgi(v) for k,v in os.environ.items()}\renviron['wsgi.input'] = sys.stdin.buffer\renviron['wsgi.errors'] = sys.stderr\renviron['wsgi.version'] = (1, 0)\renviron['wsgi.multithread'] = False\renviron['wsgi.multiprocess'] = True\renviron['wsgi.run_once'] = True\rif environ.get('HTTPS', 'off') in ('on', '1'):\renviron['wsgi.url_scheme'] = 'https'\relse:\renviron['wsgi.url_scheme'] = 'http'\rheaders_set = []\rheaders_sent = []\r# 把响应信息写到终端\rdef write(data):\rout = sys.stdout.buffer\rif not headers_set:\rraise AssertionError(\"write() before start_response()\")\relif not headers_sent:\r# Before the first output, send the stored headers\rstatus, response_headers = headers_sent[:] = headers_set\rout.write(wsgi_to_bytes('Status: %s\\r\\n' % status))\rfor header in response_headers:\rout.write(wsgi_to_bytes('%s: %s\\r\\n' % header))\rout.write(wsgi_to_bytes('\\r\\n'))\rout.write(data)\rout.flush()\r# 定义start_response回调函数\rdef start_response(status, response_headers, exc_info=None):\rif exc_info:\rtry:\rif headers_sent:\r# Re-raise original exception if headers sent\rraise exc_info[1].with_traceback(exc_info[2])\rfinally:\rexc_info = None # avoid dangling circular ref\relif headers_set:\rraise AssertionError(\"Headers already set!\")\rheaders_set[:] = [status, response_headers]\r# Note: error checking on the headers should happen here,\r# *after* the headers are set. That way, if an error\r# occurs, start_response can only be re-called with\r# exc_info set.\rreturn write\rresult = application(environ, start_response)\rtry:\r# 处理application返回的结果（可迭代）\rfor data in result:\rif data: # don't send headers until body appears\rwrite(data)\rif not headers_sent:\rwrite('') # send headers now if body was empty\rfinally:\rif hasattr(result, 'close'):\rresult.close()\r中间件Middleware Middlerware是位于Http Server和Python Application之间的功能组件。\n对于Http Server而言，Middlerware就是应用程序；对于Python Application而言，Middlerware就是Http Server。Middleware对Http Server和Python Application是透明的，把从Http Server接收到的请求进行处理并向后传递，一直传递给Python Application，最后把Python Application的处理结果返回给Http Server。如下图：\nMiddlerware组件可执行以下功能：\n 根据 url 把用户请求调度到不同的 Python Application 中。 负载均衡，转发用户请求 预处理 XSL 等相关数据 限制请求速率，设置白名单   PS：WSGI 的 middleware 体现了 unix 的哲学之一：do one thing and do it well。\n 本例实现了一个关于异常处理的 middleware（摘自）：\nfrom sys import exc_info\rfrom traceback import format_tb\rclass ExceptionMiddleware(object):\r\"\"\"The middleware we use.\"\"\"\rdef __init__(self, app):\rself.app = app\rdef __call__(self, environ, start_response):\r\"\"\"Call the application can catch exceptions.\"\"\"\rappiter = None\r# just call the application and send the output back\r# unchanged but catch exceptions\rtry:\rappiter = self.app(environ, start_response)\rfor item in appiter:\ryield item\r# if an exception occours we get the exception information\r# and prepare a traceback we can render\rexcept:\re_type, e_value, tb = exc_info()\rtraceback = ['Traceback (most recent call last):']\rtraceback += format_tb(tb)\rtraceback.append('%s: %s' % (e_type.__name__, e_value))\r# we might have not a stated response by now. try\r# to start one with the status code 500 or ignore an\r# raised exception if the application already started one.\rtry:\rstart_response('500 INTERNAL SERVER ERROR', [\r('Content-Type', 'text/plain')])\rexcept:\rpass\ryield '\\n'.join(traceback)\r# wsgi applications might have a close function. If it exists\r# it *must* be called.\rif hasattr(appiter, 'close'):\rappiter.close()\rPython Application Python Application端必须定义一个 callable object，callable object 可以是以下三者之一：\n function/method class instance with a __call__ method  callable object必须满足以下两个条件：\n 接收两个参数：environ（字典，WSGI的环境信息）、start_response（响应请求的函数, 返回HTTP status、headers给server） 返回一个可迭代的值（iterable）   重点内容：\n environ和start_response由http server提供并实现 environ变量是包含环境变量的字典 Python Application内部在返回前调用start_response start_response也是一个callable，接收两个必要的参数，status和response_headers   callable object代码实现 1.function/method def application(environ, start_response):\r# 调用服务器程序提供的 start_response，填入两个参数\rstart_response('200 OK', [('Content-Type', 'text/json')])\rreturn []\r2.class class ApplicationClass(object):\rdef __init__(self, environ, start_response):\rself.environ = environ\rself.start_response = start_response\rdef __iter__(self):\rself.start_response('200 OK', [('Content-Type', 'text/json')])\ryield \"随便\"\r 使用方式\nfor result in ApplicationClass(environ, start_response):\rdo_somthing(result)\r 3.instance with a call method class ApplicationClass(object):\rdef __init__(self):\rpass\rdef __call__(self, environ, start_response):\rstart_response('200 OK', [('Content-Type', 'text/json')])\ryield \"anything\"\r 使用方式\napp = ApplicationClass()\rfor result in app(environ, start_response):\rdo_something(result)\r 参考链接 PEP-3333\n巨佬\n","description":"","tags":["wsgi"],"title":"WSGI 理解（1）","uri":"/posts/wsgi/wsgi_kl_1/"},{"categories":["blog","hugo"],"content":"不能评论! Hugo 是一个强大的静态网页生成器，使用 go 开发，速度贼快。不过 Hugo 还比较年轻，没有像 NexT 那样功能强大，成熟稳定的主题。所以很多东西需要自己动手撸。\n比如评论系统。\n 评论系统排名\n  valine \u003e gitalk \u003e gitment \u003e livere \u003e 畅言\n 关于Valine   官方网址： «https://valine.js.org/\u003e\u003e\n  其特性不一一赘述，官方网址有介绍\n  添加评论区 目前博客使用的主题是meme\n不同的主题可能有所区别，但原理大都类似\n 原理？ Hugo 会将 Markdown 文档 按照 主题 (包括 HTML 模板、CSS、JavaScript 等) 编译成静态网页\n那么我们只需要将 Valine作为一个 \u003cdiv\u003e 插入到 HTML 模板中，然后在 config.toml 中添加相关配置，就可以添加评论区了\n Leancloud相关配置 评论系统依赖于leancloud，所以需要先在leancloud中进行相关的准备工作。\n  登录 或 注册 LeanCloud\n  登录成功后，进入后台点击左上角的创建应用：\n  创建好应用，进入应用，左边栏找到 设置 ，然后点击 应用Key，此时记录出现的 App ID 和 App Key，后面配置文件中会用到：\n  因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 Class，左边栏找到并点击 存储，点击 创建Class:\n  创建两个存储Class，分别命名为: Counter 和 Comment;\n  还需要为应用添加安全域名，左边栏点击 设置，找到 安全中心，点击后会看到 安全域名 设置框，输入博客使用的域名，点击保存即可：\n  config.toml开启comment  将enableComments = false设置为enableComments = true 将enableValine = false设置为enableValine = true   添加 Valine 参数项：\n ## Valine\renableValine = true\rvalineAppId = \"************\"\rvalineAppKey = \"*****************\"\rvalinePlaceholder = \"Just go go\"\rvalinePath = \"\"\rvalineAvatar = \"mm\"\rvalineMeta = [\"nick\", \"mail\", \"link\"]\rvalinePageSize = 10\rvalineLang = \"zh-cn\"\rvalineVisitor = false\rvalineHighlight = true\rvalineAvatarForce = false\rvalineRecordIP = false\rvalineServerURLs = \"\"\rvalineEmojiCDN = \"\"\rvalineEmojiMaps = {}\rvalineEnableQQ = false\rvalineRequiredFields = []\r上面几项内容的含义，这里简单一说，具体还是要看 Valine官网中配置相关的内容：\n   参数 用途     enable 这是用于主题中配置的，不是官方Valine的参数，true时控制开启此评论系统   appId 这是在 leancloud 后台应用中获取的，也就是上面提到的 App ID   appKey 这是在 leancloud 后台应用中获取的，也就是上面提到的 App Key   notify 用于控制是否开启邮件通知功能，具体参考邮件提醒配置   verify 用于控制是否开启评论验证码功能   avatar 用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：头像配置   placehoder 评论框的提示符   visitor 控制是否开启文章阅读数的统计功能i, 详情阅读文章阅读数统计    修改主题文件 主要是修改主题中评论相关的布局文件 themes\\meme\\layouts\\partials\\components\\comments.html，按照 Valine快速开始 添加 Valine 相关代码，找到以下位置\n{{ if .Site.Params.enableValine }}\r{{- end }}\r添加的 Valine 评论的代码如下：\n{{ if .Site.Params.enableValine }}\r\u003cdiv id=\"vcomments\"\u003e\u003c/div\u003e\r\u003cscript src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"\u003e\u003c/script\u003e\r\u003cscript src='//unpkg.com/valine/dist/Valine.min.js'\u003e\u003c/script\u003e\r\u003cscript type=\"text/javascript\"\u003e\rnew Valine({\rel: '#vcomments' ,\rappId: '{{ .Site.Params.valineAppId }}',\rappKey: '{{ .Site.Params.valineAppKey }}',\rnotify: '{{ .Site.Params.valineNotify }}', verify: '{{ .Site.Params.valineVerify }}', avatar:'{{ .Site.Params.valineAvatar }}', placeholder: '{{ .Site.Params.valinePlaceholder }}',\rvisitor: '{{ .Site.Params.valineVisitor }}'\r});\r\u003c/script\u003e\r{{ end }}\r可以看到上述代码中引用了配置文件中的相关参数，这样以后修改配置就不用修改代码了，只需要改配置文件 config.toml。\n","description":"Hugo 添加评论功能","tags":["hugo"],"title":"Hugo 添加评论功能","uri":"/posts/hugo/hugo_comment/"},{"categories":["blog","hugo"],"content":"居然都找不到！ 其实Blog我主要是用来做一些记录，突然看到有博客提到GitHub Pages屏蔽了百度的爬虫，所以百度是搜索不到GitHub Pages上的网页的。\n什么？所以百度搜索搜不到我的个人博客？不死心，尝试一下，找得到github、gist主页，但是就是找不到github.io后缀的网页。除了百度之外，我还尝试了Bing、Google，都没有。\n如何让搜索引擎索引到呢？ 发现流行的搜索引擎居然都找不到博客，那就需要赶紧找解决方法。Google和Bing还不清楚是怎么回事，但网上流传的email回复内容都点明了Github Pages禁止了百度爬虫的爬去，似乎原因是百度爬虫爬得太过于频繁，会严重影响服务器性能。针对百度爬虫的问题，大家找了很多方法。自建服务器托管博客、将博客放在Gitlab上或者CDN方法都不在我的选择范围内，因为暂时我还没有购买服务器或者域名的打算，所以决定放弃百度……但不管怎么样Bing和Google还是要设置好的！\nGoogle 添加资源 在google搜索页面输入“site:affectalways.github.io”就可以看到这个网页是否被google索引到，如果没被索引到，在搜索结果页面就会直接提示你使用Google Search Console。登录后，如果是首次使用在Search Console中以下界面中选择“网页”类型资源，并将博客完整url填入其中，我填入“https://affectalways.github.io”。注意http或者https，www等最好能完全正确。\n如果已经添加过资源，则需要点击左上角的按钮，然后和上面一样地添加资源即可。\n资源添加后，需要验证你对该网站有所有权。Google提供了几种方法，我选择了三种方式：\nHTML验证文件上传 只需要根据要求，下载HTML验证文件，把文件放在站点根目录的static目录下（以本网站为例：affectalways/static）\nHTML标记 config.toml中的googleSiteVerification = \"\" 设置为 googleSiteVerification = 不为空\n找到themes/meme/layouts/partials/head.html中的\n{{- with .Site.Params.googleSiteVerification }}\r\u003cmeta name=\"google-site-verification\" content=\"\" /\u003e\r{{- end }}\r把content内容改为给定的内容，然后执行hugo命令，就可以验证了\nGoogle Analytics 先到Google Analytics创建一个账号，并登录。\n新建一个资源，填完后获得tracking code。\n更新config.toml文件，把enableGoogleAnalytics设为true，trackingCodeType设为gtag（两个选择gtag和analytics，因为affectalways.github.io使用的是Google Analytics给定的gtag.js，所以设置为gtag），trackingID设为获取到的tracking code。然后执行hugo命令，就可以验证了。\n站点地图 在左侧点击“站点地图”，并在右侧点添加/测试站点地图，并添加url，我的是https://affectalways.github.io/sitemap.xml\nBing 相似地，在Bing网站管理登陆、添加网站url。\n然后在左侧点击“配置我的网站\u003eSitemaps”，并在右侧加上sitemap的url，点击提交。\n百度不死心的尝试  不死心的失败了\n ","description":"Hugo 让 GitHub Pages被索引到","tags":["hugo"],"title":"Hugo 让 GitHub Pages被索引到","uri":"/posts/hugo/hugo_seo/"},{"categories":["blog","hugo"],"content":"Hugo Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在这里查看。\n分类taxonomy有3个概念：\n Taxonomy 分类: 可以用来对内容进行分类的类别 Term 术语: 分类的一个键 Value 值: 分配给这个Term的具体内容  例如我需要增加3个分类，分别是：\n tag：文章标签 topic：文章主题/文章系列 category：文章分类  以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如hugo，Value是打上这个标签的对应网页。\n配置分类 需要在 config.toml 中增加分类。还是这个例子，则需要增加如下内容：\n[taxonomies]\rtag = \"tags\"\rcategory = \"categories\"\r而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为：\ntitle: \"Hugo添加tags等分类\"\rdate: 2020-06-17T20:19:37+08:00\rtags: [\"hugo\"]\rdraft: true\r当然实际上，Hugo默认会产生 tags 和 categories 的分类，如果只需要这两个，可以不用在 config.toml 中声明就在post头部使用。\n分类集合查看 使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。\n还是以tag为例：\nexample.com/tags/ 会列出tags中的所有术语；\nexample.com/tags/docker 会列出tags标为docker的所有网页列表。\n 额外知识点：\n keywords、description meta标签的一个很重要的功能就是设置关键字，来帮助你的主页被各大搜索引擎登录，提高网站的访问量。在这个功能中，最重要的就是对Keywords和description的设置。因为按照搜索引擎的工作原理,搜索引擎首先派出机器人自动检索页面中的keywords和decription，并将其加入到自己的数据库，然后再根据关键词的密度将网站排序。因此，我们必须设置好关键字，来提高页面的搜索点击率。使用如下：\nkeywords: - hugo\r- blog\r- 博客\r- 建站\rdescription: \"Hugo 添加tags等分类\"\r keywords需要进行配置：\n在themes\\meme\\layouts\\partials\\header.html的\n\u003cheader class=\"header\"{{ if and (eq .Site.Params.headerLayout \"flex\") 内部添加\n就可以了\r  description是hugo支持的，不需要配置\n ","description":"Hugo 添加tags等分类","tags":["hugo"],"title":"Hugo 添加tags等分类","uri":"/posts/hugo/hugo_tags/"},{"categories":["blog","hugo"],"content":"Introduction 正如上一篇说的，我选择了Hugo作为静态网页生成器。为何要放弃Hexo，换成Hugo呢？\n主要是出于以下考虑：\n 1.Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。\n2.同样得益于go，Hugo的安装配置看上去也并不麻烦；Hugo可以很轻松的被编译成二进制文件安装、运行。不必像Hexo一样依赖Node.js，也不必安装一堆依赖\n  Hugo的安装配置看上去也并不麻烦，同样得益于go，  安装 直接在这里选择合适的版本。\n下载好后解压，将解压出来的可执行文件 (格式为 .exe)，放到自己喜欢的目录下。直接可以使用，不需要安装。\n但要记住一定要将你选择的文件夹路径加入到环境变量 PATH 中。\n PS：由于theme选择的是meme，需要下载extended版本的hugo；\n 初始化 下面，初始化博客路径。首先需要选择一个路径来存放我们的博客，在你选好的路径下执行：\nhugo new site myBlog\r这条命令会创建一个名为myBlog（可以使用任意名字）的文件夹来存放你的博客。执行 cd myBlog 命令进入文件夹。\n此时目录结构应该是这样的\n.\r└── myBlog\r├── config.toml / config.yaml / config.json\r├── content\r│ └── ...\r├── layouts\r│ └── ...\r├── themes\r│ └── ...\r├── static\r│ └── ...\r├── archetypes\r│ └── ...\r├── data\r│ └── ...\r└── ...\r其中：\n config.toml 是网站的配置文件，Hugo还可使用 config.yaml 或者 config.json 进行配置。 content 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。 layouts 文件夹存放 .html 格式的模板。模板确定了静态网站渲染的样式。 themes 文件夹存放网站使用的theme主题模板。 static 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。 archetypes 文件夹存放网站预设置的文件模板头部，当使用 hugo new 时即可生成一个带有该头部的实例。 data 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。  配置theme 可以在这里找自己喜欢的主题。我暂时选择有搜索功能的meme，将主题clone到themes目录下：\ngit clone https://github.com/忘了/meme.git themes/meme\r然后将themes/meme/exampleSite/config.toml模板配置文件复制到根目录，然后根据此文件来配置你的设置。\n PS：一定要把config.yaml中的theme修改为你使用的主体名称。比如我用的主题是meme，config.yaml文件就设置theme=\"meme”\n 创建新页面 创建一个新页面\nhugo new about.md\r此时 content 文件夹下就多了一个 about.md 文件，打开文件就可以看到时间、文件名等信息已经自动生成了\n---\rtitle: \"about\"\rdate: 2020-06-16T23:30:53+08:00\rdraft: true\r---\r两条 --- 间的信息是文章的配置信息，有的信息是自动生成的 (如：title、date 等)，简单介绍以下各项配置\n  以下项目是自动生成的: title: # 文章标题 date: # 写作时间 draft: # 是否为草稿，如果为 true 需要在命令中加入 --buildDrafts 参数才会生成这个文档 以下项目需要自行添加: description: # 描述 tags: # 标签，用于文章分类 等等   自动生成 和 执行添加 的内容并不是绝对的，你可以根据自己的喜好配置模板文件 archetypes/default.md\n生成网站 设置完config.toml 后我们执行以下命令\nhugo server --buildDrafts -w\r此时你就可以在 http://localhost:1313 访问到你的博客了。\n此时你的博客目录下就会多出一个public目录，这是Hugo生成的网站。\n简单介绍一下两个参数：\n --buildDrafts: 生成被标记为 「草稿」 的文档 -w: 监控更改，如果发生更改直接显示到博客上   PS：但此时只能在本地访问 (相当于预览博客，如果与期望值不符，可以随时更改)，如果想发布到 Github Pages 上需要先将文章配置信息中的 draft: 改为 false ，\n然后执行命令\nhugo\r  GitHub Pages部署 参考这里，在Github Pages有四种类型，而对于非组织型用户来说有两种，一种是用户的个人网站，网页域名为 username.github.io，另一种为Project的主页，网页域名为 username.github.io/projectname。Github Pages对于Project主页的源码要求有了修改，现在也可以放置在master上，之前版本中必须放在gh-pages 分支上，不过这里暂且不提，主要还是关心用户个人主页。\n这就需要你在Github上建立一个以 username.github.io 为名称的repository，对于我来说就是 affectalways.github.io。此外，需要将Hugo生成的所有静态网页push到这个repository的master分支上。现在就可以用这个域名打开个人网站了。\nHugo没有提供自动发布到GitHub Pages的功能。需要将public中的内容手动上传到Github上。\n首先执行命令cd public进入到public目录，然后执行\ngit init\rgit remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git\rgit add .\rgit commit -m \"[介绍，随便写点什么，比如日期]\"\rgit push （若是第一次发布，需要用到--set-upstream）\r","description":"Hugo 建站（2）Blog","tags":["hugo"],"title":"Hugo blog（2）","uri":"/posts/hugo/hugo_install_2/"},{"categories":["blog","hugo"],"content":"初始  养个Blog的想法从很早就有了，但是…  从本科开始就一直想要一个自己的Blog，一直没有行动。本身我就没有记日志的习惯，也没有需求和冲动写下什么东西，虽然有时想记下学的内容，但有道云笔记就够了，也没什么写技术博客的想法。除了很久之前偶尔在CSDN写了几篇入门级文章，也就没有其他了。此外，虽说博客最重要的是内容，但没有一个好的生态环境和前端界面设计，至少对于我而言，没有任何兴趣花时间在上面，原谅我是外观主义者。对于界面设计，CSDN或者博客园实在不敢恭维，尤其是CSDN。自建网站之前也尝试过，恩，还要使用服务器，花钱。我得承认，当时作为本科生的我，太过局限于学校课堂，并未走出去看看，对于网络信息的运用和挖掘也更多停留在看看答案、找找软件、翻翻视频的基础使用上，最多也就是查看下算法之类的。\n最近，特别是正式工作快一年了，更多地接触了“网络世界”的信息和知识，拓宽了实页。随着自我学习机会和时间愈少，碎片化学习和感想也愈多，加上虽然网上知识丰富，但内容驳杂，过段时间想再查找却需要对这些信息重新筛选、略感费劲，再加上工作后个人体悟良多，于是又一次萌生个人博客的想法。\n难产  选择恐惧症+控制狂的特质决定了我家Blog的难产…  尽管现在有许多像知乎专栏这样现代化的界面和良好的用户群的网站可以让人直接在上面写作，但我还是更倾向于GitHub Pages，与GitHub非常紧密的关系是该倾向性很重要的原因（这对码农而言，非常有诱惑力）。\nGitHub Pages搭建个人博客，使用的是轻量级的静态网页，网上已经有了很多教程和方案。几天前遇到了三种方案：Jekyll、Hexo、Hugo。Jekyll据说可定制化和功能很强大，但是ruby个人真的很不能接受。Hexo是国人教程最多的，国外口碑也非常好，看到外国的一句评论说，缺点就是大多数内容都是中文，英文教程少，哈哈。Hexo是基于Node.js，对于程序员相当友好。不过这次我决定选择另一个Framework，使用Hugo。Hugo是用现在大热的go语言写的，据说编译起来比Hexo还会快很多。而且我最近在学go…\n开始  开始吧  那就开始吧\n","description":"Hugo 建站（1）Blog","tags":["hugo"],"title":"Hugo blog（1）","uri":"/posts/hugo/hugo_install_1/"},{"categories":["blog","hugo"],"content":"​\tHugo：是一种通用的网站框架。严格来说，这类应用应该被称作静态网站生成器。这类应用将 Markdown 文件和主题一起编译成由 HTML、CSS、JavaScript 组成的静态网页。\n​\t然后上传到 GitHub 上，通过 GitHub 提供的静态页面托管服务 (GitHub Pages) 进行访问。\n​\t这里就写一篇文章来记录一下踩过的坑。\n","description":"使用Hugo + GitHub Pages搭建个人博客","tags":["hugo"],"title":"使用Hugo + GitHub Pages搭建个人博客","uri":"/posts/hugo/hugo_install/"},{"categories":null,"content":"​\t理工男，非强迫症，不可一日无书\n","description":"","tags":null,"title":"关于我","uri":"/about/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"categories":null,"content":"title: \"0207链表相交\"\rdate: 2020-07-15T21:20:33+08:00\rtags: [\"leetcode\"]\rkeywords: - leetcode\r- blog\r- 博客\r- 领扣\r- 0207 链表相交\r- 算法\r- 链表\rdescription: \"leetcode，0207 链表相交\"\rcategories: [\"leetcode\",\"链表\"]\rdraft: false\r面试题 02.07. 链表相交 我竟然没读懂题！！！！！！！！！！！\n给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。\n示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r输出：Reference of the node with value = 8\r输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r示例 2：\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r输出：Reference of the node with value = 2\r输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r示例 3：\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r输出：null\r输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r解释：这两个链表不相交，因此返回 null。\r注意：\n 1.如果两个链表没有交点，返回 null 。\r2.在返回结果后，两个链表仍须保持原有的结构。\r3.可假定整个链表结构中没有循环。\r4.程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\r思路\n双指针什么的，技巧性有点强。最朴素的做法是求长度\r1.第一次遍历两个链表，记录长度\r2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步\r3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址）\r代码\nclass ListNode:\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution:\rdef getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode:\rlen_a = 0\rlen_b = 0\rcur_a = headA\rcur_b = headB\r# 1.第一次遍历两个链表，记录长度\rwhile cur_a:\rlen_a += 1\rcur_a = cur_a.next\rwhile cur_b:\rlen_b += 1\rcur_b = cur_b.next\r# 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步\rcur_a = headA\rcur_b = headB\rwhile len_b \u003e len_a:\rcur_b = cur_b.next\rlen_b -= 1\rwhile len_a \u003e len_b:\rcur_a = cur_a.next\rlen_a -= 1\r# 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址）\rwhile cur_a:\rif cur_a == cur_b:\rreturn cur_a\rcur_a = cur_a.next\rcur_b = cur_b.next\rreturn None\rdef create_list(sequence):\rheadA = None\rcur = None\rfor i in sequence:\rnode = ListNode(i)\rif headA is None:\rheadA = cur = node\rcontinue\rcur.next = node\rcur = cur.next\rreturn headA\rif __name__ == '__main__':\rintersectVal = 8\rlistA = [4, 1, 8, 4, 5]\rheadA = create_list(listA)\rlistB = [5, 0, 1, 8, 4, 5]\rheadB = create_list(listB)\rskipA = 2\rskipB = 3\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/0207%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"},{"categories":null,"content":"title: \"Offer06从尾到头打印链表\"\rdate: 2020-07-15T21:20:33+08:00\rtags: [\"leetcode\"]\rkeywords: - leetcode\r- blog\r- 博客\r- 领扣\r- Offer 06. 从尾到头打印链表\r- 算法\r- 链表\rdescription: \"leetcode，Offer 06. 从尾到头打印链表\"\rcategories: [\"leetcode\",\"链表\"]\rdraft: false\r剑指 Offer 06. 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head = [1,3,2]\r输出：[2,3,1]\r限制：\n0 \u003c= 链表长度 \u003c= 10000\r思路\n## 方法一：栈\r栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。\r创建一个栈，用于存储链表的节点\r创建一个指针，初始时指向链表的头节点\r当指针指向的元素非空时，重复下列操作：\r将指针指向的节点压入栈内\r将指针移到当前节点的下一个节点\r获得栈的大小 size，创建一个数组 print，其大小为 size\r创建下标并初始化 index = 0\r重复 size 次下列操作：\r从栈内弹出一个节点，将该节点的值存到 print[index]\r将 index 的值加 1\r返回 print\r## 复杂性分析\r时间复杂度：O(n)O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。\r空间复杂度：O(n)O(n)。额外使用一个栈存储链表中的每个节点。\r代码\nclass ListNode(object):\rdef __init__(self, x):\rself.val = x\rself.next = None\rclass Solution(object):\rdef reversePrint(self, head):\r\"\"\"\r:type head: ListNode\r:rtype: List[int]\r\"\"\"\rif head is None:\rreturn []\rstack = []\rwhile head:\rstack.append(head.val)\rhead = head.next\rstack.reverse()\rreturn stack\r# result = None\r# cur = None\r# for node in stack:\r# if result is None:\r# result = node\r# cur = result\r# continue\r# cur.next = node\r# cur = cur.next\r# return result\rdef create_list(sequence):\rheadA = None\rcur = None\rfor i in sequence:\rnode = ListNode(i)\rif headA is None:\rheadA = cur = node\rcontinue\rcur.next = node\rcur = cur.next\rreturn headA\rif __name__ == '__main__':\rsolution = Solution()\rhead = create_list([1, 3, 2])\rresult = solution.reversePrint(head)\r","description":"","tags":null,"title":"affectalways","uri":"/posts/leetcode/%E9%93%BE%E8%A1%A8/offer06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"}]
