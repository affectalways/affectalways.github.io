<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>affectalways</title>
        <link>https://affectalways.github.io/</link>
        <description>affectalways.</description>
        <generator>Hugo 0.72.0 https://gohugo.io/</generator>
        
            <language>en</language>
        
        
            <managingEditor>affectalways@gmail.com (affectalways)</managingEditor>
        
        
            <webMaster>affectalways@gmail.com (affectalways)</webMaster>
        
        
            <copyright>@2020 affectalways</copyright>
        
        <lastBuildDate>Tue, 21 Jul 2020 22:47:11 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://affectalways.github.io/rss.xml" />
        
        
            <item>
                <title>Instagram在PyCon2017的演讲摘要</title>
                <link>https://affectalways.github.io/posts/python/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/python/instagram%E5%9C%A8pycon2017%E7%9A%84%E6%BC%94%E8%AE%B2%E6%91%98%E8%A6%81/</guid>
                <pubDate>Tue, 21 Jul 2020 22:38:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;&lt;strong&gt;郑重声明：本篇文章非原创，摘自&lt;a href=&#34;https://www.zlovezl.cn/articles/instagram-pycon-2017/&#34;&gt;https://www.zlovezl.cn/articles/instagram-pycon-2017/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.zlovezl.cn/static//uploaded/2017/05/2017-05-30-22-31-37_thumb.jpg&#34; alt=&#34;图：Instagram Loves Python&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;pycon-简介&#34;&gt;PyCon 简介&lt;/h2&gt;
&lt;p&gt;PyCon 是全世界最大的以 &lt;a href=&#34;https://en.wikipedia.org/wiki/Python_(programming_language)&#34;&gt;Python 编程语言&lt;/a&gt; 为主题的技术大会。大会由 Python 社区组织，每年举办一次。在大会上，来自世界各地的 Python 用户与核心开发者齐聚一堂，共同分享 Python 世界的新鲜事、Python 语言的应用案例、使用技巧等等内容。&lt;/p&gt;
&lt;h2 id=&#34;instagram-简介&#34;&gt;Instagram 简介&lt;/h2&gt;
&lt;p&gt;Instagram 是一款移动端的照片与视频分享软件，由 Kevin Systrom 和 Mike Krieger 在 2010 年创办。Instagram 在发布后开始快速流行。于 2012 年被 Facebook 以 10 亿美元的价格收购。而当时 Instagram 的员工仅有区区 13 名。&lt;/p&gt;
&lt;p&gt;如今，&lt;strong&gt;Instagram 的总注册用户达到 30 亿，月活用户超过 7 亿&lt;/strong&gt; &lt;em&gt;（作为对比，微信最新披露的月活跃用户为 9.38 亿）&lt;/em&gt;。而令人吃惊的是，这么高的访问量背后，竟完全是由以速度慢著称的 Python + Django 支撑。&lt;/p&gt;
&lt;p&gt;在 Python 2017 上，Instagram 的工程师们带来了一个有关 Python 在 Instagram 的主题演讲，同时还分享了 Instagram 如何将整个项目运行环境升级到 Python 3 的故事。&lt;/p&gt;
&lt;p&gt;本文为该次演讲的内容摘要。&lt;/p&gt;
&lt;h2 id=&#34;python-instagram&#34;&gt;Python @Instagram&lt;/h2&gt;
&lt;h3 id=&#34;为什么选择-python-和-django&#34;&gt;为什么选择 Python 和 Django&lt;/h3&gt;
&lt;p&gt;Instagram 选择 Django 的原因很简单，Instagram 的两位创始人 &lt;em&gt;(Kevin Systrom and Mike Krieger)&lt;/em&gt; 都是产品经理出身。&lt;strong&gt;在他们想要创造 Instagram 时，Django 是他们所知道的最稳定和成熟的技术之一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时至今日，即使已经拥有超过 30 亿的注册用户。Instagram 仍然是 Python 和 Django 的重度使用者。Instagram 的工程师 Hui Ding 说到： &lt;em&gt;『一直到用户 ID 已经超过了 32bit int 的限额（约为 20 亿），Django 本身仍然没有成为我们的瓶颈所在。』&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不过，除了使用 Django 的原生功能外，Instagram 还对 Django 做了很多定制化工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;扩展 Django Models 使其支持 Sharding &lt;em&gt;（一种数据库分片技术）&lt;/em&gt;，&lt;a href=&#34;https://engineering.instagram.com/@InstagramEng&#34;&gt;Instagram Engneering&lt;/a&gt; 博客专门为这件事情写过一篇博客，可参阅：&lt;a href=&#34;https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c&#34;&gt;Sharding &amp;amp; IDs at Instagram&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动关闭 GC（垃圾回收）来提升 Python 内存管理效率，他们同样也写过一篇博客来说明这件事情：&lt;a href=&#34;https://engineering.instagram.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172&#34;&gt;Dismissing Python Garbage Collection at Instagram&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在位于不同地理位置的多个数据中心部署整套系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;python-语言的优势所在&#34;&gt;Python 语言的优势所在&lt;/h3&gt;
&lt;p&gt;Instagram 的联合创始人 Mike Krieger 说过： &lt;em&gt;『我们的用户根本不关心 Instagram 使用了哪种关系数据库，他们当然也不关心 Instagram 是用什么编程语言开发的。』&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;所以，Python 这种 &lt;strong&gt;简单&lt;/strong&gt; 而且 &lt;strong&gt;实用至上&lt;/strong&gt; 的编程语言最终赢得了 Instagram 的青睐。他们认为，使用 Python 这种简单的语言有助于塑造 Instagram 的工程师文化，那就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;专注于定位问题、解决问题&lt;/strong&gt; - 而不是工具本身的各种花花绿绿的特性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用那些经过市场验证过的成熟技术方案&lt;/strong&gt; - 而不用被工具本身的问题所烦扰&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户至上：专注于用户所能看到的新特性，为用户带去价值&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，即使使用 Python 语言有这么多好处，它还是很慢，不是吗？&lt;/p&gt;
&lt;p&gt;不过，这对于 Instagram 不是问题，因为他们认为：&lt;strong&gt;『Instagram 的最大瓶颈在于开发效率，而不是代码的执行效率』&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;At Instagram, our bottleneck is development velocity, not pure code execution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，最终的结论是：&lt;strong&gt;你完全可以使用 Python 语言来实现一个超过几十亿用户使用的产品，而根本不用担心语言或框架本身的性能瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何提升运行效率&#34;&gt;如何提升运行效率&lt;/h3&gt;
&lt;p&gt;但是，即使是选用了拥有诸多好处的 Python 和 Django。在 Instagram 的用户数迅速增长的过程中，性能问题还是出现了：&lt;strong&gt;服务器数量的增长率已经慢慢的超过了用户增长率&lt;/strong&gt;。Instagram 是怎么应对这个问题的呢？&lt;/p&gt;
&lt;p&gt;他们使用了这些手段来缓解性能问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发工具来帮助调优&lt;/strong&gt;：Instagram 开发了很多涵盖各个层面的工具，来帮助他们进行性能调优以及找到性能瓶颈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用 C/C++ 来重写部分组件&lt;/strong&gt;：把那些稳定而且对性能最敏感的组件，使用 C 或 C++ 来重写，比如访问 memcache 的 library。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用 Cython&lt;/strong&gt;：Cython 也是他们用来提升 Python 效率的法宝之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了上面这些手段，他们还在探索异步 IO 以及新的 Python Runtime 所能带来的性能可能性。&lt;/p&gt;
&lt;h3 id=&#34;升级到-python-3&#34;&gt;升级到 Python 3&lt;/h3&gt;
&lt;p&gt;在相当长的一段时间，Instagram 都跑在 Python 2.7 + Django 1.3 的组合之上。在这个已经落后社区很多年的环境上，他们的工程师们还打了非常非常多的小 patch。难道他们要被永远卡在这个版本上吗？&lt;/p&gt;
&lt;p&gt;所以，在经过一系列的讨论后，他们最终做出一个重大的决定：&lt;strong&gt;升级到 Python 3！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上，Instagram 目前已经完成了将运行环境迁移到 Python 3 的工作 - 他们的整套服务已经在 Python 3 上跑了好几个月了。那么他们是怎么做到的呢？接下来便是由 Instagram 工程师 Lisa guo 带来的 Instagram 如何迁移到 Python 3 的故事。&lt;/p&gt;
&lt;h2 id=&#34;instagram-升级到-python-3-的故事&#34;&gt;Instagram 升级到 Python 3 的故事&lt;/h2&gt;
&lt;h3 id=&#34;为什么要升级到-python-3&#34;&gt;为什么要升级到 Python 3&lt;/h3&gt;
&lt;p&gt;对于 Instagram 来说，下面这些因素是推动他们将运行环境迁移到 Python 3 的主要原因：&lt;/p&gt;
&lt;h4 id=&#34;1-新特性类型注解-type-annotations&#34;&gt;1. 新特性：类型注解 Type Annotations&lt;/h4&gt;
&lt;p&gt;看看下面这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def compose_from_max_id(max_id):
    &#39;&#39;&#39;@param str max_id&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图中函数的 &lt;code&gt;max_id&lt;/code&gt; 参数究竟是什么类型呢？int？tuple？或是 list? 等等，函数文档里面说它是 str 类型。&lt;/p&gt;
&lt;p&gt;但随着时间推移，万一这个参数的类型发生变化了呢？如果某位粗心的工程师修改代码的同时忘了更新文档，那就会给函数的使用者带来很大麻烦，最终还不如没有注释呢。&lt;/p&gt;
&lt;h4 id=&#34;2-性能&#34;&gt;2. 性能&lt;/h4&gt;
&lt;p&gt;Instagram 的整个 Django Stack 都跑在 uwsgi 之上，全部使用了同步的网络 IO。这意味着同一个 uwsgi 进程在同一时间只能接收并处理一个请求。这让如何调优每台机器上应该运行的 uwsgi 进程数成了一个麻烦事：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;为了更好利用 CPU，使用更多的进程数？但那样会消耗大量的内存。而过少的进程数量又会导致 CPU 不能被充分利用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;为此，他们决定跳过 Python 2 中哪些蹩脚的异步 IO 实现 &lt;em&gt;（可怜的 gevent、tornado、twisted 众）&lt;/em&gt;，直接升级到 Python 3，去探索标准库中的 asyncio 模块所能带来的可能性。&lt;/p&gt;
&lt;h4 id=&#34;3-社区&#34;&gt;3. 社区&lt;/h4&gt;
&lt;p&gt;因为 Python 社区已经停止了对 Python 2 的支持。如果把整个运行环境升级到 Python 3，Instagram 的工程师们就能和 Python 社区走的更近，可以更好的把他们的工作回馈给社区。&lt;/p&gt;
&lt;h3 id=&#34;确定迁移方案&#34;&gt;确定迁移方案&lt;/h3&gt;
&lt;p&gt;在 Instagram，进行 Python 3 的迁移需要必须满足两个前提条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不停机，不能有任何的服务因此不可用&lt;/li&gt;
&lt;li&gt;不能影响产品新特性的开发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，在 Instagram 的开发环境中，要满足上面这两点来完成迁移到 Python 3.6 这种庞大的工程是非常困难的。&lt;/p&gt;
&lt;h4 id=&#34;基于主分支的开发流程&#34;&gt;基于主分支的开发流程&lt;/h4&gt;
&lt;p&gt;即便使用了以多分支功能著称的 git，Instagram 所有的开发工作都是主要在 master 分支上进行的，Instagram 所奉行的开发哲学是：&lt;strong&gt;『不管是多大的新特性或代码重构，都应该拆解成较小的 Commit 来进行。』&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那些被合并进 master 分支的代码，都将在一个小时内被发布到线上环境。**而这样的发布过程每天将会发生上百次。**在这么频繁的发布频率下，如何在满足之前的那两个前提下来完成迁移变得尤其困难。&lt;/p&gt;
&lt;h4 id=&#34;被弃用的迁移方案&#34;&gt;被弃用的迁移方案&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;创建一个新分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人在处理这类问题时，第一个蹦进脑子的想法就是： &lt;em&gt;『让我们创建一个分支，当我们开发完后，再把分支合并进来』&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;但在 Instagram 这么高的迭代频率上，使用一个独立分支并不是好主意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instagram 的 Codebase 每天都在频繁更新，在开发 Python 3 分支的过程中，让新分支与现有 master 分支保持同步开销极大，同时极易出错&lt;/li&gt;
&lt;li&gt;最终将 Python 3 分支这个改动非常多的分支合并回 Master 拥有非常高的风险&lt;/li&gt;
&lt;li&gt;只有少数几个工程师在 Python 3 分支上专职负责升级工作，其他想帮助迁移工作的工程师无法参与进来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;挨个替换接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有一个方案就是，挨个替换 Instagram 的 API 接口。但是 Instagram 的不同接口共享着很多通用模块。这个方案要实施起来也非常困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有一个方案就是将 Instagram 改造成微服务架构。通过将那些通用模块重写成 Python 3 版本的微服务来一步步完成迁移工作。&lt;/p&gt;
&lt;p&gt;但是这个方案需要重新组织海量的代码。同时，当发生在进程内的函数调用变成 RPC 后 ，整个站点的延迟会变大。此外，更多的微服务也会引入更高的部署复杂度。&lt;/p&gt;
&lt;p&gt;所以，既然 Instagram 的开发哲学是：&lt;strong&gt;小步前进，快速迭代&lt;/strong&gt;。他们最终决定的方案是：&lt;strong&gt;一步一步来，最终让 master 分支上的代码同时兼容 Python 2 和 Python 3 。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;开始迁移工作&#34;&gt;开始迁移工作&lt;/h3&gt;
&lt;p&gt;既然要让整个 codebase 同时兼容 Python 2 和 Python 3，那么首先要符合这点的就是那些被大量使用的第三方 package。针对第三方 package，Instagram 做到了下面几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拒绝引入所有不兼容 Python 3 的新 package&lt;/li&gt;
&lt;li&gt;去掉所有不再使用的 package&lt;/li&gt;
&lt;li&gt;替换那些不兼容 Python 3 的 package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在代码的迁移过程中，他们使用了工具 &lt;a href=&#34;https://python-modernize.readthedocs.io/en/latest/&#34;&gt;modernize&lt;/a&gt; 来帮助他们。&lt;/p&gt;
&lt;p&gt;使用 modernize 时，有一个小技巧：&lt;strong&gt;每次修复多个文件的一个兼容问题，而不是一下修复一个文件中的多个兼容问题。&lt;/strong&gt; 这样可以让 Code Review 过程简单很多，因为 Reviewer 每次只需要关注一个问题。&lt;/p&gt;
&lt;h3 id=&#34;使用单元测试来帮助迁移&#34;&gt;使用单元测试来帮助迁移&lt;/h3&gt;
&lt;p&gt;对于 Python 这种灵活性极强的动态语言来说，除了真正去执行代码外，几乎没有其他比较好的检查代码错误的手段。&lt;/p&gt;
&lt;p&gt;前面提到，Instagram 所有被合并到 master 的代码提交会在一个小时内上线到线上环境，但这不是没有前提条件的。&lt;strong&gt;在上线前，所有的提交都需要通过成千上万个单元测试。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是，他们开始加入 Python 3 来执行所有的单元测试。一开始，只有极少数的单元测试能够在 Python 3 环境下通过，但随着 Instagram 的工程师们不断的修复那些失败的单元测试，最终所有的单元测试都可以在 Python 3 环境下成功执行。&lt;/p&gt;
&lt;h4 id=&#34;单元测试的局限性&#34;&gt;单元测试的局限性&lt;/h4&gt;
&lt;p&gt;但是，单元测试也是有局限性的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instagram 的单元测试没有做到 100% 的代码覆盖率&lt;/li&gt;
&lt;li&gt;很多第三方模块都使用了 mock 技术，而 mock 的行为与真实的线上服务可能会有所不同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，当所有的单元测试都被修复后，他们开始在线上正式使用 Python 3 来运行服务。&lt;/p&gt;
&lt;p&gt;这个过程并不是一蹴而就的。首先，所有的 Instagram 工程师开始访问到这些使用 Python 3 来执行的新服务，然后是 Facebook 的所有雇员，随后是 0.1%、20% 的用户，最终 Python 3 覆盖到了所有的 Instagram 用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.zlovezl.cn/static//uploaded/2017/05/2017-05-29-09-35-43_thumb.jpg&#34; alt=&#34;图：循序渐进的发布流程&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;迁移过程的技术问题&#34;&gt;迁移过程的技术问题&lt;/h3&gt;
&lt;p&gt;Instagram 在迁移到 Python 3 时碰到很多问题，下面是最典型的几个：&lt;/p&gt;
&lt;h4 id=&#34;unicode-相关的字符串问题&#34;&gt;Unicode 相关的字符串问题&lt;/h4&gt;
&lt;p&gt;Python 3 相比 Python 2 最大的改动之一，就是在语言内部对 unicode 的处理。&lt;/p&gt;
&lt;p&gt;在 Python 2 中，文本类型 &lt;em&gt;（也就是 unicode）&lt;/em&gt; 和二进制类型 &lt;em&gt;（也就是 str）&lt;/em&gt; 的边界非常模糊。很多函数的参数既可以是文本，也可以是二进制。但是在 Python 3 中，文本类型和二进制类型的字符串被完全的区分开了。&lt;/p&gt;
&lt;p&gt;于是，下面这段在 Python 2 下可以正常运行的代码在 Python 3 下就会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mymac = hmac.new(&#39;abc&#39;)
TypeError: key: expected bytes or bytearray, but got &#39;str&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决办法其实很简单，只要加上判断：如果 value 是文本类型，就将其转换为二进制。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value = &#39;abc&#39;
if isinstance(value, six.text_type):
    value = value.encode(encoding=&#39;utf-8&#39;)
mymac = hmac.new(value)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，在整个代码库中，像上面这样的情况非常多。作为开发人员，如果需要在调用每个函数时都要想想： &lt;em&gt;这里到底是应该编码成二进制，或者是解码成文本呢？&lt;/em&gt; 将会是非常大的负担。&lt;/p&gt;
&lt;p&gt;于是 Instagram 封装了一些名为 &lt;code&gt;ensure_str()&lt;/code&gt;、&lt;code&gt;ensure_binary()&lt;/code&gt;、&lt;code&gt;ensure_text()&lt;/code&gt; 的帮助函数，开发人员只需对那些不确定类型的字符串，使用这些帮助函数先做一次转换就好。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mymac = hmac.new(ensure_binary(&#39;abc&#39;))
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;不同-python-版本的-pickle-差异&#34;&gt;不同 Python 版本的 pickle 差异&lt;/h4&gt;
&lt;p&gt;Instagram 的代码中大量使用了 pickle。比如用它序列化某个对象，然后将其存储在 memcache 中。如下面的代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memcache_data = pickle.dumps(data, pickle.HIGHEST_PROTOCOL)
data = pickle.loads(memcache_data)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问题在于，Python 2 与 Python 3 的 pickle 模块是有差别的。&lt;/p&gt;
&lt;p&gt;如果上文的第一行代码，刚好是由 Python 3 运行的服务进行序列化后存入 memcache。而反序列化的过程却是由 Python 2 进行，那代码运行时就会出现下面的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ValueError: unsupported pickle protocol: 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是由于在 Python 3 中，&lt;code&gt;pickle.HIGHEST_PROTOCOL&lt;/code&gt; 的值为 &lt;code&gt;4&lt;/code&gt;，而 Python 2 中的的 pickle 最高支持的版本号却是 &lt;code&gt;2&lt;/code&gt;。那么如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;Instagram 最终选择让 Python 2 和 Python 3 使用完全不同的 namespace 来访问 memcache。通过将二者的数据读写完全隔开来解决这个问题。&lt;/p&gt;
&lt;h4 id=&#34;迭代器&#34;&gt;迭代器&lt;/h4&gt;
&lt;p&gt;在 Python 3 中，很多内置函数被修改成了只返成迭代器 Iterator：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map()
filter()
dict.items()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;迭代器有诸多好处，最大的好处就是，使用迭代器不需要一次性分配大量内存，所以它的内存效率比较高。&lt;/p&gt;
&lt;p&gt;但是迭代器有一个天然的特点，当你对某个迭代器做了一次迭代，访问完它的内容后，就没法再次访问那些内容了。&lt;strong&gt;迭代器中的所有内容都只能被访问一次。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Instagram 的 Python 3 迁移过程中，就因为迭代器的这个特性被坑了一次，看看下面这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CYTHON_SOURCES = [a.pyx, b.pyx, c.pyx]
builds = map(BuildProcess, CYTHON_SOURCES)
while any(not build.done() for build in builds):
    pending = [build for build in builds if not build.started()]
    &amp;lt;do some work&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码的用处是挨个编译 Cython 源文件。当他们把运行环境切换到 Python 3 后，一个奇怪的问题出现了：**CYTHON_SOURCES 中的第一个文件永远都被跳过了编译。**为什么呢？&lt;/p&gt;
&lt;p&gt;这都是迭代器的锅。在 Python 3 中，&lt;code&gt;map()&lt;/code&gt; 函数不再返回整个 list，而是返回一个迭代器。&lt;/p&gt;
&lt;p&gt;于是，当第二行代码生成 builds 这个迭代器后，第三行代码的 while 循环迭代了 builds，刚好取出了第一个元素。&lt;strong&gt;于是之后的 pending 对象便里面永远少了那第一个元素。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题解决起来也挺简单的，你只要手动的吧 builds 转换成 list 就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;builds = list(map(BuildProcess, CYTHON_SOURCES))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是这类 bug 非常难定位到。如果用户的 feeds 里面永远少了那最新的第一条，用户很少会注意到。&lt;/p&gt;
&lt;h4 id=&#34;字典的顺序&#34;&gt;字典的顺序&lt;/h4&gt;
&lt;p&gt;看看下面这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; testdict = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&amp;gt;&amp;gt;&amp;gt; json.dumps(testdict)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它会输出什么结果呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2
&#39;{&amp;quot;a&amp;quot;: 1, &amp;quot;c&amp;quot;: 3, &amp;quot;b&amp;quot;: 2}&#39;
# Python 3.5.1
&#39;{&amp;quot;c&amp;quot;: 3, &amp;quot;b&amp;quot;: 2, &amp;quot;a&amp;quot;: 1}&#39;    # or
&#39;{&amp;quot;c&amp;quot;: 3, &amp;quot;a&amp;quot;: 1, &amp;quot;b&amp;quot;: 2}&#39;
# Python 3.6
&#39;{&amp;quot;a&amp;quot;: 1, &amp;quot;b&amp;quot;: 2, &amp;quot;c&amp;quot;: 3}&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在不同的 Python 版本下，这个 json dumps 的结果是完全不一样的。甚至在 3.5.1 中，它会完全随机的返回两个不同的结果。Instagram 有一段判断配置文件是否发生变动的模块，就是因为这个原因出了问题。&lt;/p&gt;
&lt;p&gt;这个问题的解决办法是，在调用 &lt;code&gt;json.dumps&lt;/code&gt; 传入 &lt;code&gt;sort_keys=True&lt;/code&gt; 参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps(testdict, sort_keys=True)
&#39;{&amp;quot;a&amp;quot;: 1, &amp;quot;b&amp;quot;: 2, &amp;quot;c&amp;quot;: 3}&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;迁移到-python-36-后的性能提升&#34;&gt;迁移到 Python 3.6 后的性能提升&lt;/h3&gt;
&lt;p&gt;当 Instagram 解决了这些奇奇怪怪的版本差异问题后，还有一个巨大的谜题困扰着他们：&lt;strong&gt;性能问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 Instagram，他们使用两个主要指标来衡量他们的服务性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次请求产生的 CPU 指令数（越低越好）&lt;/li&gt;
&lt;li&gt;每秒能够处理的请求数（越高越好）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，当所有的迁移工作完成后，他们非常惊喜的发现：&lt;strong&gt;第一个性能指标，每次请求产生的 CPU 指令数居然足足下降了 12% ！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，按理说第二个指标 - 每秒请求数也应该获得接近 12% 的提升。不过最后的变化却是 0%。究竟是出了什么问题呢？&lt;/p&gt;
&lt;p&gt;他们最终定位到，是由于不同 Python 版本下的内存优化配置不同，导致 CPU 指令数下降带来的性能提升被抵消了。那为什么不同 Python 版本下的内存优化配置会不一样呢？&lt;/p&gt;
&lt;p&gt;这是他们用来检查 uwsgi 配置的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if uwsgi.opt.get(&#39;optimize_mem&#39;, None) == &#39;True&#39;:
    optimize_mem()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意到那段 &lt;code&gt;... ... == &#39;True&#39;&lt;/code&gt; 了吗？在 Python 3 中，这个条件判断总是不会被满足。问题就在于 unicode。在将代码中的 &lt;code&gt;&#39;True&#39;&lt;/code&gt; 换成 &lt;code&gt;b&#39;True&#39;&lt;/code&gt;（也就是将文本类型换成二进制，这种判断在 Python 2 中完全不区分的）后，问题解决了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，最终因为加上了一个小小的字母 &amp;lsquo;b&amp;rsquo;，程序的整体性能提升了 12%。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;在今年二月份，Instagram 的后端代码的运行环境完全切换到了 Python 3 下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.zlovezl.cn/static//uploaded/2017/05/2017-05-30-15-51-20_thumb.jpg&#34; alt=&#34;图：Instagram 版本迁移时间线&#34;&gt;&lt;/p&gt;
&lt;p&gt;当所有的代码都都迁移到 Python 3 运行环境后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节约了 12% 的整体 CPU 使用率（Django/uwsgi）&lt;/li&gt;
&lt;li&gt;节约了 30% 的内存使用（celery）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，在整个迁移期间，Instagram 的月活用户经历了从 4 亿到 6亿 的巨大增长。产品也发布了评论过滤、直播等非常多新功能。&lt;/p&gt;
&lt;p&gt;那么，那几个最开始驱动他们迁移到 Python 3 的目的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型注解&lt;/strong&gt;：Instagram 的整个 codebase 里已经有 2% 的代码添加上了类型注解，同时他们还开发了一些工具来辅助开发者添加类型提示&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;asyncio&lt;/strong&gt;：他们在单个接口中利用 asynio 平行的去做多件事情，最终降低了 20-30% 的请求延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;社区&lt;/strong&gt;：他们与 Intel 的工程师联合，帮助他们更好的对 CPU 利用率进行调优。同时还开发了很多新的工具，帮助他们进行性能调优&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;instagram-带给我们的启示&#34;&gt;Instagram 带给我们的启示&lt;/h2&gt;
&lt;p&gt;Instagram 的演讲视频时间不长，但是内容很丰富，在编写此文前，我完全没有想到最终的文章会这么长。&lt;/p&gt;
&lt;p&gt;那么，Instagram 的视频可以给我们哪些启示呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python + Django 的组合完全可以负载用户数以 10 亿记的服务，如果你正准备开始一个项目，放心使用 Python 吧！&lt;/li&gt;
&lt;li&gt;完善的单元测试对于复杂项目是非常有必要的。如果没有那『成千上万的单元测试』。很难想象 Instagram 的迁移项目可以成功进行下去。&lt;/li&gt;
&lt;li&gt;开发者和同事也是你的产品用户，利用好他们。用他们为你的新特性发布前多一道测试。&lt;/li&gt;
&lt;li&gt;完全基于主分支的开发流程，可以给你更快的迭代速度。前提是拥有完善的单元测试和持续部署流程。&lt;/li&gt;
&lt;li&gt;Python 3 是大势所趋，如果你正准备开始一个新项目，无需迟疑，拥抱 Python 3 吧！&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Offer18删除链表的节点</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Mon, 20 Jul 2020 22:49:28 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;剑指-offer-18-删除链表的节点httpsleetcode-cncomproblemsshan-chu-lian-biao-de-jie-dian-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/&#34;&gt;剑指 Offer 18. 删除链表的节点&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;返回删除后的链表的头节点。&lt;/p&gt;
&lt;p&gt;**注意：**此题对比原题有改动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目保证链表中节点的值互不相同&lt;/li&gt;
&lt;li&gt;若使用 C 或 C++ 语言，你不需要 &lt;code&gt;free&lt;/code&gt; 或 &lt;code&gt;delete&lt;/code&gt; 被删除的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;思路&#34;&gt;思路：&lt;/h4&gt;
&lt;p&gt;删除值为 val 的节点可分为两步：定位节点、修改引用。&lt;/p&gt;
&lt;p&gt;定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。
修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/0091d27673ec013c5557c7f9e7c731d3437f0ce655439269a6e24ce501235e4b-Picture0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法流程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。
2.初始化： pre = head , cur = head.next 。
3.定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。
4.保存当前节点索引，即 pre = cur 。
5.遍历下一节点，即 cur = cur.next 。
6.删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next 。（若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。
7.返回值： 返回链表头部节点 head 即可。


&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# @Time     : 2020/7/18 23:44
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : offer18.py
# @Software : PyCharm 

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def deleteNode(self, head, val):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        &amp;quot;&amp;quot;&amp;quot;
        if head.val == val:
            return head.next
        pre, cur = head, head.next
        while cur and cur.val != val:
            pre, cur = cur, cur.next
        if cur:
            pre.next = cur.next
        return head


def create_link(tmp):
    cur = head = None
    for i in tmp:
        node = ListNode(i)
        if head is None:
            head = node
            cur = head
        else:
            cur.next = node
            cur = cur.next

    return head


def traversal_link(head):
    cur = head
    while cur:
        print(cur.val)
        cur = cur.next


if __name__ == &#39;__main__&#39;:
    head = create_link([4, 5, 1, 9])
    traversal_link(head)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>876 链表的中间结点</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</guid>
                <pubDate>Thu, 16 Jul 2020 22:55:17 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;876-链表的中间结点httpsleetcode-cncomproblemsmiddle-of-the-linked-list&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/middle-of-the-linked-list/&#34;&gt;876. 链表的中间结点&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给定一个带有头结点 &lt;code&gt;head&lt;/code&gt; 的非空单链表，返回链表的中间结点。&lt;/p&gt;
&lt;p&gt;如果有两个中间结点，则返回第二个中间结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定链表的结点数介于 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;100&lt;/code&gt; 之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：数组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;方法二：单指针法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我们可以对方法一进行空间优化，省去数组 A。

我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;方法三：快慢指针法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# @Time     : 2020/7/16 23:03
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 876.py
# @Software : PyCharm 

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def middleNode(self, head):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :rtype: ListNode
        &amp;quot;&amp;quot;&amp;quot;
        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        return slow


def create_link(tmp):
    head = None
    cur = None
    for i in tmp:
        node = ListNode(i)
        if head is None:
            head = node
            cur = head
        else:
            cur.next = node
            cur = cur.next
    return head


def traversal_link(head):
    cur = head
    while cur:
        print(cur.val)
        cur = cur.next


if __name__ == &#39;__main__&#39;:
    head = create_link([1, 2, 3, 4, 5])
    solution = Solution()
    node = solution.middleNode(head)
    print(node.val)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>0201 移除重复节点</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Thu, 16 Jul 2020 22:42:51 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;面试题-0201-移除重复节点httpsleetcode-cncomproblemsremove-duplicate-node-lcci&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-duplicate-node-lcci/&#34;&gt;面试题 02.01. 移除重复节点&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链表长度在[0, 20000]范围内。&lt;/li&gt;
&lt;li&gt;链表元素在[0, 20000]范围内。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不得使用临时缓冲区，该怎么解决？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;哈希-on&#34;&gt;哈希 O(n)&lt;/h4&gt;
&lt;p&gt;哈希表存储出现过的元素，如果当前节点出现过，就删掉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;双指针&#34;&gt;双指针&lt;/h4&gt;
&lt;p&gt;固定p指针，右侧q指针扫描，然后移动p，指针q再次扫描
时间复杂度 O(n^2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeDuplicateNodes(self, head):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :rtype: ListNode
        &amp;quot;&amp;quot;&amp;quot;
        p = head
        while p:
            q = p
            while q.next:
                if q.next.val == p.val:
                    q.next = q.next.next
                else:
                    q = q.next
            p = p.next

        return head


def create_link(tmp):
    head = None
    cur = None
    for i in tmp:
        node = ListNode(i)
        if head is None:
            head = node
            cur = head
        else:
            cur.next = node
            cur = cur.next
    return head


def traversal_link(head):
    cur = head
    while cur:
        print(cur.val)
        cur = cur.next


if __name__ == &#39;__main__&#39;:
    head = create_link([1, 2, 3, 3, 2, 1])
    # traversal_link(head)
    solution = Solution()
    result = solution.removeDuplicateNodes(head)
    traversal_link(result)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Offer24 反转链表</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Thu, 16 Jul 2020 22:24:25 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;剑指-offer-24-反转链表httpsleetcode-cncomproblemsfan-zhuan-lian-biao-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/&#34;&gt;剑指 Offer 24. 反转链表&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 &amp;lt;= 节点个数 &amp;lt;= 5000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def reverseList(self, head):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :rtype: ListNode
        &amp;quot;&amp;quot;&amp;quot;
        cur = head
        pre = None
        while cur:
            after = cur.next
            cur.next = pre
            pre = cur
            cur = after
        return pre


def create_link(tmp):
    head = None
    cur = None
    for i in tmp:
        node = ListNode(i)
        if head is None:
            head = node
            cur = head
        else:
            cur.next = node
            cur = cur.next
    return head


def traversal_link(head):
    cur = head
    while cur:
        print(cur.val)
        cur = cur.next


if __name__ == &#39;__main__&#39;:
    head = create_link([1, 2, 3, 4, 5])
    # traversal_link(head)
    solution = Solution()
    cur = solution.reverseList(head)
    traversal_link(cur)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>1290 二进制链表转整数</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
                <pubDate>Wed, 15 Jul 2020 23:44:39 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1290-二进制链表转整数httpsleetcode-cncomproblemsconvert-binary-number-in-a-linked-list-to-integer&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/&#34;&gt;1290. 二进制链表转整数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。&lt;/p&gt;
&lt;p&gt;请你返回该链表所表示数字的 十进制值 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,0,1]
输出：5
解释：二进制数 (101) 转化为十进制数 (5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [0]
输出：0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1]
输出：1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 4：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
输出：18880
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 5：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [0,0]
输出：0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;链表不为空。
链表的结点总数不超过 30。
每个结点的值不是 0 就是 1。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果一个十进制的数字，999要和1拼接，需要999*10+1 = 999∗10+1=9991
如果一个二进制的数字，110要和1拼接，需要110*2+1 = 110∗2+1=1101 （注意按照二进制的方法计算）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def getDecimalValue(self, head):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        result = 0
        while head:
            result = head.val + (result &amp;lt;&amp;lt; 1)
            head = head.next
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>02.02. 返回倒数第 k 个节点</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Wed, 15 Jul 2020 21:20:33 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;面试题-0202-返回倒数第-k-个节点httpsleetcode-cncomproblemskth-node-from-end-of-list-lcci&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/&#34;&gt;面试题 02.02. 返回倒数第 k 个节点&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;实现一种算法找出单向链表中倒数第-k-个节点返回该节点的值&#34;&gt;实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。&lt;/h4&gt;
&lt;p&gt;注意：本题相对原题稍作改动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2
输出： 4
说明：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定的 k 保证是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经典的快慢指针问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。
设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;class Solution(object):
    def kthToLast(self, head, k):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :type k: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if head is None:
            return None

        left = head
        right = head
        count = 0
        while count &amp;lt; k:
            right = right.next
            count += 1
        while right:
            left = left.next
            right = right.next
        return left.val
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>02.03. 删除中间节点</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0203-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Wed, 15 Jul 2020 21:20:33 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;面试题-0203-删除中间节点httpsleetcode-cncomproblemsdelete-middle-node-lcci&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/delete-middle-node-lcci/&#34;&gt;面试题 02.03. 删除中间节点&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：单向链表a-&amp;gt;b-&amp;gt;c-&amp;gt;d-&amp;gt;e-&amp;gt;f中的节点c
结果：不返回任何数据，但该链表变为a-&amp;gt;b-&amp;gt;d-&amp;gt;e-&amp;gt;f
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def deleteNode(self, node):
        &amp;quot;&amp;quot;&amp;quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        node.val = node.next.val
        node.next = node.next.next
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;解题思路&#34;&gt;解题思路&lt;/h3&gt;
&lt;p&gt;删除当前节点 必须知道prev节点， 这里只能访问当前节点，就只能先将next节点的值赋值给当前结点, 再把next节点干掉&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>0206 回文链表</title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0206-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Wed, 15 Jul 2020 21:20:33 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;面试题-0206-回文链表httpsleetcode-cncomproblemspalindrome-linked-list-lcci&#34;&gt;面试题 02.06. 回文链表](&lt;a href=&#34;https://leetcode-cn.com/problems/palindrome-linked-list-lcci/&#34;&gt;https://leetcode-cn.com/problems/palindrome-linked-list-lcci/&lt;/a&gt;)&lt;/h4&gt;
&lt;p&gt;编写一个函数，检查输入的链表是否是回文的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入： 1-&amp;gt;2
输出： false 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入： 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出： true 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 快慢指针遍历到链表中间，快指针走两步、慢指针走一步，最后慢指针的位置就是链表中间（画个示例图就知道了，虽然我这看的是该题的评论，不太明白，然后画了个图就了解了）
2. 从中间开始反转链表后半段
3. 从原链表头和反转后的链表头开始比较 value
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# @Time     : 2020/7/15 21:27
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 0206.py
# @Software : PyCharm 

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def get_middle(self, head):
        &amp;quot;&amp;quot;&amp;quot;用快慢指针获取中间节点&amp;quot;&amp;quot;&amp;quot;
        left = right = head
        while right and right.next:
            left = left.next
            right = right.next.next
        return left

    def reverse_link(self, head):
        &amp;quot;&amp;quot;&amp;quot;反转链表&amp;quot;&amp;quot;&amp;quot;
        cur = head
        pre = None
        while cur:
            after = cur.next
            cur.next = pre
            pre = cur
            cur = after
        return pre

    def isPalindrome(self, head):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        if head is None:
            return True
        # 获取中间节点
        middle_node = self.get_middle(head)

        # 反转链表
        first = head
        second = self.reverse_link(middle_node)
        while second:
            if first.val != second.val:
                return False
            first = first.next
            second = second.next
        return True


def create_link(tmp):
    head = None
    cur = head
    for val in tmp:
        node = ListNode(val)
        if head is None:
            head = node
            cur = head
        else:
            cur.next = node
            cur = cur.next
    return head


def traversal_link(head):
    while head:
        print(head.val)
        head = head.next


if __name__ == &#39;__main__&#39;:
    head = create_link([1, 1, 1, 1])
    # traversal_link(head)
    solution = Solution()
    result = solution.isPalindrome(head)
    print(result)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>16.11 跳水板</title>
                <link>https://affectalways.github.io/posts/leetcode/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/16.11-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</guid>
                <pubDate>Wed, 08 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。&lt;/p&gt;
&lt;p&gt;返回的长度需要从小到大排列。&lt;/p&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入：
shorter = 1
longer = 2
k = 3
输出： {3,4,5,6}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;提示&#34;&gt;提示：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
0 &amp;lt; shorter &amp;lt;= longer
0 &amp;lt;= k &amp;lt;= 100000

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# @Time     : 2020/7/8 23:06
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 16.11跳水板.py
# @Software : PyCharm 

class Solution:
    def divingBoard(self, shorter: int, longer: int, k: int):
        if k == 0:
            return []
        elif shorter == longer:
            return [k * longer]
        min_length = shorter * k
        max_length = longer * k
        diff = longer - shorter
        result = []
        for i in range(min_length, max_length, diff):
            result.append(i)
        result.append(max_length)

        return result


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.divingBoard(1, 3, 3)
    print(result)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>938 二叉搜索树的范围和</title>
                <link>https://affectalways.github.io/posts/leetcode/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
                <pubDate>Wed, 08 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定二叉搜索树的根结点 &lt;code&gt;root&lt;/code&gt;，返回 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt;（含）之间的所有结点的值的和。&lt;/p&gt;
&lt;p&gt;二叉搜索树保证具有唯一的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;树中的结点数量最多为 10000 个。
最终的答案保证小于 2^31。
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>25 K 个一组翻转链表</title>
                <link>https://affectalways.github.io/posts/leetcode/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/25-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例：

给你这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5

当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5

当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;迭代&#34;&gt;迭代&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def reverseKGroup(self, head, k):
        cur = head
        if cur is None or cur.next is None:
            return cur

        tmp = list()
        while cur:
            tmp.append(cur)
            cur = cur.next

        pre = ListNode(None)
        cur = pre
        length = len(tmp)
        final_node = None
        if length % k &amp;lt; k and length % k != 0:
            final_node = tmp[-(length % k)]
        for node_index in range(k - 1, length, k):
            for key in range(k):
                cur.next = tmp[node_index - key]
                cur = cur.next
        cur.next = final_node
        return pre.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>33 搜索旋转排序数组</title>
                <link>https://affectalways.github.io/posts/leetcode/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解题思路&#34;&gt;解题思路：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;题目要求 O(logN)O(logN) 的时间复杂度，基本可以断定本题是需要使用二分查找，怎么分是关键。
由于题目说数字了无重复，举个例子：
1 2 3 4 5 6 7 可以大致分为两类，
第一类 2 3 4 5 6 7 1 这种，也就是 nums[start] &amp;lt;= nums[mid]。此例子中就是 2 &amp;lt;= 5。
这种情况下，前半部分有序。因此如果 nums[start] &amp;lt;=target&amp;lt;nums[mid]，则在前半部分找，否则去后半部分找。
第二类 6 7 1 2 3 4 5 这种，也就是 nums[start] &amp;gt; nums[mid]。此例子中就是 6 &amp;gt; 2。
这种情况下，后半部分有序。因此如果 nums[mid] &amp;lt;target&amp;lt;=nums[end]，则在后半部分找，否则去前半部分找。

此题有个存在重复数字的变形题，可参考 此题解 。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;代码&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def search(self, nums, target: int) -&amp;gt; int:
        if not nums:
            return -1
        if len(nums) == 1:
            if target in nums:
                return 0
            else:
                return -1
        length = len(nums)
        start = 0
        end = length - 1

        while start &amp;lt;= end:
            mid = start + (end - start) // 2
            if nums[mid] == target:
                return mid

            if nums[start] &amp;lt;= nums[mid]:
            #     前半部分有序
                if target &amp;gt;= nums[start] and target &amp;lt; nums[mid]:
                    end = mid - 1
                else:
                    start = mid + 1
            else:
                if target &amp;lt;= nums[end] and target &amp;gt; nums[mid]:
                    start = mid + 1
                else:
                    end = mid - 1
        return -1
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>39 组合综合</title>
                <link>https://affectalways.github.io/posts/leetcode/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/39-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个&lt;strong&gt;无重复元素&lt;/strong&gt;的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;
&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;所有数字（包括 target）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;回溯法&#34;&gt;回溯法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def combinationSum(self, candidates, target: int):
        if not candidates:
            return []
        result = []

        def isvalid(path, value, target):
            total = sum(path) + value
            if total &amp;gt; target:
                return False
            return True

        def backtrack(path, candidates):
            if sum(path) == target:
                path = sorted(path)
                if path not in result:
                    result.append(path)
                return None

            for value in candidates:
                if not isvalid(path, value, target):
                    continue
                path.append(value)

                backtrack(path, candidates)

                path.pop()

        backtrack([], candidates)
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>40 组合总和 II</title>
                <link>https://affectalways.github.io/posts/leetcode/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii/</guid>
                <pubDate>Thu, 02 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个数组** candidates **和一个目标数** target **，找出** candidates **中所有可以使数字和为** target **的组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;candidates&lt;/strong&gt; 中的每个数字在每个组合中&lt;strong&gt;只能使用一次&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;所有数字（包括目标数）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;回溯法&#34;&gt;回溯法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def combinationSum2(self, candidates, target: int):
        if not candidates:
            return []

        def isvalid(path, value):
            if (sum(path) + value) &amp;gt; target:
                return False
            return True

        def backtrack(path, rest):
            if sum(path) == target:
                path = sorted(path)
                if path not in result:
                    result.append(path)
                return
            for index, value in enumerate(rest):
                if not isvalid(path, value):
                    continue
                path.append(value)
                backtrack(path, rest[index + 1:])
                path.pop()

        result = []
        backtrack([], candidates)
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>22 括号生成</title>
                <link>https://affectalways.github.io/posts/leetcode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
例如，给出 n = 3，生成结果为：
[
  &amp;quot;((()))&amp;quot;,
  &amp;quot;(()())&amp;quot;,
  &amp;quot;(())()&amp;quot;,
  &amp;quot;()(())&amp;quot;,
  &amp;quot;()()()&amp;quot;
]
## 回溯算法

from collections import Counter


class Solution:
    def generateParenthesis(self, n: int):
        self.n = n
        # 结果
        result = []
        # 每次运行的
        track = []
        tmp = []

        def backtrack(path, options):
            if len(path) == n * 2:
                tmp.append(path)
                result.append(&#39;&#39;.join(path))
                return

            for i in range(len(options)):
                if not self.isvalid(path, options[i]):
                    continue
                path.append(options[i])

                backtrack(path, options)

                path.pop()

        backtrack(track, [&#39;(&#39;, &#39;)&#39;])
        return result

    def isvalid(self, path, next):
        if len(path) == 0 and next == &#39;)&#39;:
            return False

        count_dict = Counter(path)
        left_value = count_dict[&#39;(&#39;]
        right_value = count_dict[&#39;)&#39;]
        if next == &#39;)&#39; and right_value + 1 &amp;gt; left_value:
            return False

        for key, value in count_dict.items():
            if key == next and value == self.n:
                return False

        return True


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.generateParenthesis(3)
    print(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>23 合并K个排序链表</title>
                <link>https://affectalways.github.io/posts/leetcode/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;暴力解法&#34;&gt;暴力解法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;遍历所有链表，将所有节点的值放到一个数组中。
将这个数组排序，然后遍历所有元素得到正确顺序的值。
用遍历得到的值，创建一个新的有序链表。
# -*- coding: utf-8 -*-
# @Time     : 2020/3/29 1:14
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 23.py
# @Software : PyCharm 


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        # head = ListNode(-1)
        result = []
        for cur in lists:
            while cur:
                result.append(cur.val)
                cur = cur.next
        head = ListNode(-1)
        cur = head
        result.sort()
        for i in result:
            cur.next = ListNode(i)
            cur = cur.next

        return head.next


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head_1 = ListNode(1)
    node_2 = ListNode(4)
    node_4 = ListNode(5)
    head_1.next = node_2
    node_2.next = node_4

    head_2 = ListNode(1)
    node_3 = ListNode(3)
    node_4_copy = ListNode(4)
    head_2.next = node_3
    node_3.next = node_4_copy

    head_3 = ListNode(2)
    node_6 = ListNode(6)
    head_3.next = node_6

    tmp = [head_1, head_2, head_3]
    result = solution.mergeKLists(tmp)
    while result:
        print(result.val)
        result = result.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>24 两两交换链表中的节点</title>
                <link>https://affectalways.github.io/posts/leetcode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例&#34;&gt;示例:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
# -*- coding: utf-8 -*-
# @Time     : 2020/3/29 14:34
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 24.py
# @Software : PyCharm 

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def swapPairs(self, head):
        cur = head
        if cur is None or cur.next is None:
            return cur

        tmp = list()
        while cur:
            tmp.append(cur)
            cur = cur.next

        pre = ListNode(None)
        cur = pre
        length = len(tmp)
        final_node = None
        if length % 2 == 1:
            final_node = tmp[-1]
        for node_index in range(1, length, 2):
            cur.next = tmp[node_index]
            cur = cur.next
            cur.next = tmp[node_index - 1]
            cur = cur.next
        cur.next = final_node
        return pre.next


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head_1 = ListNode(1)
    node_2 = ListNode(2)
    node_3 = ListNode(3)
    node_4 = ListNode(4)
    head_1.next = node_2
    node_2.next = node_3
    node_3.next = node_4
    result = solution.swapPairs(head_1)

    while result:
        print(result.val)
        result = result.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>41 缺失的第一个正数</title>
                <link>https://affectalways.github.io/posts/leetcode/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [1,2,0]
输出: 3
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [3,4,-1,1]
输出: 2
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [7,8,9,11,12]
输出: 1
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>48 旋转图像</title>
                <link>https://affectalways.github.io/posts/leetcode/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;
&lt;p&gt;你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>54 螺旋矩阵</title>
                <link>https://affectalways.github.io/posts/leetcode/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
                <pubDate>Wed, 01 Jul 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;解决方案&#34;&gt;解决方案&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小

首先设定上下左右边界
其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界
判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案
若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理
不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案
class Solution:
    def spiralOrder(self, matrix):
        if not matrix:
            return matrix
        result = []
        # 高
        row_length = len(matrix)
        # 几列
        col_length = len(matrix[0])

        # 上边界
        up = 0
        # 下边界
        down = row_length
        #         左边界
        left = 0
        #         右边界
        right = col_length

        # 上下游标
        row_cur = 0
        # 左右游标
        col_cur = 0

        while True:
            # print(&amp;quot;left = {}, right = {}, up = {}, down = {}&amp;quot;.format(left, right, up, down))
            for col_cur in range(left, right):
                # print(&amp;quot;1 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新上边界
            up += 1
            if up &amp;gt;= down:
                break

            for row_cur in range(up, down):
                # print(&amp;quot;2 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新右边界
            right -= 1
            if right &amp;lt;= left:
                break

            for col_cur in range(right - 1, left - 1, -1):
                # print(&amp;quot;3 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新下边界
            down -= 1
            if down &amp;lt;= up:
                break

            for row_cur in range(down - 1, up - 1, -1):
                # print(&amp;quot;4 {}&amp;quot;.format(matrix[row_cur][col_cur]))
                result.append(matrix[row_cur][col_cur])
            # 更新左边界
            left += 1
            if left &amp;gt;= right:
                break


        return result

if __name__ == &#39;__main__&#39;:
    solution = Solution()
    matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    matrix = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    matrix = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    result = solution.spiralOrder(matrix)
    print(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Werkzeug 源码解析(1)</title>
                <link>https://affectalways.github.io/posts/werkzeug/werkzeug_sc_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/werkzeug/werkzeug_sc_1/</guid>
                <pubDate>Tue, 23 Jun 2020 23:08:16 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;werkzeug是什么&#34;&gt;Werkzeug是什么？&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Werkzeug&lt;/code&gt;是一个基于&lt;a href=&#34;https://affectalways.github.io/posts/wsgi/wsgi_kl_1/&#34;&gt;WSGI&lt;/a&gt;的Web应用框架（说框架可能不合理，&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/&#34;&gt;官方文档&lt;/a&gt;给出的是&lt;code&gt;应用程序库&lt;/code&gt;）。想要了解更多请看&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;为什么要了解werkzeug&#34;&gt;为什么要了解Werkzeug？&lt;/h1&gt;
&lt;p&gt;因为目前所用的web框架为Flask，而Flask是以Werkzeug为基础的，所以绕不开Werkzeug了。&lt;/p&gt;
&lt;h1 id=&#34;基础知识&#34;&gt;基础知识&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://affectalways.github.io/posts/wsgi/wsgi_kl_1/&#34;&gt;WSGI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;生成器&lt;/li&gt;
&lt;li&gt;非常简单的网络知识&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Werkzeug 源码解析(2)</title>
                <link>https://affectalways.github.io/posts/werkzeug/werkzeug_sc_2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/werkzeug/werkzeug_sc_2/</guid>
                <pubDate>Tue, 23 Jun 2020 23:08:16 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;从哪开始呢&#34;&gt;从哪开始呢？&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;熟悉目录层级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参照&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/&#34;&gt;Werkzeug&lt;/a&gt;官方文档给出的&lt;a href=&#34;https://werkzeug.palletsprojects.com/en/1.0.x/tutorial/#introducing-shortly&#34;&gt;示例&lt;/a&gt;，重点关注&lt;code&gt;Request&lt;/code&gt;,&lt;code&gt;Response&lt;/code&gt;,&lt;code&gt;run_simple&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;werkzeug.wrappers&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;
   
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;application&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;!&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;World&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mimetype&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;text/plain&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
   
   
&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; 省略超多内容
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shortly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Redis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_host&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_port&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dispatch_request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello World!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;wsgi_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dispatch_request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__call__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   
   
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;create_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis_host&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis_port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with_static&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shortly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;
        &lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_host&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;n&#34;&gt;redis_host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s1&#34;&gt;&amp;#39;redis_port&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;n&#34;&gt;redis_port&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with_static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi_app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SharedDataMiddleware&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;s1&#34;&gt;&amp;#39;/static&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dirname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;vm&#34;&gt;__file__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;static&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;
   
   
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;werkzeug.serving&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;run_simple&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;run_simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;use_debugger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;use_reloader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;requestresponserun_simple最不重要的&#34;&gt;Request、Response、run_simple（最不重要的）&lt;/h1&gt;
&lt;p&gt;之后的文章就重点关注以上三个，而且肯定会延伸到Werkzeug的其他地方（源码），不必担心，肯定会有所涉猎。&lt;/p&gt;
&lt;p&gt;讲真，感觉run_simple可以不重点关注，希望不要打脸&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Werkzeug 源码解析(3)</title>
                <link>https://affectalways.github.io/posts/werkzeug/werkzeug_sc_3/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/werkzeug/werkzeug_sc_3/</guid>
                <pubDate>Tue, 23 Jun 2020 23:08:16 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;werkzeug-request-源码解析&#34;&gt;Werkzeug Request 源码解析&lt;/h1&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from werkzeug.wrappers import Request, Response

def application(environ, start_response):
    request = Request(environ)
    text = &#39;Hello %s!&#39; % request.args.get(&#39;name&#39;, &#39;World&#39;)
    response = Response(text, mimetype=&#39;text/plain&#39;)
    return response(environ, start_response)

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意，之后&lt;code&gt;Request&lt;/code&gt;和&lt;code&gt;Response&lt;/code&gt;的相关源码都会围绕&lt;code&gt;Werkzeug&lt;/code&gt;给出的以上代码讲解。&lt;/p&gt;
&lt;h1 id=&#34;request-类&#34;&gt;Request 类&lt;/h1&gt;
&lt;h3 id=&#34;文件定位&#34;&gt;文件定位&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;src/werkzeug/wrappers/request.py&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;根据&lt;code&gt;Request&lt;/code&gt;类的名称其实就可以知道，&lt;code&gt;Request&lt;/code&gt;类是处理请求的，实际上，通过阅读相关代码，&lt;code&gt;Request&lt;/code&gt;类的作用确实如此&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BaseRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;AcceptMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ETagRequestMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;UserAgentMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;AuthorizationMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;CORSRequestMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;CommonRequestDescriptorsMixin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Full featured request object implementing the following mixins:
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`AcceptMixin` for accept header parsing
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`ETagRequestMixin` for etag and cache control handling
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`UserAgentMixin` for user agent introspection
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`AuthorizationMixin` for http auth handling
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`~werkzeug.wrappers.cors.CORSRequestMixin` for Cross
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;        Origin Resource Sharing headers
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -   :class:`CommonRequestDescriptorsMixin` for common headers
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;​	根据注释可知，除了&lt;code&gt;BaseRequest&lt;/code&gt;类之外，其他的&lt;code&gt;Mixin&lt;/code&gt;类都是作为添加&lt;code&gt;高级方法&lt;/code&gt;的类。而且&lt;code&gt;Request&lt;/code&gt;类也没有&lt;code&gt;初始化&lt;/code&gt;方法，所以可以将注意力从&lt;code&gt;Request&lt;/code&gt;转移到&lt;code&gt;BaseRequest&lt;/code&gt;类上面。&lt;/p&gt;
&lt;h1 id=&#34;baserequest-类&#34;&gt;BaseRequest 类&lt;/h1&gt;
&lt;p&gt;截取以上代码示例的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request = Request(environ)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用父类&lt;code&gt;BaseRequest&lt;/code&gt;的&lt;code&gt;__init__&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;populate_request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;populate_request&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;werkzeug.request&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;
        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shallow&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/werkzeug/">werkzeug</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>02 两数相加</title>
                <link>https://affectalways.github.io/posts/leetcode/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &amp;quot;&amp;quot;&amp;quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &amp;quot;&amp;quot;&amp;quot;
        list_1 = &amp;quot;&amp;quot;
        list_2 = &amp;quot;&amp;quot;
        if not l1 and not l2:
            return 0

        while l1:
            list_1 += str(l1.val)
            l1 = l1.next
        num_1 = int(list_1[::-1]) if list_1 else 0
        while l2:
            list_2 += str(l2.val)
            l2 = l2.next
        num_2 = int(list_2[::-1]) if list_2 else 0
        sum = list(str(num_1 + num_2)[::-1])
        head = ListNode(sum[0])
        cur = head
        for i in range(1, len(sum)):
            cur.next = ListNode(sum[i])
            cur = cur.next
        return head
            
        
    
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>03 无重复字符的最长子串</title>
                <link>https://affectalways.github.io/posts/leetcode/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h5 id=&#34;给定一个字符串请你找出其中不含有重复字符的-最长子串-的长度&#34;&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/h5&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;abcabcbb&amp;quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解决方法可以进行改进&#34;&gt;解决方法（可以进行改进）&lt;/h4&gt;
&lt;h4 id=&#34;采用-滑动窗口-算法详见html&#34;&gt;采用 滑动窗口 算法，详见html&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def lengthOfLongestSubstring(self, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if not s:
            return 0
        uq = set(s)
        uq_length = len(uq)
        windows = s[0]
        left = 0
        right = 1
        max_len = 1
        for i in range(1, len(s)):
            flag_index = windows.find(s[i])
            if flag_index == -1:
                windows += s[i]
                right += 1
            else:
                left = flag_index + 1
                right += 1
                windows = windows[left:] + s[i]
            if max_len &amp;lt; len(windows):
                max_len = len(windows)
        return max_len
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>04 寻找两个有序数组的中位数</title>
                <link>https://affectalways.github.io/posts/leetcode/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        &amp;quot;&amp;quot;&amp;quot;
        nums1.extend(nums2)
        nums1.sort()
        length = len(nums1)
        if length % 2 == 1:
            return float(nums1[length // 2])
        else:
            return float(((nums1[length // 2] + nums1[length // 2 - 1])) / 2)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>05 马拉车算法</title>
                <link>https://affectalways.github.io/posts/leetcode/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/05-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liuwei0604/article/details/50414542&#34;&gt;https://blog.csdn.net/liuwei0604/article/details/50414542&lt;/a&gt; 马拉车算法可以在线性时间复杂度内求出一个字符串的最长回文字串。其核心思想跟 KMP 相似，即反复利用已掌握的情况。&lt;/p&gt;
&lt;h3 id=&#34;1整体思路&#34;&gt;1.整体思路&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;这个算法的主要思路是维护一个跟原串 str 一样长的数组 lens。lens[i] 表示以 str[i] 为中点的回串其中一边的长度。这里有的人把中点算进去，有的人记录两边的长度，其实都一样，我这里是只记录一边的长度，不包括中点。比如 &amp;quot;CDCDE&amp;quot;
str:  [C, D, C, D, E]
lens: [0, 1, 1, 0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么 lens 里最大的自然就对应最长回串的中点了。所以这个算法的核心就是如何快速计算 lens。&lt;/p&gt;
&lt;h3 id=&#34;2预处理&#34;&gt;2.预处理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;回文有奇偶长度两种情况，通过补充间隔符可以将这两种情况化简为奇数长度。

比如 ABA 补充为 #A#B#A# 中点还是 B，ABBA 补充为 #A#B#B#A# 中点为 #，最后可以去掉。

算法用 JavaScript 写，我将原串转为数组，间隔符就用 null。

最后在两侧补上哨兵点方便遍历中止。我用了 NaN。所以看起来是这样
var arr = [NaN, null]
for (let i = 0; i &amp;lt; str.length; i += 1) {
  arr.push(str[i])
  arr.push(null)
}
arr.push(NaN)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3详解&#34;&gt;3.详解&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。

首先我们解决下奇数和偶数的问题，在每个字符间插入 &amp;quot;#&amp;quot;，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 &amp;quot;^&amp;quot; 和 &amp;quot;$&amp;quot;，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。
马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。

首先我们解决下奇数和偶数的问题，在每个字符间插入 &amp;quot;#&amp;quot;，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 &amp;quot;^&amp;quot; 和 &amp;quot;$&amp;quot;，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/ad2b5e0da4a3a35b60f60c9a5a2be07a8074f9be0fe1597351eeff7dc460789a-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 &amp;quot;#&amp;quot; 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 &amp;quot;#c#b#c#b#c#&amp;quot;。而去掉 # 恢复到原来的字符串，变成 &amp;quot;cbcbc&amp;quot;，它的长度刚好也就是 5。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/ae2c30d48d35faa7f3d0d8bc4fe18d0691f3d13dcfc5846ddce1bf7a002681f5-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4求原字符串下标&#34;&gt;4.求原字符串下标&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。

例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;5求每个-p--i-&#34;&gt;5.求每个 P [ i ]&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;接下来是算法的关键了，它充分利用了回文串的对称性。

我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。

让我们考虑求 P [ i ] 的时候，如下图。

用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/29eb66280ca149c3bf5d9906e066b4a2b39d1bf8f9dd0533ca00479aca6f4f39-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。

但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;1超出了r&#34;&gt;(1)超出了R&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/b0d52a5f30747e55ef09b3c7b7cfc23026e37040edc41f387263e8f8a0ba8f49-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2-p--i_mirror--遇到了原字符串的左边界&#34;&gt;(2) P [ i_mirror ] 遇到了原字符串的左边界&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 &amp;quot;#&amp;quot; == &amp;quot;#&amp;quot;，之后遇到了 &amp;quot;^&amp;quot; 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3i-等于了-r&#34;&gt;(3)i 等于了 R&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;6考虑-c-和-r-的更新&#34;&gt;6.考虑 C 和 R 的更新&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/5fbe52880634a9d5fa60ad5e126e8c5c38c5a6eadd0c901a3495dc1307d46d6b-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。
public String preProcess(String s) {
    int n = s.length();
    if (n == 0) {
        return &amp;quot;^$&amp;quot;;
    }
    String ret = &amp;quot;^&amp;quot;;
    for (int i = 0; i &amp;lt; n; i++)
        ret += &amp;quot;#&amp;quot; + s.charAt(i);
    ret += &amp;quot;#$&amp;quot;;
    return ret;
}

// 马拉车算法
public String longestPalindrome2(String s) {
    String T = preProcess(s);
    int n = T.length();
    int[] P = new int[n];
    int C = 0, R = 0;
    for (int i = 1; i &amp;lt; n - 1; i++) {
        int i_mirror = 2 * C - i;
        if (R &amp;gt; i) {
            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R
        } else {
            P[i] = 0;// 等于 R 的情况
        }

        // 碰到之前讲的三种情况时候，需要利用中心扩展法
        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {
            P[i]++;
        }

        // 判断是否需要更新 R
        if (i + P[i] &amp;gt; R) {
            C = i;
            R = i + P[i];
        }

    }

    // 找出 P 的最大值
    int maxLen = 0;
    int centerIndex = 0;
    for (int i = 1; i &amp;lt; n - 1; i++) {
        if (P[i] &amp;gt; maxLen) {
            maxLen = P[i];
            centerIndex = i;
        }
    }
    int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标
    return s.substring(start, start + maxLen);
}
class Solution:
    def longestPalindrome(self, s):
        format_s = self.pre_process(s)
        length = len(format_s)
        ps = [0] * length

        center = 0
        right = 0
        for current in range(1, length - 1):
            current_mirror = 2 * center - current
            if (current + ps[current_mirror]) &amp;lt; right and (current_mirror - 1) != 0:
                ps[current] = ps[current_mirror]
            elif (current + ps[current_mirror]) &amp;lt; right and (current_mirror - 1) == 0:
                i = 1
                while (current - i) &amp;gt;= 0 and (current + i) &amp;lt; length and format_s[current - i] == format_s[current + i]:
                    ps[current] += 1
                    i+=1
                if ps[current] &amp;lt; ps[current_mirror]:
                    ps[current] = ps[current_mirror]
            else:
                i = 1
                while (current - i) &amp;gt;= 0 and (current + i) &amp;lt; length and format_s[current - i] == format_s[
                    current + i]:
                    ps[current] += 1
                    i += 1

            if ps[current] + center &amp;gt; right:
                center = current
                right = ps[current] + center

        max_length = 0
        center_index = 0
        for i in range(1, length -1):
            if ps[i] &amp;gt; max_length:
                max_length = ps[i]
                center_index = i
        start = (center_index - max_length) // 2
        return s[start:start + max_length]

    def pre_process(self, s):
        result = &amp;quot;#&amp;quot;
        for i in range(len(s)):
            result += s[i]
            result += &#39;#&#39;
        return result


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.longestPalindrome(&amp;quot;ababcbab&amp;quot;)
    print(result)
时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O ( n )。

空间复杂度：O(n)。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;时间复杂度从三次方降到了一次，美妙！这里两次用到了动态规划去求解，初步认识了动态规划，就是将之前求的值保存起来，方便后边的计算，使得一些多余的计算消失了。并且在动态规划中，通过观察数组的利用情况，从而降低了空间复杂度。而 Manacher 算法对回文串对称性的充分利用，不得不让人叹服，自己加油啦

作者：windliang
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>06 Z 字形变换</title>
                <link>https://affectalways.github.io/posts/leetcode/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/06-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &amp;ldquo;LEETCODEISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L   C   I   R
E T O E S I I G
E   D   H   N
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;ldquo;LCIRETOESIIGEDHN&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string convert(string s, int numRows);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 3
输出: &amp;quot;LCIRETOESIIGEDHN&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 4
输出: &amp;quot;LDREOEIIECIHNTSG&amp;quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;h4 id=&#34;算法&#34;&gt;算法:&lt;/h4&gt;
&lt;p&gt;这个 Z 字型其实是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/810b316c74a8eb0d2c97cbfc1bcf7559811f73b1bbed92848ba1bb7b9f1691b1-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于前面的 3行的 示例1 , 它的字符数分布是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/01f701396440902b127931f5a1a8a9ecbf70a9dc43ba2b7752a8756b8393e521-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于前面的 4 行的 示例2 , 它的字符数分布是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/89ba53b0da11c91a66dbb05a75e4b9d83e853bbe3a82c7860cde1a6c1e0c9c8e-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么对于 n 行的字符数分布是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/d610b140dd0789204efe699672dc72a83e7b826da0165bbf083d24fc97ecdea7-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我们可以发现：&lt;/p&gt;
&lt;h4 id=&#34;1当前行-currow-为-0-或-n-1-时箭头发生反向转折&#34;&gt;1.当前行 curRow 为 0 或 n-1 时，箭头发生反向转折。&lt;/h4&gt;
&lt;p&gt;方法一： 从左到右按箭头方向迭代 s ，将每个字符添加到合适的行。之后从上到下遍历行即可。&lt;/p&gt;
&lt;p&gt;我们假定 n=numRows :&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def convert(self, s, numRows):
        length = len(s)
        row_num = numRows
        if length &amp;lt;= row_num or row_num == 1:
            return s
        result = [&#39;&#39;]*row_num
        turn = False
        current = 0
        for c in s:
            result[current] += c
            if current == 0 or current == (row_num - 1):
                turn = not turn
            current += 1 if turn else -1
        r = &#39;&#39;
        for s in result:
            r += s
        return r

if __name__ == &#39;__main__&#39;:
    solution = Solution()
    solution.convert(&#39;LEETCODEISHIRING&#39;, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为只需遍历一次，所以时间复杂度为 &lt;code&gt;O(len(s))&lt;/code&gt;‘O(len(s))‘&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>07 整数反转</title>
                <link>https://affectalways.github.io/posts/leetcode/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: -123
输出: -321
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
class Solution:
    def reverse(self, x):
        &amp;quot;&amp;quot;&amp;quot;
        :type x: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        flag = True
        if x &amp;lt; 0:
            flag = False

        tmp = str(x)[::-1] if flag else &#39;-&#39; + str(x)[1:][::-1]
        result = int(tmp)
        if result &amp;lt; -2 ** 31 or result &amp;gt; (2 ** 31 - 1):
            return 0
        else:
            return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>08 字符串转换整数</title>
                <link>https://affectalways.github.io/posts/leetcode/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;
&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。&lt;/p&gt;
&lt;p&gt;该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。&lt;/p&gt;
&lt;p&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。&lt;/p&gt;
&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;42&amp;quot;
输出: 42
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;   -42&amp;quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;4193 with words&amp;quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;words and 987&amp;quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-5&#34;&gt;示例 5:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;-91283472332&amp;quot;
输出: -2147483648
解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−2^31) 。
class Solution:
    def myAtoi(self, str):
        fixed = str.strip()
        if not fixed:
            return 0

        symbol = [&#39;+&#39;, &#39;-&#39;]
        result = &#39;&#39;
        for i in range(0, len(fixed)):
            if fixed[i] == &#39;+&#39; and i == 0:
                continue
            elif (fixed[i] == &#39;-&#39; and i == 0) or fixed[i].isdigit():
                result += fixed[i]
            else:
                break
        if not result or result == &#39;-&#39; or result == &#39;+&#39;:
            return 0
        int_max = 2 ** 31 - 1
        int_min = -2 ** 31
        if int(result) &amp;gt; int_max:
            return int_max
        elif int(result) &amp;lt; int_min:
            return int_min
        return int(result)


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.myAtoi(&amp;quot;  0000000000012345678&amp;quot;)
    print(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>09 回文数</title>
                <link>https://affectalways.github.io/posts/leetcode/09-%E5%9B%9E%E6%96%87%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/09-%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 121
输出: true
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
进阶:

你能不将整数转为字符串来解决这个问题吗？
class Solution:
    def isPalindrome(self, x):
        &amp;quot;&amp;quot;&amp;quot;
        :type x: int
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        if str(x) == str(x)[::-1]:
            return True
        else:
            return False
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>11 盛最多水的容器</title>
                <link>https://affectalways.github.io/posts/leetcode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg?ynotemdtimestamp=1593701291427&#34; alt=&#34;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;图中垂直线代表输入数组
[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [1,8,6,2,5,4,8,3,7]
输出: 49
class Solution:
    def maxArea(self, height):
        length = len(height)
        max = 0
        left_index = 0
        right_index = length - 1
        while left_index &amp;lt; right_index:
            area = min(height[left_index], height[right_index]) * (right_index - left_index)
            if max &amp;lt; area:
                max = area
            if height[left_index] &amp;lt; height[right_index]:
                while left_index &amp;lt; right_index:
                    if height[left_index] &amp;lt; height[left_index + 1]:
                        left_index = left_index + 1
                        break
                    else:
                        left_index = left_index + 1
            else:
                right_index = right_index - 1
                while right_index &amp;lt; left_index:
                    if height[right_index] &amp;lt; height[right_index - 1]:
                        right_index = right_index - 1
                        break
                    else:
                        right_index -= 1
        return max
&amp;quot;&amp;quot;&amp;quot;
时间复杂度为O(n)， 空间复杂度为O(1)
思路：left、right游标分别从列表左右两端向中间靠拢
1、计算以left、right为左右游标的容量（取游标指向的值中较小的作为容器高度）
2、比较left、right两个游标指向值的大小，较小的往下一个位置移动，
否则随便选择一个游标下移，在本程序中固定选择右边的游标下移
3、重复步骤1 的计算，直到程序结束
&amp;quot;&amp;quot;&amp;quot;
class Solution:
    def maxArea(self, height: list) -&amp;gt; int:
        max = 0
        left = 0
        right = len(height) - 1
        while left &amp;lt; right:
            l = left  #暂存左边游标的位置
            r = right  #暂存右边游标的位置
            if height[left] &amp;lt; height[right]:
                h = height[left]
                left += 1
            else:
                h = height[right]
                right -= 1
            tmp = h * (r - l)  #计算当前容器的容量
            max = tmp if tmp &amp;gt; max else max
        return max
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>12 整数转罗马数</title>
                <link>https://affectalways.github.io/posts/leetcode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 3
输出: &amp;quot;III&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 4
输出: &amp;quot;IV&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 9
输出: &amp;quot;IX&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 58
输出: &amp;quot;LVIII&amp;quot;
解释: L = 50, V = 5, III = 3.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-5&#34;&gt;示例 5：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: 1994
输出: &amp;quot;MCMXCIV&amp;quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
class Solution:
    def intToRoman(self, num):
        # store = {&#39;I&#39;: 1, &amp;quot;V&amp;quot;: 5, &amp;quot;X&amp;quot;: 10, &amp;quot;L&amp;quot;: 50, &amp;quot;C&amp;quot;: 100, &amp;quot;D&amp;quot;: 500, &amp;quot;M&amp;quot;: 1000, &amp;quot;IV&amp;quot;: 4, &amp;quot;IX&amp;quot;: 9, &amp;quot;XL&amp;quot;: 40, &amp;quot;XC&amp;quot;: 90,
        #          &amp;quot;CD&amp;quot;: 400, &amp;quot;CM&amp;quot;: 900}
        store = {1: &amp;quot;I&amp;quot;, 5: &amp;quot;V&amp;quot;, 10: &amp;quot;X&amp;quot;, 50: &#39;L&#39;, 100: &#39;C&#39;, 500: &#39;D&#39;, 1000: &#39;M&#39;, 4: &#39;IV&#39;, 9: &#39;IX&#39;, 40: &#39;XL&#39;, 90: &#39;XC&#39;,
                 400: &#39;CD&#39;,
                 900: &#39;CM&#39;}
        # store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True))
        store_list = sorted(store.keys(), reverse=True)
        print(store_list)
        result = []
        index = 0
        while True:
            for i in range(index, len(store_list)):
                value = store_list[i]
                if value &amp;lt;= num:
                    index = i
                    tmp = store_list[index]
                    num = num - tmp
                    result.append(store[tmp])
                    break
            if num == 0:
                break
        return &#39;&#39;.join(result)
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>13 罗马数转整数</title>
                <link>https://affectalways.github.io/posts/leetcode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;III&amp;quot;
输出: 3
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;IV&amp;quot;
输出: 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;IX&amp;quot;
输出: 9
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;LVIII&amp;quot;
输出: 58
解释: L = 50, V= 5, III = 3.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-5&#34;&gt;示例 5:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;MCMXCIV&amp;quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
# -*- coding: utf-8 -*-
# @Time     : 2018/12/2 16:48
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 13.py
# @Software : PyCharm 

class Solution(object):
    def romanToInt(self, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        # store = {1: &amp;quot;I&amp;quot;, 5: &amp;quot;V&amp;quot;, 10: &amp;quot;X&amp;quot;, 50: &#39;L&#39;, 100: &#39;C&#39;, 500: &#39;D&#39;, 1000: &#39;M&#39;, 4: &#39;IV&#39;, 9: &#39;IX&#39;, 40: &#39;XL&#39;, 90: &#39;XC&#39;,
        #          400: &#39;CD&#39;,
        #          900: &#39;CM&#39;}
        store = {&#39;I&#39;: 1, &amp;quot;V&amp;quot;: 5, &amp;quot;X&amp;quot;: 10, &amp;quot;L&amp;quot;: 50, &amp;quot;C&amp;quot;: 100, &amp;quot;D&amp;quot;: 500, &amp;quot;M&amp;quot;: 1000, &amp;quot;IV&amp;quot;: 4, &amp;quot;IX&amp;quot;: 9, &amp;quot;XL&amp;quot;: 40, &amp;quot;XC&amp;quot;: 90,
                 &amp;quot;CD&amp;quot;: 400, &amp;quot;CM&amp;quot;: 900}
        # store = dict(sorted(store.items(), key=lambda x: x[0], reverse=True))
        result = []
        length = len(s)
        index = 0
        while index &amp;lt; length:
            if (index +1) &amp;lt; length and (s[index] + s[index + 1]) in store.keys():
                result.append(store[s[index] + s[index + 1]])
                index += 2
            else:
                result.append(store[s[index]])
                index += 1

        tmp = 0
        for i in result:
            tmp += i
        return tmp


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    # print(solution.romanToInt(&amp;quot;III&amp;quot;))
    print(solution.romanToInt(&amp;quot;IV&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>14 最长公共前缀</title>
                <link>https://affectalways.github.io/posts/leetcode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。&lt;/p&gt;
&lt;h4 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]
输出: &amp;quot;fl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]
输出: &amp;quot;&amp;quot;
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。
# -*- coding: utf-8 -*-
# @Time     : 2018/12/2 22:48
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 14.py
# @Software : PyCharm 

class Solution:
    def longestCommonPrefix(self, strs):
        &amp;quot;&amp;quot;&amp;quot;
        :type strs: List[str]
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        length = len(strs)
        if length == 0 or (length == 1 and strs[0] == &#39;&#39;):
            return &amp;quot;&amp;quot;
        result = []

        min_length = len(min(strs, key=len))

        index = 0
        while index &amp;lt; min_length:
            flag = True
            all = None
            for value in strs:
                if all is None:
                    all = value[index]
                    continue
                if all == value[index]:
                    continue
                else:
                    flag = False
                    break

            if not flag:
                break
            else:
                index += 1
                result.append(all)
        return &#39;&#39;.join(result)


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    # print(solution.longestCommonPrefix([&amp;quot;flower&amp;quot;, &amp;quot;flow&amp;quot;, &amp;quot;flight&amp;quot;]))
    print(solution.longestCommonPrefix([&amp;quot;&amp;quot;, &amp;quot;&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>17 电话号码的字母组合</title>
                <link>https://affectalways.github.io/posts/leetcode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例:&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;输入：&amp;quot;23&amp;quot;
输出：[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].
方法：回溯
回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。

给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。

如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。
如果还有数字需要被输入：
遍历下一个数字所对应的所有映射的字母。
将当前的字母添加到组合最后，也就是 combination = combination + letter 。
重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/38567dcbb6401d88946ca974aacffb5ab27cb1ad54056f02b59016c0cc68b40f-file_1562774451350?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;问题转化成了从根节点到空节点一共有多少条路径&#34;&gt;问题转化成了从根节点到空节点一共有多少条路径；&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def letterCombinations(self, digits: str):
        if len(digits) == 0:
            return []
        number_al_dict = {
            &#39;2&#39;: &#39;abc&#39;,
            &#39;3&#39;: &#39;def&#39;,
            &#39;4&#39;: &#39;ghi&#39;,
            &#39;5&#39;: &#39;jkl&#39;,
            &#39;6&#39;: &#39;mno&#39;,
            &#39;7&#39;: &#39;pqrs&#39;,
            &#39;8&#39;: &#39;tuv&#39;,
            &#39;9&#39;: &#39;wxyz&#39;
        }
        if len(digits) == 1:
            return [i for i in number_al_dict[digits[0]]]

        tmp = []
        output = []

        def backtrack(path, next_numbers):
            if len(next_numbers) == 0:
                tmp.append(path)
                output.append(&amp;quot;&amp;quot;.join(path))
                return

            for letter in number_al_dict[next_numbers[0]]:
                # if letter in path:
                #     continue
                path.append(letter)
                backtrack(path, next_numbers[1:])
                path.pop()

        backtrack([], digits)
        return output
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>18 四数之和</title>
                <link>https://affectalways.github.io/posts/leetcode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
### 注意：

答案中不可以包含重复的四元组。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;解法1回溯法&#34;&gt;解法1：回溯法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def fourSum(self, nums, target: int):
        if len(nums) &amp;lt; 4:
            return []

        output = []

        def backtrack(path, next):
            if len(path) == 4:
                output.append(sorted(path))
                return

            for index, element in enumerate(next):
                path.append(element)
                backtrack(path, next[index + 1:])
                path.pop()

        backtrack([], nums)

        result = []
        for element in output:
            if sum(element) == target and element not in result:
                result.append(element)

        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>21 合并两个有序列表</title>
                <link>https://affectalways.github.io/posts/leetcode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
方法 2：迭代
想法

我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。

算法

首先，我们设定一个哨兵节点 &amp;quot;prehead&amp;quot; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。

在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/f6a8a3f573188706887808ef769ce3dc496e1bc3ef9b737e24498bd740442bb4-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# @Time     : 2020/3/27 23:37
# @Author   : affectalways
# @Site     : 
# @Contact  : affectalways@gmail.com
# @File     : 21_.py
# @Software : PyCharm 

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode):
        # head = ListNode(-1)
        head = ListNode(-1)
        cur = head

        while l1 and l2:
            if l1.val &amp;lt;= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next

        cur.next = l1 if l2 is None else l2
        return head.next


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head_1 = ListNode(1)
    node_2 = ListNode(2)
    node_4 = ListNode(4)
    head_1.next = node_2
    node_2.next = node_4

    head_2 = ListNode(1)
    node_3 = ListNode(3)
    node_4_copy = ListNode(4)
    head_2.next = node_3
    node_3.next = node_4_copy

    result = solution.mergeTwoLists(head_1, head_2)
    while result:
        print(result.val)
        result = result.next
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>31 下一个排列</title>
                <link>https://affectalways.github.io/posts/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。

以 1,2,3,4,5,6 为例，其排列依次为：
123456
123465
123546
...
654321
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;算法推导&#34;&gt;算法推导&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：

1.我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
2.我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
（1）在尽可能靠右的低位进行交换，需要从后向前查找
（2）将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
（3）将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
以上就是求“下一个排列”的分析过程。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;算法过程&#34;&gt;算法过程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;标准的“下一个排列”算法可以描述为：

1.从后向前查找第一个**==相邻升序==**的元素对 (i,j)，满足 A[i] &amp;lt; A[j]。此时 [j,end) 必然是降序
2.在 [j,end) 从后向前查找第一个满足 A[i] &amp;lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」
3.将 A[i] 与 A[k] 交换
4.可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序
5.如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;可视化&#34;&gt;可视化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;以求 12385764 的下一个排列为例：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/6e8c9822771be77c6f34cd3086153984eec386fb8376e09e36132ac36bb9cd6f-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先从后向前查找第一个相邻升序的元素对 (i,j)。这里 i=4，j=5，对应的值为 5，7：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/d7acefea4f7d4e2f19fb5eaa269c448a3098eee53656926a0ab592c564dde150-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;然后在 [j,end) 从后向前查找第一个大于 A[i] 的值 A[k]。这里 A[i] 是 5，故 A[k] 是 6：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/061cf291c237e6f5bcd0554192f894cd0c3e361b4564aa542aabe96e644afbf1-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将 A[i] 与 A[k] 交换。这里交换 5、6：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/eb1470fd9942da6d2ab4855d13dfadcb715b629b4ea9cba0edfe2d1298744186-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这时 [j,end) 必然是降序，逆置 [j,end)，使其升序。这里逆置 [7,5,4]：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/9d627a4ffda635bbf0c4fcdb7b1359c557db8e1c300ab54383a0bc89f6763c18-image.png?ynotemdtimestamp=1593701291427&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;因此，12385764 的下一个排列就是 12386457。

最后再可视化地对比一下这两个相邻的排列（橙色是蓝色的下一个排列）：
class Solution:
    def nextPermutation(self, nums) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        length = len(nums)
        guard = -1
        guard_index = length + 1
        index = length - 1
        while (index - 1) &amp;gt;= 0:
            if nums[index - 1] &amp;lt; nums[index]:
                guard = nums[index - 1]
                guard_index = index - 1
                break
            index = index - 1

        # print(&amp;quot;guard_index = {}, guard = {}&amp;quot;.format(guard_index, guard))
        if guard_index == (length + 1):
            return nums.sort(reverse=False)

        cur_index = length - 1
        while cur_index &amp;gt; guard_index:
            if nums[cur_index] &amp;gt; guard:
                break
            cur_index -= 1

        if cur_index &amp;gt;= length:
            cur_index = index
        nums[cur_index], nums[guard_index] = nums[guard_index], nums[cur_index]

        for i in range(guard_index + 1, length - 1):
            for j in range(guard_index + 1, length - 1):
                if nums[j] &amp;gt; nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>55 跳跃游戏</title>
                <link>https://affectalways.github.io/posts/leetcode/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
                <pubDate>Tue, 23 Jun 2020 23:05:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;解题思路&#34;&gt;解题思路：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。&lt;/li&gt;
&lt;li&gt;可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。&lt;/li&gt;
&lt;li&gt;如果可以一直跳到最后，就成功了。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def canJump(self, nums) -&amp;gt; bool:
        length = len(nums)
        k = 0
        for i in range(length):
            if i &amp;gt; k:
                return False
            k = max(k, k + nums[i])
        return True
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>单例模式</title>
                <link>https://affectalways.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
                <pubDate>Mon, 22 Jun 2020 22:28:03 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>01 两数之和相加</title>
                <link>https://affectalways.github.io/posts/leetcode/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9B%B8%E5%8A%A0/</guid>
                <pubDate>Mon, 22 Jun 2020 21:51:44 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解法一&#34;&gt;解法一&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def twoSum(self, nums, target):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        if not len(nums):
            return []
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i,j]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;解法二&#34;&gt;解法二&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;利用Python创建字典（即hash），同时有效避免了key相同的情况
class Solution:
    def twoSum(self, nums, target):
        dic = {}
        for i in range(len(nums)):
            if str(target - nums[i]) in dic:
                return [dic[str(target - nums[i])], i]
            dic[str(nums[i])] = i


&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Gunicorn 源码解析(1)</title>
                <link>https://affectalways.github.io/posts/gunicorn/gunicorn_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/gunicorn/gunicorn_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:29:06 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/gunicorn/">gunicorn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/server/">server</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/gunicorn/">gunicorn</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Celery 源码解析（1）</title>
                <link>https://affectalways.github.io/posts/celery/celery_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/celery/celery_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/celery/">celery</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（1）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（2）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_2/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（3）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_3/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_3/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（4）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_4/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_4/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（5）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_5/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_5/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Flask 源码解析（6）</title>
                <link>https://affectalways.github.io/posts/flask/flask_source_code_6/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/flask/flask_source_code_6/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/flask/">flask</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>requests 源码解析（1）</title>
                <link>https://affectalways.github.io/posts/requests/requests_source_code_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/requests/requests_source_code_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/requests/">requests</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/requests/">requests</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>WSGI 理解（1）</title>
                <link>https://affectalways.github.io/posts/wsgi/wsgi_kl_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/wsgi/wsgi_kl_1/</guid>
                <pubDate>Sat, 20 Jun 2020 11:24:01 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h2 id=&#34;wsgi-是个什么东西&#34;&gt;WSGI 是个什么东西？&lt;/h2&gt;
&lt;p&gt;实际的生产环境中，Python应用程序是放在服务器的http server（比如Apache、Nginx等）上的。现在的问题是http server（之后以服务器代称）怎么把接收到的请求传递给Python应用程序？这就是WSGI做的事情。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WSGI（Web Server Gateway Interface）&lt;/code&gt;即Web服务器网关接口，解耦了&lt;code&gt;服务器（Apache、Nginx等）&lt;/code&gt;和&lt;code&gt;Python应用程序&lt;/code&gt;，是Python开发者只需要关注Python应用程序的开发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Web Server：即HTTP Server，接收用户的请求并返回响应信息；分为以下两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器，如Apache、Nginx等&lt;/li&gt;
&lt;li&gt;Python应用程序，负责处理业务逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/wsgi/wsgi_1/wsgi_1_framework.png?raw=true&#34; alt=&#34;wsgi_framework.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/wsgi/wsgi_1/wsgi_1_wsgi.png?raw=true&#34; alt=&#34;wsgi.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-server-实现&#34;&gt;HTTP Server 实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;服务器&lt;/code&gt;每接收到一个请求就调用一次&lt;code&gt;Python Application&lt;/code&gt;。&lt;code&gt;服务器&lt;/code&gt;作用如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收HTTP请求&lt;/li&gt;
&lt;li&gt;提供&lt;code&gt;environ&lt;/code&gt;和回调函数&lt;code&gt;start_response&lt;/code&gt;，并传给&lt;code&gt;callable object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;callable object&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是&lt;a href=&#34;https://www.python.org/dev/peps/pep-3333/#the-application-framework-side&#34;&gt;PEP-3333&lt;/a&gt;提供的示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os, sys

enc, esc = sys.getfilesystemencoding(), &#39;surrogateescape&#39;

def unicode_to_wsgi(u):
    # Convert an environment variable to a WSGI &amp;quot;bytes-as-unicode&amp;quot; string
    return u.encode(enc, esc).decode(&#39;iso-8859-1&#39;)

def wsgi_to_bytes(s):
    return s.encode(&#39;iso-8859-1&#39;)


def run_with_cgi(application):
	&amp;quot;&amp;quot;&amp;quot;
		application: 是Python Application中的callable object
	&amp;quot;&amp;quot;&amp;quot;
    # 构造environ变量，dict类型，里面的内容是一次HTTP请求的环境变量
    environ = {k: unicode_to_wsgi(v) for k,v in os.environ.items()}
    environ[&#39;wsgi.input&#39;]        = sys.stdin.buffer
    environ[&#39;wsgi.errors&#39;]       = sys.stderr
    environ[&#39;wsgi.version&#39;]      = (1, 0)
    environ[&#39;wsgi.multithread&#39;]  = False
    environ[&#39;wsgi.multiprocess&#39;] = True
    environ[&#39;wsgi.run_once&#39;]     = True

    if environ.get(&#39;HTTPS&#39;, &#39;off&#39;) in (&#39;on&#39;, &#39;1&#39;):
        environ[&#39;wsgi.url_scheme&#39;] = &#39;https&#39;
    else:
        environ[&#39;wsgi.url_scheme&#39;] = &#39;http&#39;

    headers_set = []
    headers_sent = []

    # 把响应信息写到终端
    def write(data):
        out = sys.stdout.buffer

        if not headers_set:
             raise AssertionError(&amp;quot;write() before start_response()&amp;quot;)

        elif not headers_sent:
             # Before the first output, send the stored headers
             status, response_headers = headers_sent[:] = headers_set
             out.write(wsgi_to_bytes(&#39;Status: %s\r\n&#39; % status))
             for header in response_headers:
                 out.write(wsgi_to_bytes(&#39;%s: %s\r\n&#39; % header))
             out.write(wsgi_to_bytes(&#39;\r\n&#39;))

        out.write(data)
        out.flush()

    # 定义start_response回调函数
    def start_response(status, response_headers, exc_info=None):
        if exc_info:
            try:
                if headers_sent:
                    # Re-raise original exception if headers sent
                    raise exc_info[1].with_traceback(exc_info[2])
            finally:
                exc_info = None     # avoid dangling circular ref
        elif headers_set:
            raise AssertionError(&amp;quot;Headers already set!&amp;quot;)

        headers_set[:] = [status, response_headers]

        # Note: error checking on the headers should happen here,
        # *after* the headers are set.  That way, if an error
        # occurs, start_response can only be re-called with
        # exc_info set.

        return write

    result = application(environ, start_response)
    try:
        # 处理application返回的结果（可迭代）
        for data in result:
            if data:    # don&#39;t send headers until body appears
                write(data)
        if not headers_sent:
            write(&#39;&#39;)   # send headers now if body was empty
    finally:
        if hasattr(result, &#39;close&#39;):
            result.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;中间件middleware&#34;&gt;中间件Middleware&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Middlerware&lt;/code&gt;是位于&lt;code&gt;Http Server&lt;/code&gt;和&lt;code&gt;Python Application&lt;/code&gt;之间的功能组件。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;Http Server&lt;/code&gt;而言，&lt;code&gt;Middlerware&lt;/code&gt;就是应用程序；对于&lt;code&gt;Python Application&lt;/code&gt;而言，&lt;code&gt;Middlerware&lt;/code&gt;就是&lt;code&gt;Http Server&lt;/code&gt;。&lt;code&gt;Middleware&lt;/code&gt;对&lt;code&gt;Http Server&lt;/code&gt;和&lt;code&gt;Python Application&lt;/code&gt;是透明的，把从&lt;code&gt;Http Server&lt;/code&gt;接收到的请求进行处理并向后传递，一直传递给&lt;code&gt;Python Application&lt;/code&gt;，最后把&lt;code&gt;Python Application&lt;/code&gt;的处理结果返回给&lt;code&gt;Http Server&lt;/code&gt;。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/wsgi/wsgi_1/wsgiframeworkmiddleware.png?raw=true&#34; alt=&#34;wsgi_middlerware.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Middlerware&lt;/code&gt;组件可执行以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 url 把用户请求调度到不同的 Python Application 中。&lt;/li&gt;
&lt;li&gt;负载均衡，转发用户请求&lt;/li&gt;
&lt;li&gt;预处理 XSL 等相关数据&lt;/li&gt;
&lt;li&gt;限制请求速率，设置白名单&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：WSGI 的 middleware 体现了 unix 的哲学之一：do one thing and do it well。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本例实现了一个关于异常处理的 middleware（&lt;a href=&#34;https://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/&#34;&gt;摘自&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sys import exc_info
from traceback import format_tb

class ExceptionMiddleware(object):
    &amp;quot;&amp;quot;&amp;quot;The middleware we use.&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        &amp;quot;&amp;quot;&amp;quot;Call the application can catch exceptions.&amp;quot;&amp;quot;&amp;quot;
        appiter = None
        # just call the application and send the output back
        # unchanged but catch exceptions
        try:
            appiter = self.app(environ, start_response)
            for item in appiter:
                yield item
        # if an exception occours we get the exception information
        # and prepare a traceback we can render
        except:
            e_type, e_value, tb = exc_info()
            traceback = [&#39;Traceback (most recent call last):&#39;]
            traceback += format_tb(tb)
            traceback.append(&#39;%s: %s&#39; % (e_type.__name__, e_value))
            # we might have not a stated response by now. try
            # to start one with the status code 500 or ignore an
            # raised exception if the application already started one.
            try:
                start_response(&#39;500 INTERNAL SERVER ERROR&#39;, [
                               (&#39;Content-Type&#39;, &#39;text/plain&#39;)])
            except:
                pass
            yield &#39;\n&#39;.join(traceback)

        # wsgi applications might have a close function. If it exists
        # it *must* be called.
        if hasattr(appiter, &#39;close&#39;):
            appiter.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;python-application&#34;&gt;Python Application&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Python Application&lt;/code&gt;端必须定义一个 &lt;code&gt;callable object&lt;/code&gt;，&lt;code&gt;callable object&lt;/code&gt; 可以是以下三者之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function/method&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance with a __call__ method&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;callable object&lt;/code&gt;必须满足以下两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收两个参数：environ（字典，WSGI的环境信息）、start_response（响应请求的函数, 返回HTTP status、headers给server）&lt;/li&gt;
&lt;li&gt;返回一个可迭代的值（iterable）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;environ&lt;/code&gt;和&lt;code&gt;start_response&lt;/code&gt;由&lt;code&gt;http server&lt;/code&gt;提供并实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;environ&lt;/code&gt;变量是包含环境变量的字典&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Python Application&lt;/code&gt;内部在返回前调用&lt;code&gt;start_response&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_response&lt;/code&gt;也是一个callable，接收两个必要的参数，&lt;code&gt;status&lt;/code&gt;和&lt;code&gt;response_headers&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;callable-object代码实现&#34;&gt;callable object代码实现&lt;/h4&gt;
&lt;h5 id=&#34;1functionmethod&#34;&gt;1.function/method&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;def application(environ, start_response):
	# 调用服务器程序提供的 start_response，填入两个参数
	start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/json&#39;)])
	return []
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;2class&#34;&gt;2.class&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class ApplicationClass(object):
	def __init__(self, environ, start_response):
		self.environ = environ
		self.start_response = start_response
	
	def __iter__(self):
		self.start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/json&#39;)])
		yield &amp;quot;随便&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for result in ApplicationClass(environ, start_response):
    do_somthing(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h5 id=&#34;3instance-with-a-__call__-method&#34;&gt;3.instance with a &lt;strong&gt;call&lt;/strong&gt; method&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;class ApplicationClass(object):
	def __init__(self):
		pass
		
	def __call__(self, environ, start_response):
		start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/json&#39;)])
		yield &amp;quot;anything&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = ApplicationClass()
for result in app(environ, start_response):
	do_something(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;参考链接&#34;&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-3333/#the-application-framework-side&#34;&gt;PEP-3333&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/&#34;&gt;巨佬&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/wsgi/">WSGI</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/flask/">flask</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/python/">python</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/wsgi/">wsgi</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo 添加评论功能</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_comment/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_comment/</guid>
                <pubDate>Wed, 17 Jun 2020 21:48:44 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;不能评论&#34;&gt;不能评论!&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; 是一个强大的静态网页生成器，使用 go 开发，速度贼快。不过 Hugo 还比较年轻，没有像 &lt;a href=&#34;https://theme-next.iissnan.com/&#34;&gt;NexT&lt;/a&gt; 那样功能强大，成熟稳定的主题。所以很多东西需要自己动手撸。&lt;/p&gt;
&lt;p&gt;比如评论系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;评论系统排名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;valine &amp;gt; gitalk &amp;gt; gitment &amp;gt; livere &amp;gt; 畅言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于valine&#34;&gt;关于Valine&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/valine.png?raw=true&#34; alt=&#34;valine.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;官方网址： &amp;laquo;&lt;a href=&#34;https://valine.js.org/%3E%3E&#34;&gt;https://valine.js.org/&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其特性不一一赘述，官方网址有介绍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;添加评论区&#34;&gt;添加评论区&lt;/h2&gt;
&lt;p&gt;目前博客使用的主题是meme&lt;/p&gt;
&lt;p&gt;不同的主题可能有所区别，但原理大都类似&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理？&lt;/h3&gt;
&lt;p&gt;Hugo 会将 &lt;strong&gt;Markdown 文档&lt;/strong&gt; 按照 &lt;strong&gt;主题 (包括 HTML 模板、CSS、JavaScript 等)&lt;/strong&gt; 编译成静态网页&lt;/p&gt;
&lt;p&gt;那么我们只需要将 &lt;code&gt;Valine&lt;/code&gt;作为一个 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 插入到 HTML 模板中，然后在 &lt;code&gt;config.toml&lt;/code&gt; 中添加相关配置，就可以添加&lt;code&gt;评论区&lt;/code&gt;了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;leancloud相关配置&#34;&gt;Leancloud相关配置&lt;/h2&gt;
&lt;p&gt;评论系统依赖于&lt;code&gt;leancloud&lt;/code&gt;，所以需要先在&lt;code&gt;leancloud&lt;/code&gt;中进行相关的准备工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leancloud.cn/dashboard/login.html#/signin&#34;&gt;登录&lt;/a&gt; 或 &lt;a href=&#34;https://leancloud.cn/dashboard/login.html#/signup&#34;&gt;注册&lt;/a&gt; LeanCloud&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录成功后，进入后台点击左上角的创建应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud.png?raw=true&#34; alt=&#34;leancloud.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建好应用，进入应用，左边栏找到 &lt;strong&gt;设置&lt;/strong&gt; ，然后点击 &lt;strong&gt;应用Key&lt;/strong&gt;，此时记录出现的 &lt;strong&gt;App ID&lt;/strong&gt; 和 &lt;strong&gt;App Key&lt;/strong&gt;，后面配置文件中会用到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud_key.png?raw=true&#34; alt=&#34;lc_key.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 &lt;code&gt;Class&lt;/code&gt;，左边栏找到并点击 &lt;strong&gt;存储&lt;/strong&gt;，点击 &lt;strong&gt;创建Class&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud_class.png?raw=true&#34; alt=&#34;lc_class.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建两个存储Class，分别命名为: &lt;code&gt;Counter&lt;/code&gt; 和 &lt;code&gt;Comment&lt;/code&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还需要为应用添加安全域名，左边栏点击 &lt;strong&gt;设置&lt;/strong&gt;，找到 &lt;strong&gt;安全中心&lt;/strong&gt;，点击后会看到 &lt;strong&gt;安全域名&lt;/strong&gt; 设置框，输入博客使用的域名，点击保存即可：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_comment/leancloud_safe.png?raw=true&#34; alt=&#34;lc_safe.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;configtoml开启comment&#34;&gt;config.toml开启comment&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;enableComments = false&lt;/code&gt;设置为&lt;code&gt;enableComments = true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;enableValine = false&lt;/code&gt;设置为&lt;code&gt;enableValine = true&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;添加 &lt;strong&gt;Valine&lt;/strong&gt; 参数项：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;## Valine
    enableValine = true
    valineAppId = &amp;quot;************&amp;quot;
    valineAppKey = &amp;quot;*****************&amp;quot;
    valinePlaceholder = &amp;quot;Just go go&amp;quot;
    valinePath = &amp;quot;&amp;quot;
    valineAvatar = &amp;quot;mm&amp;quot;
    valineMeta = [&amp;quot;nick&amp;quot;, &amp;quot;mail&amp;quot;, &amp;quot;link&amp;quot;]
    valinePageSize = 10
    valineLang = &amp;quot;zh-cn&amp;quot;
    valineVisitor = false
    valineHighlight = true
    valineAvatarForce = false
    valineRecordIP = false
    valineServerURLs = &amp;quot;&amp;quot;
    valineEmojiCDN = &amp;quot;&amp;quot;
    valineEmojiMaps = {}
    valineEnableQQ = false
    valineRequiredFields = []
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面几项内容的含义，这里简单一说，具体还是要看 &lt;a href=&#34;https://valine.js.org/configuration.html&#34;&gt;Valine官网中配置相关的内容&lt;/a&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;这是用于主题中配置的，不是官方Valine的参数，&lt;strong&gt;true&lt;/strong&gt;时控制开启此评论系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;appId&lt;/td&gt;
&lt;td&gt;这是在 &lt;a href=&#34;https://leancloud.cn/&#34;&gt;leancloud&lt;/a&gt; 后台应用中获取的，也就是上面提到的 &lt;strong&gt;App ID&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;appKey&lt;/td&gt;
&lt;td&gt;这是在 &lt;a href=&#34;https://leancloud.cn/&#34;&gt;leancloud&lt;/a&gt; 后台应用中获取的，也就是上面提到的 &lt;strong&gt;App Key&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;notify&lt;/td&gt;
&lt;td&gt;用于控制是否开启邮件通知功能，具体参考&lt;a href=&#34;https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE&#34;&gt;邮件提醒配置&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;verify&lt;/td&gt;
&lt;td&gt;用于控制是否开启评论验证码功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;avatar&lt;/td&gt;
&lt;td&gt;用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：&lt;a href=&#34;https://valine.js.org/avatar.html&#34;&gt;头像配置&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;placehoder&lt;/td&gt;
&lt;td&gt;评论框的提示符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;visitor&lt;/td&gt;
&lt;td&gt;控制是否开启文章阅读数的统计功能i, 详情阅读&lt;a href=&#34;https://valine.js.org/visitor.html&#34;&gt;文章阅读数统计&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;修改主题文件&#34;&gt;修改主题文件&lt;/h3&gt;
&lt;p&gt;主要是修改主题中评论相关的布局文件 &lt;code&gt;themes\meme\layouts\partials\components\comments.html&lt;/code&gt;，按照 &lt;a href=&#34;https://valine.js.org/quickstart.html&#34;&gt;Valine快速开始&lt;/a&gt; 添加 &lt;strong&gt;Valine&lt;/strong&gt; 相关代码，找到以下位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ if .Site.Params.enableValine }}
{{- end }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加的 &lt;strong&gt;Valine&lt;/strong&gt; 评论的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ if .Site.Params.enableValine }}
            &amp;lt;div id=&amp;quot;vcomments&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;script src=&amp;quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
			  &amp;lt;script src=&#39;//unpkg.com/valine/dist/Valine.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
			  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
				new Valine({
					el: &#39;#vcomments&#39; ,
					appId: &#39;{{ .Site.Params.valineAppId }}&#39;,
					appKey: &#39;{{ .Site.Params.valineAppKey }}&#39;,
					notify: &#39;{{ .Site.Params.valineNotify }}&#39;, 
					verify: &#39;{{ .Site.Params.valineVerify }}&#39;, 
					avatar:&#39;{{ .Site.Params.valineAvatar }}&#39;, 
					placeholder: &#39;{{ .Site.Params.valinePlaceholder }}&#39;,
					visitor: &#39;{{ .Site.Params.valineVisitor }}&#39;
				});
			  &amp;lt;/script&amp;gt;
        {{ end }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到上述代码中引用了配置文件中的相关参数，这样以后修改配置就不用修改代码了，只需要改配置文件 &lt;code&gt;config.toml&lt;/code&gt;。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo 让 GitHub Pages被索引到</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_seo/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_seo/</guid>
                <pubDate>Wed, 17 Jun 2020 21:00:29 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h2 id=&#34;居然都找不到&#34;&gt;居然都找不到！&lt;/h2&gt;
&lt;p&gt;其实Blog我主要是用来做一些记录，突然看到有博客提到GitHub Pages屏蔽了百度的爬虫，所以百度是搜索不到GitHub Pages上的网页的。&lt;/p&gt;
&lt;p&gt;什么？所以百度搜索搜不到我的个人博客？不死心，尝试一下，找得到github、gist主页，但是就是找不到github.io后缀的网页。除了百度之外，我还尝试了Bing、Google，都没有。&lt;/p&gt;
&lt;h2 id=&#34;如何让搜索引擎索引到呢&#34;&gt;如何让搜索引擎索引到呢？&lt;/h2&gt;
&lt;p&gt;发现流行的搜索引擎居然都找不到博客，那就需要赶紧找解决方法。Google和Bing还不清楚是怎么回事，但网上流传的email回复内容都点明了Github Pages禁止了百度爬虫的爬去，似乎原因是百度爬虫爬得太过于频繁，会严重影响服务器性能。针对百度爬虫的问题，大家找了很多方法。自建服务器托管博客、将博客放在Gitlab上或者CDN方法都不在我的选择范围内，因为暂时我还没有购买服务器或者域名的打算，所以决定放弃百度……但不管怎么样Bing和Google还是要设置好的！&lt;/p&gt;
&lt;h3 id=&#34;google&#34;&gt;Google&lt;/h3&gt;
&lt;h4 id=&#34;添加资源&#34;&gt;添加资源&lt;/h4&gt;
&lt;p&gt;在google搜索页面输入“site:affectalways.github.io”就可以看到这个网页是否被google索引到，如果没被索引到，在搜索结果页面就会直接提示你使用&lt;a href=&#34;https://search.google.com/search-console?utm_source=about-page&amp;amp;resource_id=https://affectalways.github.io/&#34;&gt;Google Search Console&lt;/a&gt;。登录后，如果是首次使用在Search Console中以下界面中选择“网页”类型资源，并将博客完整url填入其中，我填入“https://affectalways.github.io”。注意http或者https，www等最好能完全正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_seo/hugo_seo_1.png?raw=true&#34; alt=&#34;hugo_seo_1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果已经添加过资源，则需要点击左上角的按钮，然后和上面一样地添加资源即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_seo/hugo_seo_2.png?raw=true&#34; alt=&#34;hugo_seo_2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;资源添加后，需要验证你对该网站有所有权。Google提供了几种方法，我选择了三种方式：&lt;/p&gt;
&lt;h5 id=&#34;html验证文件上传&#34;&gt;HTML验证文件上传&lt;/h5&gt;
&lt;p&gt;只需要根据要求，下载HTML验证文件，把文件放在站点根目录的static目录下（以本网站为例：affectalways/static）&lt;/p&gt;
&lt;h5 id=&#34;html标记&#34;&gt;HTML标记&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;中的&lt;code&gt;googleSiteVerification = &amp;quot;&amp;quot;&lt;/code&gt; 设置为 &lt;code&gt;googleSiteVerification = 不为空&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找到&lt;code&gt;themes/meme/layouts/partials/head.html&lt;/code&gt;中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{- with .Site.Params.googleSiteVerification }}

        &amp;lt;meta name=&amp;quot;google-site-verification&amp;quot; content=&amp;quot;&amp;quot; /&amp;gt;

{{- end }}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把&lt;code&gt;content&lt;/code&gt;内容改为给定的内容，然后执行&lt;code&gt;hugo&lt;/code&gt;命令，就可以验证了&lt;/p&gt;
&lt;h5 id=&#34;google-analytics&#34;&gt;Google Analytics&lt;/h5&gt;
&lt;p&gt;先到&lt;a href=&#34;https://marketingplatform.google.com/about/analytics/&#34;&gt;Google Analytics&lt;/a&gt;创建一个账号，并登录。&lt;/p&gt;
&lt;p&gt;新建一个资源，填完后获得&lt;code&gt;tracking code&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;更新&lt;code&gt;config.toml&lt;/code&gt;文件，把&lt;code&gt;enableGoogleAnalytics&lt;/code&gt;设为&lt;code&gt;true&lt;/code&gt;，&lt;code&gt;trackingCodeType&lt;/code&gt;设为&lt;code&gt;gtag&lt;/code&gt;（两个选择gtag和analytics，因为affectalways.github.io使用的是&lt;code&gt;Google Analytics给定的gtag.js&lt;/code&gt;，所以设置为gtag），&lt;code&gt;trackingID&lt;/code&gt;设为获取到的&lt;code&gt;tracking code&lt;/code&gt;。然后执行&lt;code&gt;hugo&lt;/code&gt;命令，就可以验证了。&lt;/p&gt;
&lt;h4 id=&#34;站点地图&#34;&gt;站点地图&lt;/h4&gt;
&lt;p&gt;在左侧点击“站点地图”，并在右侧点添加/测试站点地图，并添加url，我的是&lt;code&gt;https://affectalways.github.io/sitemap.xml&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;bing&#34;&gt;Bing&lt;/h3&gt;
&lt;p&gt;相似地，在&lt;a href=&#34;https://www.bing.com/webmaster/home&#34;&gt;Bing网站管理&lt;/a&gt;登陆、添加网站url。&lt;/p&gt;
&lt;p&gt;然后在左侧点击“配置我的网站&amp;gt;Sitemaps”，并在右侧加上sitemap的url，点击提交。&lt;/p&gt;
&lt;h3 id=&#34;百度不死心的尝试&#34;&gt;百度不死心的尝试&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不死心的失败了&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo 添加tags等分类</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_tags/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_tags/</guid>
                <pubDate>Wed, 17 Jun 2020 20:19:37 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;
&lt;p&gt;Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在&lt;a href=&#34;https://gohugo.io/content-management/taxonomies/&#34;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;分类taxonomy有3个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Taxonomy 分类&lt;/strong&gt;: 可以用来对内容进行分类的类别&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Term 术语&lt;/strong&gt;: 分类的一个键&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value 值&lt;/strong&gt;: 分配给这个Term的具体内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如我需要增加3个分类，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag：文章标签&lt;/li&gt;
&lt;li&gt;topic：文章主题/文章系列&lt;/li&gt;
&lt;li&gt;category：文章分类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如hugo，Value是打上这个标签的对应网页。&lt;/p&gt;
&lt;h3 id=&#34;配置分类&#34;&gt;配置分类&lt;/h3&gt;
&lt;p&gt;需要在 &lt;code&gt;config.toml&lt;/code&gt; 中增加分类。还是这个例子，则需要增加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[taxonomies]
tag = &amp;quot;tags&amp;quot;
category = &amp;quot;categories&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title: &amp;quot;Hugo添加tags等分类&amp;quot;
date: 2020-06-17T20:19:37+08:00
tags: [&amp;quot;hugo&amp;quot;]
draft: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然实际上，Hugo默认会产生 &lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt; 的分类，如果只需要这两个，可以不用在 &lt;code&gt;config.toml&lt;/code&gt; 中声明就在post头部使用。&lt;/p&gt;
&lt;h3 id=&#34;分类集合查看&#34;&gt;分类集合查看&lt;/h3&gt;
&lt;p&gt;使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。&lt;/p&gt;
&lt;p&gt;还是以tag为例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com/tags/&lt;/code&gt; 会列出tags中的所有术语；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com/tags/docker&lt;/code&gt; 会列出tags标为docker的所有网页列表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;额外知识点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;keywordsdescription&#34;&gt;keywords、description&lt;/h3&gt;
&lt;p&gt;meta标签的一个很重要的功能就是设置关键字，来帮助你的主页被各大搜索引擎登录，提高网站的访问量。在这个功能中，最重要的就是对Keywords和description的设置。因为按照搜索引擎的工作原理,搜索引擎首先派出机器人自动检索页面中的keywords和decription，并将其加入到自己的数据库，然后再根据关键词的密度将网站排序。因此，我们必须设置好关键字，来提高页面的搜索点击率。使用如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keywords: 
- hugo
- blog
- 博客
- 建站
description: &amp;quot;Hugo 添加tags等分类&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;keywords需要进行配置：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;themes\meme\layouts\partials\header.html&lt;/code&gt;的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;header class=&amp;quot;header&amp;quot;{{ if and (eq .Site.Params.headerLayout &amp;quot;flex&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部添加&lt;/p&gt;
&lt;meta content=&#34;{{ delimit .Keywords &#34;, &#34; }}&#34; name=&#34;keywords&#34;&gt;
就可以了
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;description是hugo支持的，不需要配置&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo blog（2）</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_install_2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_install_2/</guid>
                <pubDate>Tue, 16 Jun 2020 23:30:53 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;正如上一篇说的，我选择了&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;作为静态网页生成器。为何要放弃Hexo，换成Hugo呢？&lt;/p&gt;
&lt;p&gt;主要是出于以下考虑：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。&lt;/p&gt;
&lt;p&gt;2.同样得益于go，Hugo的安装配置看上去也并不麻烦；Hugo可以很轻松的被编译成二进制文件安装、运行。不必像Hexo一样依赖Node.js，也不必安装一堆依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Hugo的安装配置看上去也并不麻烦，同样得益于go，&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;p&gt;直接在&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;这里&lt;/a&gt;选择合适的版本。&lt;/p&gt;
&lt;p&gt;下载好后解压，将解压出来的可执行文件 (格式为 .exe)，放到自己喜欢的目录下。直接可以使用，不需要安装。&lt;/p&gt;
&lt;p&gt;但要记住一定要将你选择的文件夹路径加入到环境变量 &lt;code&gt;PATH&lt;/code&gt; 中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：由于theme选择的是meme，需要下载extended版本的hugo；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;初始化&#34;&gt;初始化&lt;/h1&gt;
&lt;p&gt;下面，初始化博客路径。首先需要选择一个路径来存放我们的博客，在你选好的路径下执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new site myBlog
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条命令会创建一个名为&lt;strong&gt;myBlog&lt;/strong&gt;（可以使用任意名字）的文件夹来存放你的博客。执行 &lt;strong&gt;cd myBlog&lt;/strong&gt; 命令进入文件夹。&lt;/p&gt;
&lt;p&gt;此时目录结构应该是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
└── myBlog
    ├── config.toml / config.yaml / config.json
    ├── content
    │   └── ...
    ├── layouts
    │   └── ...
    ├── themes
    │   └── ...
    ├── static
    │   └── ...
    ├── archetypes
    │   └── ...
    ├── data
    │   └── ...
    └── ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;config.toml&lt;/code&gt; 是网站的配置文件，Hugo还可使用 &lt;code&gt;config.yaml&lt;/code&gt; 或者 &lt;code&gt;config.json&lt;/code&gt; 进行配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content&lt;/code&gt; 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layouts&lt;/code&gt; 文件夹存放 &lt;code&gt;.html&lt;/code&gt; 格式的模板。模板确定了静态网站渲染的样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;themes&lt;/code&gt; 文件夹存放网站使用的theme主题模板。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;archetypes&lt;/code&gt; 文件夹存放网站预设置的文件模板头部，当使用 &lt;code&gt;hugo new&lt;/code&gt; 时即可生成一个带有该头部的实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;配置theme&#34;&gt;配置theme&lt;/h1&gt;
&lt;p&gt;可以在&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;这里&lt;/a&gt;找自己喜欢的主题。我暂时选择有搜索功能的meme，将主题clone到&lt;code&gt;themes&lt;/code&gt;目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/忘了/meme.git themes/meme
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将&lt;code&gt;themes/meme/exampleSite/config.toml&lt;/code&gt;模板配置文件复制到根目录，然后根据此文件来配置你的设置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：一定要把config.yaml中的theme修改为你使用的主体名称。比如我用的主题是meme，config.yaml文件就设置theme=&amp;quot;meme&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;创建新页面&#34;&gt;创建新页面&lt;/h1&gt;
&lt;p&gt;创建一个新页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new about.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时 &lt;code&gt;content&lt;/code&gt; 文件夹下就多了一个 &lt;code&gt;about.md&lt;/code&gt; 文件，打开文件就可以看到时间、文件名等信息已经自动生成了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;about&amp;quot;
date: 2020-06-16T23:30:53+08:00
draft: true
---
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两条 &lt;code&gt;---&lt;/code&gt; 间的信息是文章的配置信息，有的信息是自动生成的 (如：&lt;code&gt;title&lt;/code&gt;、&lt;code&gt;date&lt;/code&gt; 等)，简单介绍以下各项配置&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以下项目是自动生成的:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title:&lt;/code&gt; # 文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date:&lt;/code&gt; # 写作时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;draft:&lt;/code&gt; # 是否为草稿，如果为 &lt;code&gt;true&lt;/code&gt; 需要在命令中加入 &lt;code&gt;--buildDrafts&lt;/code&gt; 参数才会生成这个文档&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以下项目需要自行添加:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description:&lt;/code&gt; # 描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags:&lt;/code&gt; # 标签，用于文章分类&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;自动生成&lt;/code&gt; 和 &lt;code&gt;执行添加&lt;/code&gt; 的内容并不是绝对的，你可以根据自己的喜好配置模板文件 &lt;code&gt;archetypes/default.md&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;生成网站&#34;&gt;生成网站&lt;/h1&gt;
&lt;p&gt;设置完&lt;code&gt;config.toml&lt;/code&gt; 后我们执行以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo server --buildDrafts -w
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时你就可以在 &lt;code&gt;http://localhost:1313&lt;/code&gt; 访问到你的博客了。&lt;/p&gt;
&lt;p&gt;此时你的博客目录下就会多出一个&lt;code&gt;public&lt;/code&gt;目录，这是Hugo生成的网站。&lt;/p&gt;
&lt;p&gt;简单介绍一下两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--buildDrafts&lt;/code&gt;: 生成被标记为 「草稿」 的文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;: 监控更改，如果发生更改直接显示到博客上&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：但此时只能在本地访问 (相当于预览博客，如果与期望值不符，可以随时更改)，如果想发布到 &lt;code&gt;Github Pages&lt;/code&gt; 上需要先将文章配置信息中的 &lt;code&gt;draft:&lt;/code&gt; 改为 &lt;code&gt;false&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;然后执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;h1 id=&#34;github-pages部署&#34;&gt;GitHub Pages部署&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&#34;https://help.github.com/articles/user-organization-and-project-pages/&#34;&gt;这里&lt;/a&gt;，在Github Pages有四种类型，而对于非组织型用户来说有两种，一种是用户的个人网站，网页域名为 &lt;code&gt;username.github.io&lt;/code&gt;，另一种为Project的主页，网页域名为 &lt;code&gt;username.github.io/projectname&lt;/code&gt;。Github Pages对于Project主页的源码要求有了修改，现在也可以放置在master上，之前版本中必须放在&lt;code&gt;gh-pages&lt;/code&gt; 分支上，不过这里暂且不提，主要还是关心用户个人主页。&lt;/p&gt;
&lt;p&gt;这就需要你在Github上建立一个以 &lt;code&gt;username.github.io&lt;/code&gt; 为名称的repository，对于我来说就是 &lt;code&gt;affectalways.github.io&lt;/code&gt;。此外，需要将Hugo生成的所有静态网页push到这个repository的master分支上。现在就可以用这个域名打开个人网站了。&lt;/p&gt;
&lt;p&gt;Hugo没有提供自动发布到GitHub Pages的功能。需要将&lt;code&gt;public&lt;/code&gt;中的内容手动上传到Github上。&lt;/p&gt;
&lt;p&gt;首先执行命令&lt;code&gt;cd public&lt;/code&gt;进入到&lt;code&gt;public&lt;/code&gt;目录，然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
git remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git
git add .
git commit -m &amp;quot;[介绍，随便写点什么，比如日期]&amp;quot;
git push （若是第一次发布，需要用到--set-upstream）
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hugo blog（1）</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_install_1/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_install_1/</guid>
                <pubDate>Tue, 16 Jun 2020 22:55:34 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h1 id=&#34;初始&#34;&gt;初始&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;养个blog的想法从很早就有了但是&#34;&gt;养个Blog的想法从很早就有了，但是…&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;从本科开始就一直想要一个自己的Blog，一直没有行动。本身我就没有记日志的习惯，也没有需求和冲动写下什么东西，虽然有时想记下学的内容，但有道云笔记就够了，也没什么写技术博客的想法。除了很久之前偶尔在CSDN写了几篇入门级文章，也就没有其他了。此外，虽说博客最重要的是内容，但没有一个好的生态环境和前端界面设计，至少对于我而言，没有任何兴趣花时间在上面，原谅我是外观主义者。对于界面设计，CSDN或者博客园实在不敢恭维，尤其是CSDN。自建网站之前也尝试过，恩，还要使用服务器，花钱。我得承认，当时作为本科生的我，太过局限于学校课堂，并未走出去看看，对于网络信息的运用和挖掘也更多停留在看看答案、找找软件、翻翻视频的基础使用上，最多也就是查看下算法之类的。&lt;/p&gt;
&lt;p&gt;最近，特别是正式工作快一年了，更多地接触了“网络世界”的信息和知识，拓宽了实页。随着自我学习机会和时间愈少，碎片化学习和感想也愈多，加上虽然网上知识丰富，但内容驳杂，过段时间想再查找却需要对这些信息重新筛选、略感费劲，再加上工作后个人体悟良多，于是又一次萌生个人博客的想法。&lt;/p&gt;
&lt;h1 id=&#34;难产&#34;&gt;难产&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;选择恐惧症控制狂的特质决定了我家blog的难产&#34;&gt;选择恐惧症+控制狂的特质决定了我家Blog的难产&amp;hellip;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管现在有许多像知乎专栏这样现代化的界面和良好的用户群的网站可以让人直接在上面写作，但我还是更倾向于GitHub Pages，与GitHub非常紧密的关系是该倾向性很重要的原因（这对码农而言，非常有诱惑力）。&lt;/p&gt;
&lt;p&gt;GitHub Pages搭建个人博客，使用的是轻量级的静态网页，网上已经有了很多教程和方案。几天前遇到了三种方案：Jekyll、Hexo、Hugo。Jekyll据说可定制化和功能很强大，但是ruby个人真的很不能接受。Hexo是国人教程最多的，国外口碑也非常好，看到外国的一句评论说，缺点就是大多数内容都是中文，英文教程少，哈哈。Hexo是基于Node.js，对于程序员相当友好。不过这次我决定选择另一个Framework，使用Hugo。Hugo是用现在大热的go语言写的，据说编译起来比Hexo还会快很多。而且我最近在学go&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;开始&#34;&gt;开始&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;开始吧&#34;&gt;开始吧&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;那就开始吧&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>使用Hugo &#43; GitHub Pages搭建个人博客</title>
                <link>https://affectalways.github.io/posts/hugo/hugo_install/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/hugo/hugo_install/</guid>
                <pubDate>Tue, 16 Jun 2020 22:40:14 &#43;0800</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://github.com/affectalways/affectalways.github.io/blob/master/images/hugo/hugo_install/hugo.png?raw=true&#34; alt=&#34;hugo.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	Hugo：是一种通用的网站框架。严格来说，这类应用应该被称作静态网站生成器。这类应用将 Markdown 文件和主题一起编译成由 HTML、CSS、JavaScript 组成的静态网页。&lt;/p&gt;
&lt;p&gt;​	然后上传到 GitHub 上，通过 GitHub 提供的静态页面托管服务 (GitHub Pages) 进行访问。&lt;/p&gt;
&lt;p&gt;​	这里就写一篇文章来记录一下踩过的坑。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/blog/">blog</category>
                                
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/categories/hugo/">hugo</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://affectalways.github.io/tags/hugo/">hugo</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;面试题-0202-返回倒数第-k-个节点httpsleetcode-cncomproblemskth-node-from-end-of-list-lcci&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/&#34;&gt;面试题 02.02. 返回倒数第 k 个节点&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;实现一种算法找出单向链表中倒数第-k-个节点返回该节点的值&#34;&gt;实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。&lt;/h4&gt;
&lt;p&gt;注意：本题相对原题稍作改动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2
输出： 4
说明：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定的 k 保证是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经典的快慢指针问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
反向思考，既然是寻找倒数第K个，那么计算机只能循环后移，不如我们先将位置确定，让其同步后移到链尾。
设置前后指针都先指向头结点，后指针先移动到第K个结点，那么前后指针此时相距K个位置。同步后移，当后指针指向链尾时，前指针就自然指向倒数第K个结点
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;class Solution(object):
    def kthToLast(self, head, k):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :type k: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if head is None:
            return None

        left = head
        right = head
        count = 0
        while count &amp;lt; k:
            right = right.next
            count += 1
        while right:
            left = left.next
            right = right.next
        return left.val
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/1108-ip%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/1108-ip%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1108-ip-地址无效化httpsleetcode-cncomproblemsdefanging-an-ip-address&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/defanging-an-ip-address/&#34;&gt;1108. IP 地址无效化&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个有效的 &lt;a href=&#34;https://baike.baidu.com/item/IPv4&#34;&gt;IPv4&lt;/a&gt; 地址 &lt;code&gt;address&lt;/code&gt;，返回这个 IP 地址的无效化版本。&lt;/p&gt;
&lt;p&gt;所谓无效化 IP 地址，其实就是用 &lt;code&gt;&amp;quot;[.]&amp;quot;&lt;/code&gt; 代替了每个 &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：address = &amp;quot;1.1.1.1&amp;quot;
输出：&amp;quot;1[.]1[.]1[.]1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：address = &amp;quot;255.100.50.0&amp;quot;
输出：&amp;quot;255[.]100[.]50[.]0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给出的 &lt;code&gt;address&lt;/code&gt; 是一个有效的 IPv4 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def defangIPaddr(self, address):
        &amp;quot;&amp;quot;&amp;quot;
        :type address: str
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        return address.replace(&#39;.&#39;, &#39;[.]&#39;)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1252-奇数值单元格的数目httpsleetcode-cncomproblemscells-with-odd-values-in-a-matrix&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/&#34;&gt;1252. 奇数值单元格的数目&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个&lt;code&gt;n&lt;/code&gt;行&lt;code&gt;m&lt;/code&gt;列的矩阵，最开始的时候，每个单元格中的值都是&lt;code&gt; 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另有一个索引数组&lt;code&gt; indices&lt;/code&gt;，&lt;code&gt;indices[i] = [ri, ci]&lt;/code&gt; 中的 &lt;code&gt;ri&lt;/code&gt; 和 &lt;code&gt;ci&lt;/code&gt; 分别表示指定的行和列（从 &lt;code&gt;0&lt;/code&gt; 开始编号）。&lt;/p&gt;
&lt;p&gt;你需要将每对 &lt;code&gt;[ri, ci]&lt;/code&gt; 指定的行和列上的所有单元格的值加 &lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请你在执行完所有 &lt;code&gt;indices&lt;/code&gt; 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 2, m = 3, indices = [[0,1],[1,1]]
输出：6
解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 2, m = 2, indices = [[1,1],[0,0]]
输出：0
解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;提示：

1 &amp;lt;= n &amp;lt;= 50
1 &amp;lt;= m &amp;lt;= 50
1 &amp;lt;= indices.length &amp;lt;= 100
0 &amp;lt;= indices[i][0] &amp;lt; n
0 &amp;lt;= indices[i][1] &amp;lt; m

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def oddCells(self, n, m, indices):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: int
        :type m: int
        :type indices: List[List[int]]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        recy = [[0 for i in range(m)] for j in range(n)]

        for item in indices:
            for x in range(n):
                recy[x][item[1]] += 1

            for y in range(m):
                recy[item[0]][y] += 1

        count = 0
        for i in range(n):
            for j in range(m):
                if recy[i][j] % 2 == 1:
                    count += 1

        return count
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1281-整数的各位积和之差httpsleetcode-cncomproblemssubtract-the-product-and-sum-of-digits-of-an-integer&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/&#34;&gt;1281. 整数的各位积和之差&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 234
输出：15 
解释：
各位数之积 = 2 * 3 * 4 = 24 
各位数之和 = 2 + 3 + 4 = 9 
结果 = 24 - 9 = 15
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 4421
输出：21
解释： 
各位数之积 = 4 * 4 * 2 * 1 = 32 
各位数之和 = 4 + 4 + 2 + 1 = 11 
结果 = 32 - 11 = 21


&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;提示：

1 &amp;lt;= n &amp;lt;= 10^5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def subtractProductAndSum(self, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        mul = 1
        ad = 0
        while n &amp;gt; 0:
            tmp = n % 10
            mul *= tmp
            ad += tmp
            n //= 10
        return mul - ad
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/1323-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/1323-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1323-6-和-9-组成的最大数字httpsleetcode-cncomproblemsmaximum-69-number&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/maximum-69-number/&#34;&gt;1323. 6 和 9 组成的最大数字&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个仅由数字 6 和 9 组成的正整数 num。&lt;/p&gt;
&lt;p&gt;你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。&lt;/p&gt;
&lt;p&gt;请返回你可以得到的最大数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：num = 9669
输出：9969
解释：
改变第一位数字可以得到 6669 。
改变第二位数字可以得到 9969 。
改变第三位数字可以得到 9699 。
改变第四位数字可以得到 9666 。
其中最大的数字是 9969 。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：num = 9996
输出：9999
解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：num = 9999
输出：9999
解释：无需改变就已经是最大的数字了。
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;提示：

1 &amp;lt;= num &amp;lt;= 10^4
num 每一位上的数字都是 6 或者 9 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def maximum69Number(self, num):
        &amp;quot;&amp;quot;&amp;quot;
        :type num: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        return int(str(num).replace(&#39;6&#39;, &#39;9&#39;, 1))

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1431-拥有最多糖果的孩子httpsleetcode-cncomproblemskids-with-the-greatest-number-of-candies&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/&#34;&gt;1431. 拥有最多糖果的孩子&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。&lt;/p&gt;
&lt;p&gt;对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：candies = [2,3,5,1,3], extraCandies = 3
输出：[true,true,true,false,true] 
解释：
孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：candies = [4,2,1,1,2], extraCandies = 1
输出：[true,false,false,false,false] 
解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：candies = [12,1,12], extraCandies = 10
输出：[true,false,true]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 &amp;lt;= candies.length &amp;lt;= 100
1 &amp;lt;= candies[i] &amp;lt;= 100
1 &amp;lt;= extraCandies &amp;lt;= 50
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):
        &amp;quot;&amp;quot;&amp;quot;
        :type candies: List[int]
        :type extraCandies: int
        :rtype: List[bool]
        &amp;quot;&amp;quot;&amp;quot;
        max_val = max(candies)
        result = [False] * len(candies)
        for index, item in enumerate(candies):
            if (item + extraCandies) &amp;gt;= max_val:
                result[index] = True
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/1480-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/1480-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;1480-一维数组的动态和httpsleetcode-cncomproblemsrunning-sum-of-1d-array&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/running-sum-of-1d-array/&#34;&gt;1480. 一维数组的动态和&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给你一个数组 &lt;code&gt;nums &lt;/code&gt;。数组&lt;code&gt;「动态和」&lt;/code&gt;的计算公式为：&lt;code&gt;runningSum[i] = sum(nums[0]…nums[i]) &lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请返回 &lt;code&gt;nums&lt;/code&gt; 的&lt;code&gt;动态和&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;提示：

1 &amp;lt;= nums.length &amp;lt;= 1000
-10^6 &amp;lt;= nums[i] &amp;lt;= 10^6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def runningSum(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        if not nums:
            return []
        result = list()
        result.append(nums[0])
        for ind in range(1, len(nums)):
            result.append(result[ind - 1] + nums[ind])
        return result
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/58offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/58offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;剑指-offer-58---ii-左旋转字符串httpsleetcode-cncomproblemszuo-xuan-zhuan-zi-fu-chuan-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/&#34;&gt;剑指 Offer 58 - II. 左旋转字符串&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;abcdefg&amp;quot;, k = 2
输出: &amp;quot;cdefgab&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;lrloseumgh&amp;quot;, k = 6
输出: &amp;quot;umghlrlose&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;限制：

1 &amp;lt;= k &amp;lt; s.length &amp;lt;= 10000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def reverseLeftWords(self, s, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :type n: int
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        return s[n:] + s[:n]


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    result = solution.reverseLeftWords(s=&amp;quot;abcdefg&amp;quot;, n=2)
    print(result)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/lcp-01-%E7%8C%9C%E6%95%B0%E5%AD%97/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/lcp-01-%E7%8C%9C%E6%95%B0%E5%AD%97/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;h4 id=&#34;lcp-01-猜数字httpsleetcode-cncomproblemsguess-numbers&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/guess-numbers/&#34;&gt;LCP 01. 猜数字&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？&lt;/p&gt;
&lt;p&gt;输入的&lt;code&gt;guess&lt;/code&gt;数组为 小A 每次的猜测，&lt;code&gt;answer&lt;/code&gt;数组为 小B 每次的选择。&lt;code&gt;guess&lt;/code&gt;和&lt;code&gt;answer&lt;/code&gt;的长度都等于3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：guess = [1,2,3], answer = [1,2,3]
输出：3
解释：小A 每次都猜对了。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：guess = [2,2,3], answer = [3,2,1]
输出：1
解释：小A 只猜对了第二次。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;guess的长度 = 3
answer的长度 = 3
guess的元素取值为 {1, 2, 3} 之一。
answer的元素取值为 {1, 2, 3} 之一。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def game(self, guess, answer):
        &amp;quot;&amp;quot;&amp;quot;
        :type guess: List[int]
        :type answer: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        count = 0
        for index in range(len(guess)):
            if guess[index] == answer[index]:
                count += 1

        return count
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/0207-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;title: &amp;quot;0207 链表相交&amp;quot;
date: 2020-07-15T21:20:33+08:00
tags: [&amp;quot;leetcode&amp;quot;]
keywords: 
- leetcode
- blog
- 博客
- 领扣
- 0207 链表相交
- 算法
description: &amp;quot;leetcode，0207 链表相交&amp;quot;
categories: [&amp;quot;leetcode&amp;quot;]
draft: false
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;面试题-0207-链表相交httpsleetcode-cncomproblemsintersection-of-two-linked-lists-lcci&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/&#34;&gt;面试题 02.07. 链表相交&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;我竟然没读懂题！！！！！！！！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1.如果两个链表没有交点，返回 null 。
 2.在返回结果后，两个链表仍须保持原有的结构。
 3.可假定整个链表结构中没有循环。
 4.程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;双指针什么的，技巧性有点强。最朴素的做法是求长度

1.第一次遍历两个链表，记录长度
2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步
3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:

    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; ListNode:
        len_a = 0
        len_b = 0
        cur_a = headA
        cur_b = headB
        
        # 1.第一次遍历两个链表，记录长度
        while cur_a:
            len_a += 1
            cur_a = cur_a.next

        while cur_b:
            len_b += 1
            cur_b = cur_b.next
            
		# 2.根据两个链表的长度，得出长度差n,让长的链表的指针先走n步
        cur_a = headA
        cur_b = headB
        while len_b &amp;gt; len_a:
            cur_b = cur_b.next
            len_b -= 1
        while len_a &amp;gt; len_b:
            cur_a = cur_a.next
            len_a -= 1
		# 3.然后两个指针一起移动，判断两者是否相等（指向同一个内存地址）
        while cur_a:
            if cur_a == cur_b:
                return cur_a

            cur_a = cur_a.next
            cur_b = cur_b.next

        return None

def create_list(sequence):
    headA = None
    cur = None
    for i in sequence:
        node = ListNode(i)
        if headA is None:
            headA = cur = node
            continue
        cur.next = node
        cur = cur.next
    return headA


if __name__ == &#39;__main__&#39;:
    intersectVal = 8
    listA = [4, 1, 8, 4, 5]
    headA = create_list(listA)
    listB = [5, 0, 1, 8, 4, 5]
    headB = create_list(listB)
    skipA = 2
    skipB = 3

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
                <guid isPermaLink="true">https://affectalways.github.io/posts/leetcode/%E9%93%BE%E8%A1%A8/offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>affectalways@gmail.com (affectalways)</author>
                
                <copyright>@2020 affectalways</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;title: &amp;quot;Offer 06. 从尾到头打印链表&amp;quot;
date: 2020-07-15T21:20:33+08:00
tags: [&amp;quot;leetcode&amp;quot;]
keywords: 
- leetcode
- blog
- 博客
- 领扣
- Offer 06. 从尾到头打印链表
- 算法
description: &amp;quot;leetcode，Offer 06. 从尾到头打印链表&amp;quot;
categories: [&amp;quot;leetcode&amp;quot;]
draft: false

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;剑指-offer-06-从尾到头打印链表httpsleetcode-cncomproblemscong-wei-dao-tou-da-yin-lian-biao-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/&#34;&gt;剑指 Offer 06. 从尾到头打印链表&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,3,2]
输出：[2,3,1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 &amp;lt;= 链表长度 &amp;lt;= 10000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 方法一：栈
栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。

创建一个栈，用于存储链表的节点
创建一个指针，初始时指向链表的头节点
当指针指向的元素非空时，重复下列操作：
将指针指向的节点压入栈内
将指针移到当前节点的下一个节点
获得栈的大小 size，创建一个数组 print，其大小为 size
创建下标并初始化 index = 0
重复 size 次下列操作：
从栈内弹出一个节点，将该节点的值存到 print[index]
将 index 的值加 1
返回 print


## 复杂性分析

时间复杂度：O(n)O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。
空间复杂度：O(n)O(n)。额外使用一个栈存储链表中的每个节点。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def reversePrint(self, head):
        &amp;quot;&amp;quot;&amp;quot;
        :type head: ListNode
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        if head is None:
            return []
        stack = []
        while head:
            stack.append(head.val)
            head = head.next

        stack.reverse()
        return stack
        # result = None
        # cur = None
        # for node in stack:
        #     if result is None:
        #         result = node
        #         cur = result
        #         continue
        #     cur.next = node
        #     cur = cur.next
        # return result


def create_list(sequence):
    headA = None
    cur = None
    for i in sequence:
        node = ListNode(i)
        if headA is None:
            headA = cur = node
            continue
        cur.next = node
        cur = cur.next
    return headA


if __name__ == &#39;__main__&#39;:
    solution = Solution()
    head = create_list([1, 3, 2])
    result = solution.reversePrint(head)

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
